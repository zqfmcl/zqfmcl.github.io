<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Fey&#39;s blog">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fey&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/">





  <title>Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/07/2019-10-07-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/2019-10-07-ES6/" itemprop="url">ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-07T10:00:00+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>个人es6总结，大多是看阮老师的博客，总结了自己认为重要的部分</p>
</blockquote>
<h2 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h2><p>let和const注意：只有在<code>{}</code>中才有作用域（if单语句不加{}  不能用let）</p>
<pre><code class="javascript">if(1) let i = 1
Uncaught SyntaxError: Unexpected identifier</code></pre>
<p>const表示常量必须在<strong>定义的时候赋值</strong>，且<strong>不能修改</strong>，否则报错</p>
<h3 id="重复定义会报错"><a href="#重复定义会报错" class="headerlink" title="重复定义会报错"></a>重复定义会报错</h3><pre><code class="javascript">// 报错
function () {
  let a = 10;
  var a = 1;
}

function () {
  var a = 10;
  let a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}

function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}</code></pre>
<h3 id="for的特殊性"><a href="#for的特殊性" class="headerlink" title="for的特殊性"></a>for的特殊性</h3><pre><code class="javascript">for (var i = 0; i &lt; 3; i++) {
  setTimeout(function(){console.log(i)},0)
}
//3 3 3 

for (let i = 0; i &lt; 3; i++) {
  setTimeout(function(){console.log(i)},0)
}
//0 1 2 </code></pre>
<p><code>for</code>循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = &#39;abc&#39;;
  console.log(i);
}</code></pre><h3 id="无变量提升"><a href="#无变量提升" class="headerlink" title="无变量提升"></a>无变量提升</h3><p><code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code class="javascript">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;</code></pre>
<h3 id="暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="暂时性死区（temporal dead zone，简称 TDZ）"></a>暂时性死区（temporal dead zone，简称 TDZ）</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre><code class="javascript">var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}

if (true) {
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}</code></pre>
<h3 id="typeof不再绝对安全"><a href="#typeof不再绝对安全" class="headerlink" title="typeof不再绝对安全"></a>typeof不再绝对安全</h3><p>在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。如果一个变量用let申明，但是在typeof之后，typeof<code>运行时就会抛出一个</code>ReferenceError`。</p>
<h3 id="立即执行函数不必要"><a href="#立即执行函数不必要" class="headerlink" title="立即执行函数不必要"></a>立即执行函数不必要</h3><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<pre><code class="javascript">// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}</code></pre>
<h3 id="不属于顶层对象"><a href="#不属于顶层对象" class="headerlink" title="不属于顶层对象"></a>不属于顶层对象</h3><p><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code class="javascript">var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined</code></pre>
<h3 id="const本质"><a href="#const本质" class="headerlink" title="const本质"></a>const本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，<strong>而是变量指向的那个内存地址不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，<strong>至于它指向的数据结构是不是可变的，就完全不能控制了</strong>。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="javascript">const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: &quot;foo&quot; is read-only</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错</code></pre>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="javascript">const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;</code></pre>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="javascript">var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};</code></pre>
<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h2><h2 id="数组型"><a href="#数组型" class="headerlink" title="[]数组型"></a>[]数组型</h2><p>只要<strong>形式一样就能结构成功</strong>，右边多没事，右边少就会有<code>undefined</code></p>
<pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []</code></pre>
<p><code>...</code>表示rest元素数组。</p>
<h3 id="右边可以是字符串"><a href="#右边可以是字符串" class="headerlink" title="右边可以是字符串"></a>右边可以是字符串</h3><p>因为字符串是一个类数组，有length</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;</code></pre>
<h3 id="右边不可遍历，出错"><a href="#右边不可遍历，出错" class="headerlink" title="右边不可遍历，出错"></a>右边不可遍历，出错</h3><p>如果等号的右边不是数组（或者严格地说，<strong>不是可遍历的结构</strong>，参见《Iterator》一章），那么将会报错。</p>
<pre><code class="javascript">// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};</code></pre>
<p>事实上，只要某种数<strong>据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong>Generator是原生具有iterator接口的</p>
<pre><code class="javascript">function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5</code></pre>
<h3 id="解构允许默认值"><a href="#解构允许默认值" class="headerlink" title="解构允许默认值"></a>解构允许默认值</h3><p>ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员<strong>不严格</strong>等于<code>undefined</code>，默认值是不会生效的。(<strong>比如null</strong>)</p>
<pre><code class="javascript">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;

let [x = 1] = [null];
x // null</code></pre>
<h2 id="对象型"><a href="#对象型" class="headerlink" title="{}对象型"></a>{}对象型</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="javascript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined</code></pre>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code class="javascript">var { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;</code></pre>
<p>这实际上说明，对象的解构赋值是下面形式的简写（<strong>前面是模式，后面是真实变量</strong>）</p>
<pre><code class="javascript">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };</code></pre>
<h3 id="不在声明使用需要加括号"><a href="#不在声明使用需要加括号" class="headerlink" title="不在声明使用需要加括号"></a>不在声明使用需要加括号</h3><p>由于<code>{}</code>的二义性，所以在<code>{}</code>开头的特殊语句，需要加上<code>()</code></p>
<pre><code class="javascript">let foo;
({foo} = {foo: 1}); // 成功


let baz;
{bar: baz} = {bar: 1}; //报错</code></pre>
<h3 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h3><p>和数组一样，解构也可以用于嵌套结构的对象。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;</code></pre><p>注意，这时<code>p</code>是<strong>模式</strong>，不是变量，因此不会被赋值。</p>
<h3 id="允许默认值"><a href="#允许默认值" class="headerlink" title="允许默认值"></a>允许默认值</h3><pre><code class="javascript">var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5</code></pre>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<pre><code class="javascript">let {length : len} = &#39;hello&#39;;
len // 5

let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3</code></pre>
<h3 id="数字字符串"><a href="#数字字符串" class="headerlink" title="数字字符串"></a>数字字符串</h3><p>解构赋值时，如果等号右边是数值和布尔值，<strong>则会先转为对象。</strong></p>
<pre><code class="javascript">let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true</code></pre>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code class="javascript">let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError</code></pre>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><p>写法不仅简洁，而且易读，语义非常清晰。</p>
<pre><code class="javascript">let x = 1;
let y = 2;
[x, y] = [y, x];</code></pre>
<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><pre><code class="javascript">// 返回一个数组
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象
function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();</code></pre>
<h3 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h3><p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code class="javascript">// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});</code></pre>
<h3 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h3><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<pre><code class="javascript">let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]</code></pre>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><pre><code class="javascript">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h3 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h3><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="javascript">var map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="javascript">// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...</code></pre>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="unicode字符问题"><a href="#unicode字符问题" class="headerlink" title="unicode字符问题"></a>unicode字符问题</h2><h3 id="增加了四字节unicode表示"><a href="#增加了四字节unicode表示" class="headerlink" title="增加了四字节unicode表示"></a>增加了四字节unicode表示</h3><p>es5有<code>\uxxxx</code>表示unicode，但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。es6加入了<strong>大括号表示</strong></p>
<pre><code class="javascript">&#39;\u{1F680}&#39; === &#39;\uD83D\uDE80&#39;</code></pre>
<h3 id="码点表示"><a href="#码点表示" class="headerlink" title="码点表示"></a>码点表示</h3><p>charPointAt();</p>
<p>String.fromCodePoint();</p>
<p>这些都是基于码点的，可以完整返回四字节Unicode。</p>
<h3 id="for-of遍历"><a href="#for-of遍历" class="headerlink" title="for of遍历"></a>for of遍历</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p>
<pre><code class="javascript">for (let codePoint of &#39;foo&#39;) {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;</code></pre>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<pre><code>var s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true

</code></pre><p>这三个方法都<strong>支持第二个参数，表示开始搜索的位置。</strong></p>
<pre><code>var s = &#39;Hello world!&#39;;

s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false

</code></pre><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<pre><code>&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre><p>参数如果是小数，会被取整。</p>
<pre><code>&#39;na&#39;.repeat(2.9) // &quot;nana&quot;

</code></pre><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<pre><code>&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError

</code></pre><p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。</p>
<pre><code>&#39;na&#39;.repeat(-0.9) // &quot;&quot;

</code></pre><p>参数<code>NaN</code>等同于0。</p>
<pre><code>&#39;na&#39;.repeat(NaN) // &quot;&quot;

</code></pre><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<pre><code>&#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot;
&#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot;
</code></pre><h3 id="padStart和padEnd（ES2017）"><a href="#padStart和padEnd（ES2017）" class="headerlink" title="padStart和padEnd（ES2017）"></a>padStart和padEnd（ES2017）</h3><p>ES2017 引入了字符串补全长度的功能（chrome可以使用了，node v6.3.1没实现该api）</p>
<p>如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre><p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>如果补串超长，自动截去超过部分  </li>
<li>如果原字符串长度&gt;=最小长度，则返回原字符串</li>
<li>如果忽略第二参数，默认用空格补</li>
</ol>
<pre><code class="javascript">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)  // &#39;0123456abc&#39;
&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;
&#39;x&#39;.padStart(4) // &#39;   x&#39;</code></pre>
<p><code>padStart</code>的常见用途是为数值补全指定位数。另一个用途是提示字符串格式。</p>
<pre><code class="javascript">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;</code></pre>
<h2 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h2><p>我觉得es6在字符串里引入的最大的变化就是模板字符串，通过`` 表示，模板字符串有几大特性：</p>
<h3 id="可以换行"><a href="#可以换行" class="headerlink" title="可以换行"></a>可以换行</h3><pre><code class="javascript">$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());</code></pre>
<h3 id="可以嵌入js变量"><a href="#可以嵌入js变量" class="headerlink" title="可以嵌入js变量"></a>可以嵌入js变量</h3><p>通过<code>${}</code>可以嵌入js对象，允许使用运算符，可以使用函数（返回值）</p>
<pre><code class="javascript">  //传统写法
&#39;User &#39;
      + user.name
      + &#39; is not authorized to do &#39;
      + action
      + &#39;.&#39;

//ES6写法
`User ${user.name} is not authorized to do ${action}.`);


function fn() {
  return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar

function fn2() {}
`test ${fn2()}`
// test undefined
`${fn2}`
// function fn2() {}


var x = 1;
var y = 2;

`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;

`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;</code></pre>
<p>如果变量没申明，则会报错</p>
<pre><code class="javascript">// 变量place没有声明
var msg = `Hello, ${place}`;
// 报错</code></pre>
<h3 id="需要转义"><a href="#需要转义" class="headerlink" title="需要转义"></a>需要转义</h3><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code class="javascript">var greeting = `\`Yo\` World!`;</code></pre>
<h3 id="【高级】模板嵌套"><a href="#【高级】模板嵌套" class="headerlink" title="【高级】模板嵌套"></a>【高级】模板嵌套</h3><p>模板字符串甚至还能嵌套。</p>
<pre><code class="javascript">const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join(&#39;&#39;)}
  &lt;/table&gt;
`;

const data = [
    { first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; },
    { first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; },
];

console.log(tmpl(data));
// &lt;table&gt;
//
//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
//
//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
//
// &lt;/table&gt;</code></pre>
<h3 id="【高级】标签模板"><a href="#【高级】标签模板" class="headerlink" title="【高级】标签模板"></a>【高级】标签模板</h3><p>实际就是将模板跟在函数名后，将会调用函数来执行这个模板</p>
<pre><code class="javascript">var a = 5;
var b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);</code></pre>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中<strong>那些没有变量替换的部分</strong>，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>
<p><code>tag</code>函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p><a href="http://es6.ruanyifeng.com/#docs/string#标签模板" target="_blank" rel="noopener">具体看这里</a></p>
<p>利用标签模板，<strong>理论上可以在javascript里面加载别的语言代码：</strong></p>
<pre><code class="javascript">function java(...){

}

java`
class HelloWorldApp {
  public static void main(String[] args) {
    System.out.println(“Hello World!”); // Display the string.
  }
}
`
HelloWorldApp.main();</code></pre>
<h3 id="String-raw调用标签模板"><a href="#String-raw调用标签模板" class="headerlink" title="String.raw调用标签模板"></a>String.raw调用标签模板</h3><p>单独使用标签模板无法自动把里面的参数转换成字符串，所以ES6原生提供了一个<code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回<strong>一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串</strong>，对应于替换变量后的模板字符串。</p>
<pre><code class="javascript">String.raw`Hi\n${2+3}!`;
// &quot;Hi\\n5!&quot;

String.raw`Hi\u000A!`;
// &#39;Hi\\u000A!&#39;</code></pre>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。</p>
<pre><code class="javascript">String.raw`Hi\\n`
// Hi\\n
//也就是&quot;Hi\n&quot;     //这里\n已经是转义过的，否则会换行，比如看下面的例子

`Hi\n${2+3}!`;
&quot;Hi
5!&quot;</code></pre>
<p>由于它会自动转换斜杠，所以利于用来方便下一步做字符串。</p>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>加入了大量特性都是跟unicode有关的，增加了一个<code>flags</code>属性返回正则的修饰符比如<code>gi</code>，加入了新的粘连（sticky）修饰符<code>y</code>,<code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code class="javascript">var s = &#39;aaa_aa_a&#39;;
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null

var s = &#39;aaa_aa_a&#39;;
var r = /a+_/y;

r.exec(s) // [&quot;aaa_&quot;]
r.exec(s) // [&quot;aa_&quot;]</code></pre>
<p>进一步说，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<pre><code>/b/y.exec(&#39;aba&#39;)
// null

</code></pre><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<pre><code>var r = /hello\d/y;
r.sticky // true
</code></pre><h3 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h3><p>在ES5中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<pre><code class="javascript">var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;);
// 等价于
var regex = /xyz/i;</code></pre>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<pre><code class="javascript">var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;</code></pre>
<p>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。</p>
<pre><code class="javascript">var regex = new RegExp(/xyz/, &#39;i&#39;);
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</code></pre>
<p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<pre><code class="javascript">new RegExp(/abc/ig, &#39;i&#39;).flags
// &quot;i&quot;</code></pre>
<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="八进制和二进制"><a href="#八进制和二进制" class="headerlink" title="八进制和二进制"></a>八进制和二进制</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>
<pre><code class="javascript">0b111110111 === 503 // true
0o767 === 503 // true</code></pre>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<pre><code class="javascript">Number(&#39;0b111&#39;)  // 7
Number(&#39;0o10&#39;)  // 8</code></pre>
<h3 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h3><p>ES6在Number对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法<strong>只对数值有效</strong>，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code></p>
<pre><code class="javascript">isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false</code></pre>
<p>可以这样部署isFinite()，isNaN类似</p>
<pre><code class="javascript">(function (global) {
  var global_isFinite = global.isFinite;

  Object.defineProperty(Number, &#39;isFinite&#39;, {
    value: function isFinite(value) {
      return typeof value === &#39;number&#39; &amp;&amp; global_isFinite(value);
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
})(this);</code></pre>
<h3 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h3><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。这样做的目的，<strong>是逐步减少全局性方法，使得语言逐步模块化。</strong></p>
<pre><code class="javascript">// ES5的写法
parseInt(&#39;12.34&#39;) // 12
parseFloat(&#39;123.45#&#39;) // 123.45

// ES6的写法
Number.parseInt(&#39;12.34&#39;) // 12
Number.parseFloat(&#39;123.45#&#39;) // 123.45

Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true</code></pre>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以<strong>3和3.0被视为同一个值。</strong></p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.0) // true
Number.isInteger(25.1) // false
Number.isInteger(&quot;15&quot;) // false
Number.isInteger(true) // false
</code></pre><p>ES5可以通过下面的代码，部署<code>Number.isInteger()</code>。</p>
<pre><code class="javascript">(function (global) {
   ……
  Object.defineProperty(Number, &#39;isInteger&#39;, {
    value: function isInteger(value) {
      return typeof value === &#39;number&#39; &amp;&amp; isFinite(value) &amp;&amp;
        value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp;
        floor(value) === value;
    },
    ……
  });
})(this);</code></pre>
<h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>
<pre><code class="javascript">Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &#39;0.00000000000000022204&#39;</code></pre>
<p>引入一个这么小的量的目的，<strong>在于为浮点数计算，设置一个误差范围</strong>。我们知道浮点数计算是不精确的。但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>
<h3 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h3><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。上面代码中，超出2的53次方之后，一个数就不精确了。ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<pre><code class="javascript">Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true</code></pre>
<p>上面代码中，可以看到JavaScript能够精确表示的极限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<h2 id="Math扩展"><a href="#Math扩展" class="headerlink" title="Math扩展"></a>Math扩展</h2><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分（原理就是根据正负调用floor和ceil），对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。</p>
<pre><code class="javascript">Math.trunc(4.1) // 4
Math.trunc(-4.1) // -4
Math.trunc(-0.1234) // -0
Math.trunc(&#39;123.456&#39;)// 123
Math.trunc(NaN);      // NaN
Math.trunc(&#39;foo&#39;);    // NaN
Math.trunc();         // NaN</code></pre>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p><code>Math.sign</code>方法用来判断一个数到底是<strong>正数、负数、还是零</strong>。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<h3 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h3><p><code>Math.cbrt</code>方法用于计算一个数的<strong>立方根</strong> Math.pow(Math.abs(x), 1/3)</p>
<h3 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式<strong>有多少个前导0</strong>。<code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representations of a number“（计算32位整数的前导0）的缩写。左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>
<pre><code class="javascript">Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 &lt;&lt; 1) // 30
Math.clz32(1 &lt;&lt; 2) // 29
Math.clz32(1 &lt;&lt; 29) // 2</code></pre>
<h3 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h3><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<pre><code class="javascript">Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755
Math.hypot();            // 0
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, &#39;foo&#39;); // NaN
Math.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755
Math.hypot(-3);          // 3</code></pre>
<h3 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h3><p><strong>（1） Math.expm1()</strong>   == Math.exp(x) - 1;</p>
<p><code>Math.expm1(x)</code>返回ex - 1，即<code>Math.exp(x) - 1</code>。</p>
<p><strong>（2）Math.log1p()</strong>  ==  Math.log(1 + x);</p>
<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>
<p><strong>（3）Math.log10()</strong> == Math.log(x) / Math.LN10;</p>
<p><code>Math.log10(x)</code>返回以10为底的<code>x</code>的对数。如果<code>x</code>小于0，则返回NaN。</p>
<p><strong>（4）Math.log2()</strong> == Math.log(x) / Math.LN2;</p>
<p><code>Math.log2(x)</code>返回以2为底的<code>x</code>的对数。如果<code>x</code>小于0，则返回NaN。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>ES6新增了6个三角函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="！指数运算符"><a href="#！指数运算符" class="headerlink" title="！指数运算符"></a>！指数运算符</h3><p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>
<pre><code class="javascript">2 ** 3 // 8

let a = 1.5;
a **= 2;
// 等同于 a = a * a;</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="! Array.from()"></a>! Array.from()</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>
<pre><code class="javascript">let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。再使用<code>forEach</code>方法。</p>
<pre><code class="javascript">// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).forEach(function (p) {
  console.log(p);
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}</code></pre>
<p>只要是部署了Iterator接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>
<pre><code class="javascript">Array.from(&#39;hello&#39;)
// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]

let namesSet = new Set([&#39;a&#39;, &#39;b&#39;])
Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]</code></pre>
<p>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被<code>Array.from</code>转为真正的数组。</p>
<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。</p>
<pre><code class="javascript">// arguments对象
function foo() {
  var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]</code></pre>
<p><code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<pre><code class="javascript">Array.from({ length: 3 });
// [ undefined, undefined, undefined ]</code></pre>
<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。<code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);
// 等同于
Array.prototype.map.call(arrayLike),x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]

let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)</code></pre>
<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<pre><code class="javascript">Array.from({ length: 2 }, () =&gt; &#39;jack&#39;)
// [&#39;jack&#39;, &#39;jack&#39;]</code></pre>
<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于<code>\uFFFF</code>的Unicode字符，算作两个字符的bug。</p>
<pre><code class="javascript">function countSymbols(string) {
  return Array.from(string).length;
}</code></pre>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1</code></pre>
<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]</code></pre>
<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<pre><code class="javascript">Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]</code></pre>
<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>
<pre><code class="javascript">function ArrayOf(){
  return [].slice.call(arguments);
}</code></pre>
<h3 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h3><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，<strong>使用这个方法，会修改当前数组。</strong></p>
<pre><code class="javascript">Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。<strong>如果为负值，表示倒数。</strong></li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。<strong>如果为负值，表示倒数。</strong></li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]</code></pre>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p>下面是更多例子。</p>
<pre><code class="javascript">// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);</code></pre>
<h3 id="Array-fill"><a href="#Array-fill" class="headerlink" title="Array.fill"></a>Array.fill</h3><p>方法使用给定值，填充一个数组(<strong>初始化数组</strong>)</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]</code></pre>
<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。<code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]</code></pre>
<p>上面代码表示，<code>fill</code>方法从1号位开始，向原数组填充7，到2号位之前结束。</p>
<h3 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h3><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个<strong>遍历器对象</strong>，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<p>注：values在chrome中暂时不可用</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);
}
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;</code></pre>
<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<pre><code class="javascript">let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let entries = letter.entries();
console.log(entries.next().value); // [0, &#39;a&#39;]
console.log(entries.next().value); // [1, &#39;b&#39;]
console.log(entries.next().value); // [2, &#39;c&#39;]</code></pre>
<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于<strong>ES7</strong>，但Babel转码器已经支持。用来替换indexof，它有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对<code>NaN</code>的误判。</p>
<pre><code class="javascript">[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, NaN].includes(NaN); // true

[NaN].indexOf(NaN)// -1</code></pre>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true</code></pre>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<pre><code class="javascript">const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)   //这样还是没办法避免NaN问题，如果需要判断这个还需加强
)();
contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</code></pre>
<p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h3 id="空位置（坑）"><a href="#空位置（坑）" class="headerlink" title="空位置（坑）"></a>空位置（坑）</h3><p>数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<pre><code>Array(3) // [, , ,]

</code></pre><p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<pre><code class="javascript">0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false</code></pre>
<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<pre><code class="javascript">// forEach方法
[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]

// every方法
[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true

// some方法
[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false

// map方法
[,&#39;a&#39;].map(x =&gt; 1) // [,1]

// join方法
[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;

// toString方法
[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;</code></pre>
<p>ES6则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<pre><code class="javascript">Array.from([&#39;a&#39;,,&#39;b&#39;])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre>
<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<pre><code class="javascript">[...[&#39;a&#39;,,&#39;b&#39;]]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre>
<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<pre><code class="javascript">[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]</code></pre>
<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<pre><code class="javascript">new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</code></pre>
<p><code>for...of</code>循环也会遍历空位。</p>
<pre><code class="javascript">let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1</code></pre>
<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<pre><code class="javascript">// entries()
[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,&#39;a&#39;].keys()] // [0,1]

// values()
[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]

// find()
[,&#39;a&#39;].find(x =&gt; true) // undefined

// findIndex()
[,&#39;a&#39;].findIndex(x =&gt; true) // 0</code></pre>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。这种写法的缺点在于，<strong>如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。</strong>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<pre><code class="javascript">function log(x, y) {
  y = y || &#39;World&#39;;
  console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello World           //这里不符合预计

//改成
function log(x, y) {
  if (typeof y === &#39;undefined&#39;) {
     y = &#39;World&#39;;
  }
  console.log(x, y);
}</code></pre>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello</code></pre>
<p>ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>另外，一个容易忽略的地方是，<strong>如果参数默认值是变量，那么参数就不是传值的</strong>，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code class="javascript">let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101</code></pre>
<p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p>
<h3 id="与解构结合用"><a href="#与解构结合用" class="headerlink" title="与解构结合用"></a>与解构结合用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="javascript">function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined, 5
foo(1,2) // undefined, 5    //只要第一个参数不是一个对象就不会赋值
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined</code></pre>
<p>上面的写法不能省略参数，如果结合函数参数的默认值，就可以省略第二个参数。<strong>这时，就出现了双重默认值。</strong></p>
<pre><code class="javascript">function foo({x, y = 5} = {}) {
  console.log(x, y);
}
foo() // undefined, 5</code></pre>
<p><strong>注意：</strong></p>
<p>再请问下面两种写法有什么差别？</p>
<pre><code class="javascript">// 写法一  使用这种
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二  缺点是如果传入了参数，哪怕是空{},初始化就失效
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code class="javascript">// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x有值，y无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]</code></pre>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，<strong>应该是函数的尾参数</strong>。因为这样比较容易看出来，到底省略了哪些参数。<strong>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</strong>除非显式输入<code>undefined</code>。如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<pre><code class="javascript">// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]</code></pre>
<p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。这是因为<code>length</code>属性的含义是，<strong>该函数预期传入的参数个数</strong>。</p>
<pre><code class="javascript">(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<pre><code class="javascript">(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1</code></pre>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，<strong>参数会形成一个单独的作用域（context）</strong>。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="javascript">var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2</code></pre>
<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">let x = 1;
function f(y = x) {   //如果不定义x会报错
  let x = 2;
  console.log(y);
}
f() // 1</code></pre>
<p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p>
<p>面是一个更复杂的例子。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;   //和第一个参数x不一样
  y();   //改变的是第一个参数x
  console.log(x); 
}

foo() // 3
x // 1</code></pre>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;    //和第一个参数x一致
  y();      //改变了第一个参数x
  console.log(x);  //2
}

foo() // 2
x // 1</code></pre>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，<strong>可以指定某一个参数不得省略，如果省略就抛出一个错误。</strong></p>
<pre><code class="javascript">function throwIfMissing() {
  throw new Error(&#39;Missing parameter&#39;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter</code></pre>
<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<pre><code class="javascript">function foo(optional = undefined) { ··· }</code></pre>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入<strong>数组</strong>中。</p>
<pre><code>function add(...values) {
    values //[2,5,3]
}

add(2, 5, 3) // 10
</code></pre><p><strong>由于rest参数本来就是数组，所以它不需要做数组转换就可以用数组的方法</strong>(sort，forEach……)</p>
<pre><code class="javascript">// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code class="javascript">// 报错
function f(a, ...b, c) {
  // ...
}</code></pre>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<pre><code class="javascript">(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1</code></pre>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 <strong>rest 参数的逆运算</strong>，将<strong>一个数组转为用逗号分隔的参数序列</strong>。</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</code></pre>
<p>该运算符主要用于函数调用。</p>
<pre><code class="javascript">function push(array, ...items) {
  array.push(...items);   //把items转换成序列
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers) // 42</code></pre>
<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code class="javascript">function f(v, w, x, y, z) { }
var args = [0, 1];
f(-1, ...args, 2, ...[3]);</code></pre>
<h3 id="！扩展运算符作用"><a href="#！扩展运算符作用" class="headerlink" title="！扩展运算符作用"></a>！扩展运算符作用</h3><ol>
<li><p><strong>替代apply</strong></p>
<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>
</li>
</ol>
<pre><code class="javascript">// 1. 求数组最大值

// ES5的写法
Math.max.apply(null, [14, 3, 77])

// ES6的写法
Math.max(...[14, 3, 77])

// 2. 给Date传参

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);


// 3. 添加数组到尾部

// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);
// ES6的写法
arr1.push(...arr2);

// 4. 合并数组

// ES5
arr1.concat(arr2, arr3);

// ES6
[...arr1, ...arr2, ...arr3]</code></pre>
<ol>
<li>扩展运算符可以与<strong>解构赋值</strong>结合起来，<strong>用于生成数组。</strong>如果将扩展运算符用于数组赋值，<strong>只能放在参数的最后一位</strong>，否则会报错。</li>
</ol>
<pre><code class="javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list

const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错</code></pre>
<ol>
<li><strong>字符串</strong></li>
</ol>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</code></pre>
<p>上面的写法，有一个重要的好处，<strong>那就是能够正确识别32位的Unicode字符。</strong></p>
<pre><code class="javascript">&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3</code></pre>
<p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code class="javascript">function length(str) {
  return [...str].length;
}

length(&#39;x\uD83D\uDE80y&#39;) // 3</code></pre>
<p>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre><code class="javascript">let str = &#39;x\uD83D\uDE80y&#39;;

str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;</code></pre>
<p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确</p>
<ol>
<li><p><strong>转换所有带Iterator接口的对象</strong></p>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
</li>
</ol>
<pre><code class="javascript">let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]</code></pre>
<p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code class="javascript">var go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]</code></pre>
<p>上面代码中，变量<code>go</code>是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有<code>iterator</code>接口的对象，使用扩展运算符，将会报错。</p>
<pre><code class="javascript">var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object</code></pre>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<pre><code class="javascript">function foo() {}
foo.name // &quot;foo&quot;</code></pre>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<pre><code class="javascript">var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;</code></pre>
<p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</p>
<pre><code class="javascript">const bar = function baz() {};

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;</code></pre>
<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<pre><code class="javascript">(new Function).name // &quot;anonymous&quot;</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<pre><code class="javascript">function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>如果没有参数，必须要用一个括号，只有一个参数，不用写括号，返回值不用写return</p>
<pre><code class="javascript">var f = v =&gt; v;
//等于
var f = function(v) {
  return v;
};
var f = () =&gt; 5;
var sum = (num1, num2) =&gt; num1 + num2;</code></pre>
<h3 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h3><p>如果只是返回对象，必须要加一个括号，否则编译器认不出</p>
<pre><code class="javascript">var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });</code></pre>
<h3 id="与解构"><a href="#与解构" class="headerlink" title="与解构"></a>与解构</h3><pre><code class="javascript">const full = ({ first, last }) =&gt; first + &#39; &#39; + last;

// 等同于
function full(person) {
  return person.first + &#39; &#39; + person.last;
}</code></pre>
<h3 id="简化回调"><a href="#简化回调" class="headerlink" title="简化回调"></a>简化回调</h3><pre><code class="javascript">// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);

// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);</code></pre>
<h3 id="与rest结合"><a href="#与rest结合" class="headerlink" title="与rest结合"></a>与rest结合</h3><pre><code class="javascript">const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]</code></pre>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）<strong>不可以当作构造函数</strong>，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，<strong>可以用Rest参数代替</strong>。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数<strong>不能用作Generator函数</strong>。</p>
<p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<pre><code class="javascript">var handler = {
  id: &#39;123456&#39;,

  init: function() {
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);   //如果不用箭头函数那this指向document
  },

  doSomething: function(type) {
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  }
};</code></pre>
<p>所以，箭头函数转成ES5的代码如下。</p>
<pre><code class="javascript">// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;    //这里引用了外面的this

  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}</code></pre>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<pre><code class="javascript">(function() {
  return [
    (() =&gt; this.x).bind({ x: &#39;inner&#39; })()
  ];
}).call({ x: &#39;outer&#39; });
// [&#39;outer&#39;]</code></pre>
<h3 id="arguments-super-target"><a href="#arguments-super-target" class="headerlink" title="arguments,super,target"></a>arguments,super,target</h3><p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>
<pre><code class="javascript">function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;args:&#39;, arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]</code></pre>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><pre><code class="javascript">function f(x){
  return g(x);
}</code></pre>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<pre><code class="javascript">function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}</code></pre>
<p>以下不是尾调用</p>
<pre><code class="javascript">// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;  // ==  var tmp = g(x); return tmp+1;
}

// 情况三
function f(x){
  g(x);    //  g(x);   return undefined;
}</code></pre>
<p><strong>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧</strong>，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<pre><code class="javascript">function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);</code></pre>
<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p>
<pre><code class="javascript">function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}</code></pre>
<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但<strong>对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</strong></p>
<pre><code class="javascript">function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120</code></pre>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<pre><code class="javascript">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120</code></pre>
<p>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p>
<p>如果是非尾递归的fibonacci 递归方法</p>
<pre><code class="javascript">function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10); // 89
// Fibonacci(100)
// Fibonacci(500)
// 堆栈溢出了</code></pre>
<p>如果我们使用尾递归优化过的fibonacci 递归算法</p>
<pre><code class="javascript">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity</code></pre>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。<strong>ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。</strong>这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h3><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<pre><code class="javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)</code></pre>
<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归100000次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<pre><code class="javascript">function trampoline(f) {
  while (f &amp;&amp; f instanceof Function) {
    f = f();
  }
  return f;
}</code></pre>
<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<pre><code class="javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}</code></pre>
<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<pre><code class="javascript">trampoline(sum(1, 100000))
// 100001</code></pre>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<pre><code class="javascript">function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001</code></pre>
<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="属性简洁表达"><a href="#属性简洁表达" class="headerlink" title="属性简洁表达"></a>属性简洁表达</h2><p>ES6允许<strong>直接写入变量和函数，作为对象的属性和方法</strong>。这样的书写更加简洁。</p>
<pre><code class="javascript">var foo = &#39;bar&#39;;
var baz = {foo};
baz // {foo: &quot;bar&quot;}</code></pre>
<p>属性名直接是变量名，属性值是变量值</p>
<pre><code class="javascript">var birth = &#39;2000/01/01&#39;;

var Person = {
  name: &#39;张三&#39;,
  //等同于birth: &#39;2000/01/01&#39;;
  birth,
  // 等同于hello: function ()...
  hello() { console.log(&#39;我的名字是&#39;, this.name); }
};</code></pre>
<p>CommonJS模块输出变量，就非常合适使用简洁写法。</p>
<pre><code class="javascript">var ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};</code></pre>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre><code class="javascript">var obj = {
  class () {}   //class是字符串，所以不会因为它属于关键字，而导致语法解析报错。
};
// 等同于
var obj = {
  &#39;class&#39;: function() {}    
};</code></pre>
<p>如果某个方法的值是一个Generator函数，前面需<strong>要加上星号。</strong></p>
<pre><code class="javascript">var obj = {
  * m(){
    yield &#39;hello world&#39;;
  }
};</code></pre>
<h2 id="字面量中可用"><a href="#字面量中可用" class="headerlink" title="字面量中可用[]"></a>字面量中可用[]</h2><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，<strong>即把表达式放在方括号内</strong>。</p>
<pre><code class="javascript">let propKey = &#39;foo&#39;;

let obj = {
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
};
//Object {foo: true, abc: 123}</code></pre>
<p>表达式还可以用于定义方法名。</p>
<pre><code class="javascript">let obj = {
  [&#39;h&#39; + &#39;ello&#39;]() {
    return &#39;hi&#39;;
  }
};

obj.hello() // hi</code></pre>
<p><strong>注意</strong>，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code class="javascript">// 报错
var foo = &#39;bar&#39;;
var bar = &#39;abc&#39;;
var baz = { [foo] };

// 正确
var foo = &#39;bar&#39;;
var baz = { [foo]: &#39;abc&#39;};
var baz = {foo}</code></pre>
<p><strong>注意</strong>，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<pre><code class="javascript">const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
};

myObject // Object {[object Object]: &quot;valueB&quot;}
//[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解持有对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解持有对象/" itemprop="url">Java题解持有对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第十一章持有对象"><a href="#第十一章持有对象" class="headerlink" title="第十一章持有对象"></a>第十一章持有对象</h2><p>class Gerbil {</p>
<p>​       private int gerbilNumber;</p>
<p>​       public Gerbil(int i) {</p>
<p>​              gerbilNumber = i;</p>
<p>​       }</p>
<p>​       public void hop() {</p>
<p>​              System.out.println(“Gerbil “ + gerbilNumber + “ hops”);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex1 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ArrayList<gerbil> gerbils = new ArrayList<gerbil>();</gerbil></gerbil></p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     gerbils.add(new Gerbil(i));</p>
<p>​              for(int i = 0; i &lt; 10; i++) </p>
<p>​                     gerbils.get(i).hop();</p>
<p>​                           for(Gerbil g : gerbils)</p>
<p>​                     g.hop();</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex2 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Set<integer> c = new HashSet<integer>();</integer></integer></p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     c.add(i);               for(Integer i : c)</p>
<p>​                     System.out.print(i + “, “);</p>
<p>​       }      </p>
<p>}</p>
<p>interface Selector {</p>
<p>​       boolean end();</p>
<p>​       Object current();</p>
<p>​       void next();</p>
<p>}</p>
<p>public class Sequence3 {</p>
<p>​       private ArrayList<object> items = new ArrayList<object>();</object></object></p>
<p>​       public void add(Object x) {</p>
<p>​              items.add(x);</p>
<p>​       }</p>
<p>​       private class Sequence3Selector implements Selector {</p>
<p>​              private int i = 0;</p>
<p>​              public boolean end() {</p>
<p>​                     return i == items.size();               </p>
<p>​              }</p>
<p>​              public Object current() {</p>
<p>​                     return items.get(i);</p>
<p>​              }</p>
<p>​              public void next() {</p>
<p>​                     i++;</p>
<p>​              }      </p>
<p>​       }</p>
<p>​       public Selector selector() {</p>
<p>​              return new Sequence3Selector();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Sequence3 s3 = new Sequence3();</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     s3.add(i);</p>
<p>​              Selector selector = s3.selector();</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​              s3.add(10);</p>
<p>​              s3.add(11);</p>
<p>​              s3.add(12);</p>
<p>​              s3.add(13);</p>
<p>​              s3.add(13);</p>
<p>​              s3.add(“good bye”);</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Generator {</p>
<p>​       int key = 0;</p>
<p>​       public String next() {</p>
<p>​              switch(key) {</p>
<p>​                     default:</p>
<p>​                     case 0 : key++; return “Snow White”;</p>
<p>​                     case 1 : key++; return “Bashful”;</p>
<p>​                     case 2 : key++; return “Doc”;</p>
<p>​                     case 3 : key++; return “Dopey”;</p>
<p>​                     case 4 : key++; return “Grumpy”;</p>
<p>​                     case 5 : key++; return “Happy”;</p>
<p>​                     case 6 : key++; return “Sleepy”;</p>
<p>​                     case 7 : key = 0; return “Sneezy”;              </p>
<p>​              }</p>
<p>​       } </p>
<p>​       public void fillA(String[] a) {</p>
<p>​              for(int i = 0; i &lt; a.length; i++)</p>
<p>​                     a[i] = next();</p>
<p>​       }</p>
<p>​       public Collection fill(Collection<string> c, int n) {</string></p>
<p>​              for(int i = 0; i &lt; n; i++) c.add(next());</p>
<p>​              return c;</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex4 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Generator gen = new Generator();            </p>
<p>​              String[] a = new String[10];</p>
<p>​              gen.fillA(a);</p>
<p>​              for(String s : a) System.out.print(s + “, “);</p>
<p>​              System.out.println();     </p>
<p>​              System.out.println(gen.fill(new ArrayList<string>(), 10));</string></p>
<p>​              System.out.println(gen.fill(new LinkedList<string>(), 10));</string></p>
<p>​              System.out.println(gen.fill(new HashSet<string>(), 10));</string></p>
<p>​              System.out.println(gen.fill(new LinkedHashSet<string>(), 10));</string></p>
<p>​              System.out.println(gen.fill(new TreeSet<string>(), 10));                        </string></p>
<p>​       }</p>
<p>}</p>
<p>public class Ex5 {</p>
<p>​             public static List<integer> listOfRandInteger(int length, int n) {</integer></p>
<p>​              Random rand = new Random();</p>
<p>​              List<integer> li = new ArrayList<integer>(); </integer></integer></p>
<p>​              for(int i = 0; i &lt; length; i++)</p>
<p>​                     li.add(rand.nextInt(n));         </p>
<p>​              return li;  </p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Random rand = new Random();</p>
<p>​              List<integer> li = listOfRandInteger(7, 10);</integer></p>
<p>​              print(“1: “ + li);</p>
<p>​              Integer h = new Integer(rand.nextInt(10));</p>
<p>​              li.add(h);</p>
<p>​              print(“2: “ + li);</p>
<p>​              print(“3: “ + li.contains(h));</p>
<p>​                           li.remove(h);</p>
<p>​              print(“3.5: “ + li);</p>
<p>​              Integer p = li.get(2);</p>
<p>​              print(“4: “ + p + “ “ +  li.indexOf(p));</p>
<p>​              Integer cy = new Integer(rand.nextInt(10));</p>
<p>​              print(“5: “ + cy +” “ + li.indexOf(cy));</p>
<p>​              print(“6: “ + li.remove(cy));</p>
<p>​              print(“7: “ + li.remove(p));</p>
<p>​              print(“8: “ + li);</p>
<p>​              li.add(3, new Integer(rand.nextInt(10)));</p>
<p>​              print(“9: “ + li);</p>
<p>​              List<integer> sub = li.subList(1, 4);</integer></p>
<p>​              print(“sublist: “ + sub);</p>
<p>​              print(“10: “ + li.containsAll(sub));</p>
<p>​                           Collections.sort(sub);</p>
<p>​              print(“sorted sublist: “ + sub);</p>
<p>​              print(“11: “ + li.containsAll(sub));</p>
<p>​              print(“11.25: “ + li);</p>
<p>​                           Collections.shuffle(sub, rand);</p>
<p>​              print(“11.5: “ + li);</p>
<p>​              print(“shuffled sublist: “ + sub);</p>
<p>​              print(“12: “ + li.containsAll(sub));</p>
<p>​              List<integer> copy = new ArrayList<integer>(li);</integer></integer></p>
<p>​              print(“12.5: “ + li);</p>
<p>​              sub = Arrays.asList(li.get(1), li.get(4));</p>
<p>​              print(“sub: “ + sub);      </p>
<p>​              copy.retainAll(sub);</p>
<p>​              print(“13: “ + copy);</p>
<p>​              copy = new ArrayList<integer>(li);</integer></p>
<p>​              copy.remove(2);</p>
<p>​              print(“14: “ + copy);</p>
<p>​              copy.removeAll(sub); </p>
<p>​              print(“15: “ + copy);</p>
<p>​              if(copy.size() &gt; 1)                      copy.set(1, 8);             print(“16: “ + copy);</p>
<p>​              if(copy.size() &gt; 2)</p>
<p>​                     copy.addAll(2, sub);</p>
<p>​              print(“17: “ + copy);</p>
<p>​              print(“18: “ + li.isEmpty());</p>
<p>​              li.clear();</p>
<p>​              print(“19: “ + li);</p>
<p>​              print(“20: “ + li.isEmpty());</p>
<p>​              li.addAll(listOfRandInteger(4, 10));</p>
<p>​              print(“21: “ + li);</p>
<p>​              Object[] o = li.toArray();</p>
<p>​              print(“22: “ + o[3]);</p>
<p>​              Integer[] ia = li.toArray(new Integer[0]);</p>
<p>​              print(“23: “ + ia[3]);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex6 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Random rand = new Random();</p>
<p>​              List<string> ls = new ArrayList<string>();</string></string></p>
<p>​              print(“0: “ + ls);</p>
<p>​              Collections.addAll(ls, “oh”, “what”, “a”, “beautiful”, “Manila”, “Monday”, “morning”);</p>
<p>​              print(“1: “ + ls);</p>
<p>​              String h = new String(“hi”);</p>
<p>​              ls.add(h);</p>
<p>​              print(“2: “ + ls);</p>
<p>​              print(“3: “ + ls.contains(h));</p>
<p>​                           ls.remove(h);</p>
<p>​              print(“3.5: “ + ls);</p>
<p>​              String p = ls.size() &gt; 2 ? ls.get(2) : null;</p>
<p>​              print(“4: “ + p + “ “ +  ls.indexOf(p));</p>
<p>​              String cy = new String(“cy”);</p>
<p>​              print(“5: “ + cy +” “ + ls.indexOf(cy));</p>
<p>​              print(“6: “ + ls.remove(cy));</p>
<p>​              print(“7: “ + ls.remove(p));</p>
<p>​              print(“8: “ + ls);</p>
<p>​              if(ls.size() &gt; 3)</p>
<p>​                     ls.add(3, “wonderful”);</p>
<p>​              print(“9: “ + ls);</p>
<p>​              if(ls.size() &lt; 4) {</p>
<p>​                     List<string> s = </string></p>
<p>​                        Arrays.asList(“let’s”, “jump”, “in”, “here”);</p>
<p>​                     ls.addAll(0, s);</p>
<p>​              }</p>
<p>​              List<string> sub = ls.subList(1, 4);</string></p>
<p>​              print(“sublist: “ + sub);</p>
<p>​              print(“10: “ + ls.containsAll(sub));</p>
<p>​                           Collections.sort(sub);</p>
<p>​              print(“sorted sublist: “ + sub);</p>
<p>​              print(“11: “ + ls.containsAll(sub));</p>
<p>​              print(“11.25: “ + ls);</p>
<p>​                           Collections.shuffle(sub, rand);</p>
<p>​              print(“11.5: “ + ls);</p>
<p>​              print(“shuffled sublist: “ + sub);</p>
<p>​              print(“12: “ + ls.containsAll(sub));</p>
<p>​              List<string> copy = new ArrayList<string>(ls);</string></string></p>
<p>​              print(“12.5: “ + ls);</p>
<p>​              if(ls.size() &lt; 5) {</p>
<p>​                     ls.add(“two”);</p>
<p>​                     ls.add(“more”);</p>
<p>​              }</p>
<p>​              sub = Arrays.asList(ls.get(1), ls.get(4));</p>
<p>​              print(“sub: “ + sub);      </p>
<p>​              copy.retainAll(sub);</p>
<p>​              print(“13: “ + copy);</p>
<p>​              copy = new ArrayList<string>(ls);</string></p>
<p>​              copy.remove(2);</p>
<p>​              print(“14: “ + copy);</p>
<p>​              copy.removeAll(sub); </p>
<p>​              print(“15: “ + copy);</p>
<p>​              if(copy.size() &gt; 1)                      copy.set(1, “excellent”); </p>
<p>​              print(“16: “ + copy);</p>
<p>​              if(copy.size() &gt; 2)</p>
<p>​                     copy.addAll(2, sub);</p>
<p>​              print(“17: “ + copy);</p>
<p>​              print(“18: “ + ls.isEmpty());</p>
<p>​              ls.clear();</p>
<p>​              print(“19: “ + ls);</p>
<p>​              print(“20: “ + ls.isEmpty());</p>
<p>​              ls.addAll(0, sub);</p>
<p>​              ls.addAll(2, sub);</p>
<p>​              print(“21: “ + ls);</p>
<p>​              Object[] o = ls.toArray();</p>
<p>​              print(“22: “ + o[3]);</p>
<p>​              String[] sa = ls.toArray(new String[0]);</p>
<p>​              print(“23: “ + sa[3]);</p>
<p>​       }</p>
<p>}</p>
<p>class Tester {</p>
<p>​       public static int counter = 0;</p>
<p>​       private int id = counter++;</p>
<p>​       public String toString() { return String.valueOf(id); } </p>
<p>}</p>
<p>public class Ex7 {</p>
<p>​       public static void main(String[] args) {       </p>
<p>​              Tester[] t = new Tester[10];</p>
<p>​              for(int i = 0; i &lt; t.length; i++)</p>
<p>​                     t[i] = new Tester();</p>
<p>​              List<tester> lt = new ArrayList<tester>();</tester></tester></p>
<p>​              for(Tester x : t) lt.add(x);</p>
<p>​              print(“list of Tester: “ + lt);</p>
<p>​              List<tester> sub = lt.subList(2, 6);</tester></p>
<p>​              print(“subList: “ + sub);</p>
<p>​                                                     List<tester> copy = new ArrayList<tester>(lt);</tester></tester></p>
<p>​              copy.removeAll(sub);</p>
<p>​              print(“copy: “ + copy);</p>
<p>​              lt = copy;</p>
<p>​              print(“list of Tester: “ + lt);</p>
<p>​       }</p>
<p>}</p>
<p>​    import java.util.*;</p>
<p>class Gerbil {</p>
<p>​       private int gerbilNumber;</p>
<p>​       public Gerbil(int i) {</p>
<p>​              gerbilNumber = i;</p>
<p>​       }</p>
<p>​       public void hop() {</p>
<p>​              System.out.println(“Gerbil “ + gerbilNumber + “ hops”);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex8 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ArrayList<gerbil> gerbils = new ArrayList<gerbil>();</gerbil></gerbil></p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     gerbils.add(new Gerbil(i));</p>
<p>​              Iterator<gerbil> it = gerbils.iterator();</gerbil></p>
<p>​              while(it.hasNext()) </p>
<p>​                     it.next().hop();</p>
<p>​       }</p>
<p>}</p>
<p>public class Sequence9 {</p>
<p>​       private ArrayList<object> items = new ArrayList<object>();</object></object></p>
<p>​       public void add(Object x) {</p>
<p>​              items.add(x);</p>
<p>​       }</p>
<p>​       public Iterator iterator() {</p>
<p>​              return items.iterator();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Sequence9 sequence = new Sequence9();</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     sequence.add(Integer.toString(i));</p>
<p>​              Iterator it = sequence.iterator();</p>
<p>​              while(it.hasNext()) {                                                               System.out.print(it.next() + “ “);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class RandomRodentGenerator {</p>
<p>​       private Random rand = new Random();</p>
<p>​       public Rodent next() {</p>
<p>​              switch(rand.nextInt(3)) {</p>
<p>​                     default:</p>
<p>​                     case 0: return new Mouse();</p>
<p>​                     case 1: return new Rat();</p>
<p>​                     case 2: return new Squirrel();                     </p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Rodent {</p>
<p>​       private String name = “Rodent”;</p>
<p>​       protected void eat() { println(“Rodent.eat()”); }</p>
<p>​       protected void run() { println(“Rodent.run()”); }</p>
<p>​       protected void sleep() { println(“Rodent.sleep()”); }</p>
<p>​       public String toString() { return name; }</p>
<p>}</p>
<p>class Mouse extends Rodent {</p>
<p>​       private String name = “Mouse”;</p>
<p>​       protected void eat() { println(“Mouse.eat()”); }</p>
<p>​       protected void run() { println(“Mouse.run()”); }</p>
<p>​       protected void sleep() { println(“Mouse.sleep()”); }</p>
<p>​       public String toString() { return name; }</p>
<p>}</p>
<p>class Rat extends Rodent {</p>
<p>​       private String name = “Rat”;</p>
<p>​       protected void eat() { println(“Rat.eat()”); }</p>
<p>​       protected void run() { println(“Rat.run()”); }</p>
<p>​       protected void sleep() { println(“Rat.sleep()”); }</p>
<p>​       public String toString() { return name; }</p>
<p>}</p>
<p>class Squirrel extends Rodent {</p>
<p>​       private String name = “Squirrel”;</p>
<p>​       protected void eat() { println(“Squirrel.eat()”); }</p>
<p>​       protected void run() { println(“Squirrel.run()”); }</p>
<p>​       protected void sleep() { println(“Squirrel.sleep()”); }</p>
<p>​       public String toString() { return name; }</p>
<p>}</p>
<p>public class Rodent10 {</p>
<p>​       private static RandomRodentGenerator gen = </p>
<p>​              new RandomRodentGenerator();</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<rodent> rodentList = new ArrayList<rodent>();</rodent></rodent></p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     rodentList.add(gen.next());</p>
<p>​              Iterator<rodent> it = rodentList.iterator();</rodent></p>
<p>​              while(it.hasNext()) {</p>
<p>​                     Rodent r = it.next();</p>
<p>​                     print(r + “: “);</p>
<p>​                     r.eat();</p>
<p>​                     r.run();</p>
<p>​                     r.sleep();</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex11 {</p>
<p>​       public static void printAny(Collection c) {</p>
<p>​              Iterator it = c.iterator();</p>
<p>​              while(it.hasNext())</p>
<p>​                     print(it.next() + “ “);</p>
<p>​              println();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ArrayList<integer> al = </integer></p>
<p>​                     new ArrayList<integer>(Arrays.asList(1, 2, 3));</integer></p>
<p>​              LinkedList<character> ll =</character></p>
<p>​                     new LinkedList<character>(Arrays.asList(‘a’, ‘b’, ‘c’));       </character></p>
<p>​              HashSet<float> hs = </float></p>
<p>​                     new HashSet<float>(Arrays.asList(1.1f, 2.2f, 3.3f));</float></p>
<p>​              TreeSet<double> ts =</double></p>
<p>​                     new TreeSet<double>(Arrays.asList(1.11, 2.22, 3.33));</double></p>
<p>​              LinkedHashSet<integer> lhs =</integer></p>
<p>​                     new LinkedHashSet<integer>(Arrays.asList(11, 22, 33));</integer></p>
<p>​              printAny(al);</p>
<p>​              printAny(ll);</p>
<p>​              printAny(hs);</p>
<p>​              printAny(ts);</p>
<p>​              printAny(lhs);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex12 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<integer> li1 = </integer></p>
<p>​                     new ArrayList<integer>(Arrays.asList(0, 1, 2, 3, 4));</integer></p>
<p>​              List<integer> li2 = </integer></p>
<p>​                     new ArrayList<integer>(Arrays.asList(5, 6, 7, 8, 9));</integer></p>
<p>​              ListIterator<integer> it1 = li1.listIterator();</integer></p>
<p>​              ListIterator<integer> it2 = li2.listIterator();</integer></p>
<p>​              println(“li1: “ + li1);</p>
<p>​              println(“li2: “ + li2);</p>
<p>​                           while(it1.hasNext())</p>
<p>​                     it1.next();</p>
<p>​                           while(it2.hasNext()) {     </p>
<p>​                     it2.next();        </p>
<p>​                     it2.set(it1.previous());</p>
<p>​              }</p>
<p>​              println(“li1: “ + li1);</p>
<p>​              println(“li2: “ + li2);</p>
<p>​              </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex12a {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<integer> li1 = </integer></p>
<p>​                     new ArrayList<integer>(Arrays.asList(0, 1, 2, 3, 4));</integer></p>
<p>​              List<integer> li2 = </integer></p>
<p>​                     new ArrayList<integer>(Arrays.asList(5, 6, 7, 8, 9));</integer></p>
<p>​                           ListIterator<integer> it1 = li1.listIterator(5);</integer></p>
<p>​              ListIterator<integer> it2 = li2.listIterator();</integer></p>
<p>​              println(“li1: “ + li1);</p>
<p>​              println(“li2: “ + li2);</p>
<p>​                           while(it2.hasNext()) {     </p>
<p>​                     it2.next();        </p>
<p>​                     it2.set(it1.previous());</p>
<p>​              }</p>
<p>​              println(“li1: “ + li1);</p>
<p>​              println(“li2: “ + li2);</p>
<p>​              </p>
<p>​       }</p>
<p>}</p>
<p>public class Controller13 {</p>
<p>​             private LinkedList<event> eventList = new LinkedList<event>();</event></event></p>
<p>​       public void addEvent(Event c) { eventList.add(c); }           </p>
<p>​       public void run() {         </p>
<p>​              LinkedList<event> eventListCopy = </event></p>
<p>​                     new LinkedList<event>(eventList);</event></p>
<p>​              ListIterator<event> it </event></p>
<p>​                     = eventListCopy.listIterator();</p>
<p>​              while(it.hasNext()) {       </p>
<p>​                     it.next().action();</p>
<p>​                     it.previous();          </p>
<p>​                     System.out.println(it.next());         </p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex14 {</p>
<p>​       static void addMiddle(LinkedList<integer> l, Integer[] ia) {</integer></p>
<p>​              </p>
<p>​              for(Integer i : ia) {</p>
<p>​                     ListIterator<integer> it = </integer></p>
<p>​                            l.listIterator((l.size())                   it.add(i);</p>
<p>​                     System.out.println(l);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              LinkedList<integer> li = new LinkedList<integer>();</integer></integer></p>
<p>​              Integer[] x = {0, 1, 2, 3, 4, 5, 6, 7};</p>
<p>​              Ex14.addMiddle(li, x);</p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex15 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Stack<character> sc = new Stack<character>();</character></character></p>
<p>​              sc.push(‘U’);</p>
<p>​              sc.push(‘n’);</p>
<p>​              sc.push(‘c’);</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              sc.push(‘e’);</p>
<p>​              sc.push(‘r’);</p>
<p>​              sc.push(‘t’);</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              sc.push(‘a’);</p>
<p>​              sc.push(‘i’);</p>
<p>​              sc.push(‘n’);</p>
<p>​              sc.push(‘t’);</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              sc.push(‘ ‘);</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              sc.push(‘r’);</p>
<p>​              sc.push(‘u’);</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              sc.push(‘l’);</p>
<p>​              sc.push(‘e’);</p>
<p>​              sc.push(‘s’);</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());</p>
<p>​              System.out.print(sc.pop());          </p>
<p>​       }             </p>
<p>}</p>
<p>public class Vowels16 {</p>
<p>​       static void vowelCounter(Set<string> st) {</string></p>
<p>​              Set<character> vowels = new TreeSet<character>();</character></character></p>
<p>​              Collections.addAll(vowels, </p>
<p>​                     ‘A’, ‘E’, ‘I’, ‘O’, ‘U’, ‘a’, ‘e’, ‘i’, ‘o’, ‘u’);</p>
<p>​              int allVowels = 0;</p>
<p>​              for(String s : st) {</p>
<p>​                     int count = 0;</p>
<p>​                     for(Character v : s.toCharArray()) {             </p>
<p>​                            if(vowels.contains(v)) {</p>
<p>​                                   count++;</p>
<p>​                                   allVowels++; </p>
<p>​                            }</p>
<p>​                     }</p>
<p>​                     System.out.print(s + “: “ + count + “, “);            </p>
<p>​              }</p>
<p>​              System.out.println();     </p>
<p>​              System.out.print(“Total vowels: “ + allVowels);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Set<string> words = new TreeSet<string>(</string></string></p>
<p>​                     new TextFile(“SetOperations.java”, “\W+”));</p>
<p>​              System.out.println(words);</p>
<p>​              System.out.println();</p>
<p>​              vowelCounter(words);         </p>
<p>​       }             </p>
<p>}</p>
<p>class Gerbil {</p>
<p>​       private int gerbilNumber;</p>
<p>​       public Gerbil(int i) {</p>
<p>​              gerbilNumber = i;</p>
<p>​       }</p>
<p>​       public void hop() {</p>
<p>​              System.out.println(“gerbil “ + gerbilNumber + “ hops”);</p>
<p>​       }</p>
<p>}</p>
<p>public class Gerbils17 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String, Gerbil&gt; gerbils = new HashMap&lt;String, Gerbil&gt;();</p>
<p>​              gerbils.put(“Fuzzy”, new Gerbil(0));</p>
<p>​              gerbils.put(“Spot”, new Gerbil(1));</p>
<p>​              gerbils.put(“Speedy”, new Gerbil(2));</p>
<p>​              gerbils.put(“Dopey”, new Gerbil(3));</p>
<p>​              gerbils.put(“Sleepy”, new Gerbil(4));</p>
<p>​              gerbils.put(“Happy”, new Gerbil(5));</p>
<p>​              Iterator<string> it = gerbils.keySet().iterator();</string></p>
<p>​              while(it.hasNext()) {</p>
<p>​                     String s = it.next();</p>
<p>​                     System.out.print(s + “: “);</p>
<p>​                     gerbils.get(s).hop();</p>
<p>​              }      </p>
<p>​       }</p>
<p>class Gerbil {</p>
<p>​       private int gerbilNumber;</p>
<p>​       public Gerbil(int i) {</p>
<p>​              gerbilNumber = i;</p>
<p>​       }</p>
<p>​       public void hop() {</p>
<p>​              System.out.println(“gerbil “ + gerbilNumber + “ hops”);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex18 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String, Gerbil&gt; gerbils = new HashMap&lt;String, Gerbil&gt;();</p>
<p>​              gerbils.put(“Fuzzy”, new Gerbil(0));</p>
<p>​              gerbils.put(“Spot”, new Gerbil(1));</p>
<p>​              gerbils.put(“Speedy”, new Gerbil(2));</p>
<p>​              gerbils.put(“Dopey”, new Gerbil(3));</p>
<p>​              gerbils.put(“Sleepy”, new Gerbil(4));</p>
<p>​              gerbils.put(“Happy”, new Gerbil(5));</p>
<p>​              gerbils.put(“Funny”, new Gerbil(6));</p>
<p>​              gerbils.put(“Silly”, new Gerbil(7));</p>
<p>​              gerbils.put(“Goofy”, new Gerbil(8));</p>
<p>​              gerbils.put(“Wowee”, new Gerbil(9));</p>
<p>​              System.out.println(gerbils);</p>
<p>​              System.out.println();</p>
<p>​              Set<string> sortedKeys = </string></p>
<p>​                     new TreeSet<string>(gerbils.keySet());</string></p>
<p>​              System.out.println(sortedKeys);</p>
<p>​              System.out.println();</p>
<p>​              Map&lt;String, Gerbil&gt; sortedGerbils = </p>
<p>​                     new LinkedHashMap&lt;String, Gerbil&gt;();</p>
<p>​              for(String s : sortedKeys) {</p>
<p>​                     System.out.print(“Adding “ + s + “, “);</p>
<p>​                     sortedGerbils.put(s, gerbils.get(s));                   </p>
<p>​              }</p>
<p>​              System.out.println();</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(sortedGerbils);</p>
<p>​              System.out.println();</p>
<p>​                           Map&lt;String, Gerbil&gt; sortedGerbils2 =</p>
<p>​                     new TreeMap&lt;String, Gerbil&gt;(gerbils);</p>
<p>​              System.out.println(sortedGerbils2);            </p>
<p>​       }</p>
<p>}</p>
<p>class Gerbil {</p>
<p>​       private int gerbilNumber;</p>
<p>​       public Gerbil(int i) {</p>
<p>​              gerbilNumber = i;</p>
<p>​       }</p>
<p>​       public void hop() {</p>
<p>​              System.out.println(“gerbil “ + gerbilNumber + “ hops”);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex19 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String, Gerbil&gt; gerbils = new HashMap&lt;String, Gerbil&gt;();</p>
<p>​              gerbils.put(“Fuzzy”, new Gerbil(0));</p>
<p>​              gerbils.put(“Spot”, new Gerbil(1));</p>
<p>​              gerbils.put(“Speedy”, new Gerbil(2));</p>
<p>​              gerbils.put(“Dopey”, new Gerbil(3));</p>
<p>​              gerbils.put(“Sleepy”, new Gerbil(4));</p>
<p>​              gerbils.put(“Happy”, new Gerbil(5));</p>
<p>​              gerbils.put(“Funny”, new Gerbil(6));</p>
<p>​              gerbils.put(“Silly”, new Gerbil(7));</p>
<p>​              gerbils.put(“Goofy”, new Gerbil(8));</p>
<p>​              gerbils.put(“Wowee”, new Gerbil(9));</p>
<p>​              System.out.println(gerbils);</p>
<p>​              System.out.println();</p>
<p>​              Set<string> hashedKeys = </string></p>
<p>​                     new HashSet<string>(gerbils.keySet());</string></p>
<p>​              System.out.println(“HashSet: “ + hashedKeys);</p>
<p>​              System.out.println();</p>
<p>​              Map&lt;String, Gerbil&gt; hashedGerbils = </p>
<p>​                     new LinkedHashMap&lt;String, Gerbil&gt;();</p>
<p>​              for(String s : hashedKeys) {</p>
<p>​                     System.out.print(“Adding “ + s + “, “);              </p>
<p>​                     hashedGerbils.put(s, gerbils.get(s));</p>
<p>​              }</p>
<p>​              System.out.println();</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(“From HashSet: “ + hashedGerbils);</p>
<p>​              </p>
<p>​              System.out.println();</p>
<p>​              Set<string> linkedHashedKeys = </string></p>
<p>​                     new LinkedHashSet<string>(gerbils.keySet());</string></p>
<p>​              System.out.println(“LinkedHashSet: “ + linkedHashedKeys);</p>
<p>​              System.out.println();</p>
<p>​              Map&lt;String, Gerbil&gt; linkedHashedGerbils = </p>
<p>​                     new LinkedHashMap&lt;String, Gerbil&gt;();</p>
<p>​              for(String s : linkedHashedKeys) {</p>
<p>​                     System.out.print(“Adding “ + s + “, “);              </p>
<p>​                     linkedHashedGerbils.put(s, gerbils.get(s));</p>
<p>​              }</p>
<p>​              System.out.println();</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(“From LinkedHashSet: “ </p>
<p>​                     + linkedHashedGerbils);</p>
<p>​              }</p>
<p>}</p>
<p>public class Vowels20 {</p>
<p>​       static void vowelCounter20(Set<string> st) {           </string></p>
<p>​              Set<character> vowels = new TreeSet<character>();</character></character></p>
<p>​              Collections.addAll(vowels, </p>
<p>​                     ‘A’, ‘E’, ‘I’, ‘O’, ‘U’, ‘a’, ‘e’, ‘i’, ‘o’, ‘u’);</p>
<p>​              int allVowels = 0;</p>
<p>​              Map&lt;Character,Integer&gt; vowelMap =</p>
<p>​                     new TreeMap&lt;Character,Integer&gt;();</p>
<p>​              for(String s : st) {</p>
<p>​                     for(Character v : s.toCharArray()) {             </p>
<p>​                            if(vowels.contains(v)) {</p>
<p>​                                   Integer count = vowelMap.get(v);</p>
<p>​                                   vowelMap.put(v, </p>
<p>​                                          count == null ? 1 : count + 1);</p>
<p>​                                   allVowels++; </p>
<p>​                            }</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              System.out.println(“Vowels: “ + vowelMap);      </p>
<p>​              System.out.println(“Total vowels: “ + allVowels);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Set<string> words = new TreeSet<string>(</string></string></p>
<p>​                     new TextFile(“SetOperations.java”, “\W+”));</p>
<p>​              System.out.println(words);</p>
<p>​              System.out.println();</p>
<p>​              vowelCounter20(words);             </p>
<p>​       }             </p>
<p>}</p>
<p>public class UniqueWords21 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<string> words = new ArrayList<string>(</string></string></p>
<p>​                     new TextFile(“SetOperations.java”, “\W+”));</p>
<p>​              System.out.println(“Words to count: “ + words);</p>
<p>​              Collections.sort(words, String.CASE_INSENSITIVE_ORDER);</p>
<p>​              Map&lt;String,Integer&gt; wordCount =</p>
<p>​                     new LinkedHashMap&lt;String,Integer&gt;();</p>
<p>​              Iterator it = words.iterator();</p>
<p>​              int totalWords = 0;</p>
<p>​              while(it.hasNext()) {</p>
<p>​                     String s = (String)it.next();</p>
<p>​                     if(words.contains(s)) {</p>
<p>​                            Integer count = wordCount.get(s);</p>
<p>​                            wordCount.put(s,</p>
<p>​                                   count == null ? 1 : count + 1);</p>
<p>​                            totalWords++;</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(“Word count: “ + wordCount);</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(“Total words: “ + totalWords);            </p>
<p>​       }             </p>
<p>}</p>
<p>class Word {</p>
<p>​       static int totalWords = 0;     </p>
<p>​       String s;  </p>
<p>​       int count;</p>
<p>​       Word(String s, int count) { </p>
<p>​              this.s = s; </p>
<p>​              this.count = count;</p>
<p>​              totalWords++;</p>
<p>​       }</p>
<p>​       public String toString() { return s + “: “ + count; }</p>
<p>}</p>
<p>public class UniqueWords22 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<string> words = new ArrayList<string>(</string></string></p>
<p>​                     new TextFile(“SetOperations.java”, “\W+”));            </p>
<p>​              Collections.sort(words, String.CASE_INSENSITIVE_ORDER);</p>
<p>​              System.out.println(“Words to count, sorted: “ + words);</p>
<p>​              Set<word> wordObjects = new HashSet<word>();</word></word></p>
<p>​              Iterator it = words.iterator(); </p>
<p>​              while(it.hasNext()) {</p>
<p>​                     String s = (String)it.next();</p>
<p>​                     int count = 0;               </p>
<p>​                     for(int i = 0; i &lt; words.size(); i++) {</p>
<p>​                            if(s.equals(words.get(i))) count++;</p>
<p>​                     }</p>
<p>​                     Word w = new Word(s, count);</p>
<p>​                     wordObjects.add(w);</p>
<p>​              }             </p>
<p>​              System.out.println(“Word count: “ + wordObjects);</p>
<p>​              System.out.println(“Total words: “ + Word.totalWords);          </p>
<p>​       }             </p>
<p>}</p>
<p>public class Statistics23 {</p>
<p>​       private static int getBestInt20(int n) {</p>
<p>​              Random rand = new Random();</p>
<p>​              Map&lt;Integer, Integer&gt; m =</p>
<p>​                     new TreeMap&lt;Integer, Integer&gt;();</p>
<p>​              for(int i = 0; i &lt; 10000; i++) {</p>
<p>​                                         int r = rand.nextInt(20);</p>
<p>​                     Integer freq = m.get(r);</p>
<p>​                     m.put(r, freq == null ? 1 : freq + 1);</p>
<p>​              }</p>
<p>​              int max = 0;</p>
<p>​              for(int i = 0; i &lt; m.keySet().size(); i++) {</p>
<p>​                     max = max &lt; m.get(i) ? m.get(i) : max;</p>
<p>​              }</p>
<p>​              Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; me = new </p>
<p>​                     LinkedHashSet&lt;Map.Entry&lt;Integer,Integer&gt;&gt;(m.entrySet());</p>
<p>​              int maxKey = 0;</p>
<p>​              Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; it = me.iterator();</p>
<p>​              while(it.hasNext()) {</p>
<p>​                     Map.Entry&lt;Integer,Integer&gt; findMax = it.next();</p>
<p>​                     if(findMax.getValue() == max)</p>
<p>​                     maxKey = findMax.getKey();</p>
<p>​              }</p>
<p>​              return maxKey;                    </p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;Integer,Integer&gt; m20 =            </p>
<p>​                     new TreeMap&lt;Integer,Integer&gt;();</p>
<p>​              for(int i = 0; i &lt; 2000; i++) {</p>
<p>​                     int x = getBestInt20(10000);</p>
<p>​                     Integer freq = m20.get(x);</p>
<p>​                     m20.put(x, freq == null ? 1 : freq + 1);</p>
<p>​              }</p>
<p>​              System.out.println(“Most often picked ints, 0 - 19, in 2000 tests of 10,000 random picks: “ + m20);</p>
<p>​       }</p>
<p>}      </p>
<p>public class Ex24{  </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String,Integer&gt; m = </p>
<p>​                     new LinkedHashMap&lt;String,Integer&gt;();</p>
<p>​              m.put(“ten”, 10);</p>
<p>​              m.put(“nine”, 9);</p>
<p>​              m.put(“eight”, 8);</p>
<p>​              m.put(“seven”, 7);</p>
<p>​              m.put(“six”, 6);</p>
<p>​              m.put(“five”, 5);</p>
<p>​              m.put(“four”, 4);</p>
<p>​              m.put(“three”, 3);</p>
<p>​              m.put(“two”, 2);</p>
<p>​              m.put(“one”, 1);</p>
<p>​              m.put(“zero”, 0);</p>
<p>​              println(“Map to sort: “ + m);</p>
<p>​                           Map&lt;String,Integer&gt; mTemp = </p>
<p>​                     new LinkedHashMap&lt;String,Integer&gt;();</p>
<p>​                           Set<string> ss = new TreeSet<string>(m.keySet());</string></string></p>
<p>​                           Iterator<string> itss = ss.iterator();</string></p>
<p>​              while(itss.hasNext()) {</p>
<p>​                     String s = (String)itss.next();</p>
<p>​                     Integer i = m.get(s);</p>
<p>​                     m.remove(s);</p>
<p>​                     mTemp.put(s, i);</p>
<p>​              }</p>
<p>​                           Set<string> ssTemp = </string></p>
<p>​                     new TreeSet<string>(mTemp.keySet());</string></p>
<p>​                           Iterator<string> itssTemp = ssTemp.iterator();</string></p>
<p>​              while(itssTemp.hasNext()) {</p>
<p>​                     String s = (String)itssTemp.next();</p>
<p>​                     Integer i = mTemp.get(s);</p>
<p>​                     mTemp.remove(s);</p>
<p>​                     m.put(s, i);</p>
<p>​              }</p>
<p>​                           mTemp.clear();</p>
<p>​              println(“Sorted map: “ + m);</p>
<p>​       }</p>
<p>}      </p>
<p>public class Ex24b{       </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String,Integer&gt; m = </p>
<p>​                     new LinkedHashMap&lt;String,Integer&gt;();</p>
<p>​              m.put(“ten”, 10);</p>
<p>​              m.put(“nine”, 9);</p>
<p>​              m.put(“eight”, 8);</p>
<p>​              m.put(“seven”, 7);</p>
<p>​              m.put(“six”, 6);</p>
<p>​              m.put(“five”, 5);</p>
<p>​              m.put(“four”, 4);</p>
<p>​              m.put(“three”, 3);</p>
<p>​              m.put(“two”, 2);</p>
<p>​              m.put(“one”, 1);</p>
<p>​              m.put(“zero”, 0);</p>
<p>​              println(“Map to sort: “ + m);</p>
<p>​                           Map&lt;String,Integer&gt; mTemp = </p>
<p>​                     new LinkedHashMap&lt;String,Integer&gt;();</p>
<p>​                                        List<string> ss2List = </string></p>
<p>​                     new LinkedList<string>(m.keySet());</string></p>
<p>​                           Collections.sort(ss2List);</p>
<p>​                           Iterator<string> itss2List = ss2List.iterator();</string></p>
<p>​              while(itss2List.hasNext()) {</p>
<p>​                     String s = (String)itss2List.next();</p>
<p>​                     Integer i = m.get(s);</p>
<p>​                     m.remove(s);</p>
<p>​                     mTemp.put(s, i);</p>
<p>​              }</p>
<p>​                           List<string> ssTemp = </string></p>
<p>​                     new LinkedList<string>(mTemp.keySet());</string></p>
<p>​                           Iterator<string> itssTemp = ssTemp.iterator();</string></p>
<p>​              while(itssTemp.hasNext()) {</p>
<p>​                     String s = (String)itssTemp.next();</p>
<p>​                     Integer i = mTemp.get(s);</p>
<p>​                     mTemp.remove(s);</p>
<p>​                     m.put(s, i);</p>
<p>​              }</p>
<p>​                           mTemp.clear();</p>
<p>​              println(“Sorted map: “ + m);       </p>
<p>​       }</p>
<p>}      </p>
<p>public class Ex25 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String,ArrayList<integer>&gt; m = </integer></p>
<p>​                     new LinkedHashMap&lt;String,ArrayList<integer>&gt;();</integer></p>
<p>​              List<string> words = new LinkedList<string>();</string></string></p>
<p>​              words.addAll(new TextFile(“SetOperations.java”, “\W+”));</p>
<p>​              System.out.println(“Words in file: “ + words);</p>
<p>​              Iterator itWords = words.iterator();</p>
<p>​              int count = 0;</p>
<p>​              while(itWords.hasNext()) {</p>
<p>​                     String s = (String)itWords.next();</p>
<p>​                     count++;                     </p>
<p>​                     if(!m.keySet().contains(s)) {   </p>
<p>​                            ArrayList<integer> ai = </integer></p>
<p>​                                   new ArrayList<integer>();           </integer></p>
<p>​                            ai.add(0, count);</p>
<p>​                            m.put(s, ai);</p>
<p>​                     }</p>
<p>​                     else {</p>
<p>​                            m.get(s).add(count);</p>
<p>​                            m.put(s, m.get(s));       </p>
<p>​                     }</p>
<p>​              }</p>
<p>​              System.out.println(“Map of word locations: “ + m);                </p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex26 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Map&lt;String,ArrayList<integer>&gt; m = </integer></p>
<p>​                     new LinkedHashMap&lt;String,ArrayList<integer>&gt;();</integer></p>
<p>​              List<string> words = new LinkedList<string>();</string></string></p>
<p>​              words.addAll(new TextFile(“SetOperations.java”, “\W+”));</p>
<p>​              System.out.println(“Words in file: “ + words);</p>
<p>​              Iterator itWords = words.iterator();</p>
<p>​              int count = 0;</p>
<p>​              while(itWords.hasNext()) {</p>
<p>​                     String s = (String)itWords.next();</p>
<p>​                     count++;                     </p>
<p>​                     if(!m.keySet().contains(s)) {   </p>
<p>​                            ArrayList<integer> ai = </integer></p>
<p>​                                   new ArrayList<integer>();           </integer></p>
<p>​                            ai.add(0, count);</p>
<p>​                            m.put(s, ai);</p>
<p>​                     }</p>
<p>​                     else {</p>
<p>​                            m.get(s).add(count);</p>
<p>​                            m.put(s, m.get(s));       </p>
<p>​                     }</p>
<p>​              }</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(“Map of word locations: “ + m);</p>
<p>​                           Map&lt;Integer,String&gt; replay = new TreeMap&lt;Integer,String&gt;();</p>
<p>​              Iterator&lt;Map.Entry&lt;String,ArrayList<integer>&gt;&gt; it = </integer></p>
<p>​                     m.entrySet().iterator();</p>
<p>​              while(it.hasNext()) {</p>
<p>​                     Map.Entry&lt;String,ArrayList<integer>&gt; me = it.next();</integer></p>
<p>​                     for(int i = 0; i &lt; me.getValue().size(); i++)</p>
<p>​                            replay.put(me.getValue().get(i),</p>
<p>​                                   me.getKey());</p>
<p>​              }</p>
<p>​              System.out.println();</p>
<p>​              System.out.println(“TreeMap of ordered locations, words: “ + replay);</p>
<p>​              System.out.println();</p>
<p>​                           System.out.println(“Words in original order: “ +</p>
<p>​                     replay.values());</p>
<p>​       }      </p>
<p>}</p>
<p>class Command {</p>
<p>​       String s;</p>
<p>​       Command(String s) { this.s = s; }</p>
<p>​       void operation() { System.out.print(s); }</p>
<p>}</p>
<p>class Build {    </p>
<p>​       Queue<command> makeQ() {</p>
<p>​              Queue<command> q = new LinkedList<command>();</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     q.offer(new Command(i + “ “));</p>
<p>​              return q;</p>
<p>​       }</p>
<p>}</p>
<p>public class Queue27 {</p>
<p>​       public static void commandEater(Queue<command> qc) {</p>
<p>​              while(qc.peek() != null)</p>
<p>​                     qc.poll().operation();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Build b = new Build();</p>
<p>​              commandEater(b.makeQ()); </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex28 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Random rand = new Random();</p>
<p>​              PriorityQueue<double> d = new PriorityQueue<double>();</double></double></p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     d.offer(rand.nextDouble() * i);</p>
<p>​              while(d.peek() != null)</p>
<p>​                     System.out.print(d.poll() + “ “);</p>
<p>​       }</p>
<p>}</p>
<p>class Simple extends Object {}</p>
<p>public class Ex29 {</p>
<p>​       public static void main(String[] args) {       </p>
<p>​              PriorityQueue<simple> s = new PriorityQueue<simple>();</simple></simple></p>
<p>​                           s.offer(new Simple());</p>
<p>​                                        s.offer(new Simple());</p>
<p>​       }</p>
<p>}</p>
<p> import typeinfo.pets.*;</p>
<p>import java.util.*;</p>
<p>public class CollectionSequence30 implements Collection<pet> {</pet></p>
<p>​       private Pet[] pets = Pets.createArray(8);</p>
<p>​       public int size() { return pets.length; }</p>
<p>​       public Iterator<pet> iterator() {</pet></p>
<p>​              return new Iterator<pet>() {</pet></p>
<p>​                     private int index = 0;</p>
<p>​                     public boolean hasNext() {</p>
<p>​                            return index &lt; pets.length; </p>
<p>​                     }</p>
<p>​                     public Pet next() { return pets[index++]; }</p>
<p>​                     public void remove() {                             throw new UnsupportedOperationException();</p>
<p>​                     }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public void clear() { </p>
<p>​              if(this.size() != 0)</p>
<p>​              for(Pet p : pets)</p>
<p>​                     p = null;</p>
<p>​       }</p>
<p>​       public boolean retainAll(Collection&lt;?&gt; c) { </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public boolean removeAll(Collection&lt;?&gt; c) { </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public boolean addAll(Collection&lt;? extends Pet&gt; c) { </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public boolean contains(Object o) {   </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public boolean isEmpty() {   </p>
<p>​              return (this.size() == 0) ? true : false;</p>
<p>​       }</p>
<p>​       public boolean containsAll(Collection&lt;?&gt; c) { </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public boolean remove(Object o) { </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public boolean add(Pet p) { </p>
<p>​              throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public Object[] toArray() {</p>
<p>​              return pets;</p>
<p>​       }</p>
<p>​       public <t> T[] toArray(T[] a) {</t></p>
<p>​            throw new UnsupportedOperationException();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              CollectionSequence30 c = new CollectionSequence30();</p>
<p>​              InterfaceVsIterator.display(c);</p>
<p>​              InterfaceVsIterator.display(c.iterator());</p>
<p>​       }</p>
<p>}</p>
<p>public class RandomShapeGenerator31 implements Iterable<shape> {</shape></p>
<p>​       private Random rand = new Random();</p>
<p>​       public Shape make() {          </p>
<p>​              switch(rand.nextInt(3)) {</p>
<p>​                     default:</p>
<p>​                     case 0: return new Circle();</p>
<p>​                     case 1: return new Square();</p>
<p>​                     case 2: return new Triangle();</p>
<p>​              }</p>
<p>​       }</p>
<p>​       private Shape[] shapes;</p>
<p>​       RandomShapeGenerator31(int n) {</p>
<p>​              shapes = new Shape[n];</p>
<p>​              for(int i = 0; i &lt; n; i++)</p>
<p>​                     shapes[i] = make();</p>
<p>​                             </p>
<p>​       }</p>
<p>​       public Iterator<shape> iterator() {</shape></p>
<p>​              return new Iterator<shape>() {</shape></p>
<p>​                     private int index = 0;</p>
<p>​                     public boolean hasNext() {</p>
<p>​                            return index &lt; shapes.length;</p>
<p>​                     }</p>
<p>​                     public Shape next() {</p>
<p>​                            return shapes[index++];</p>
<p>​                     }</p>
<p>​                     public void remove() {</p>
<p>​                            throw new UnsupportedOperationException();</p>
<p>​                     }                    </p>
<p>​              };</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              RandomShapeGenerator31 rsg = new RandomShapeGenerator31(20);</p>
<p>​              for(Shape s : rsg)</p>
<p>​                     System.out.println(s);</p>
<p>​       }</p>
<p>}</p>
<p>class PetSequence {</p>
<p>​       protected Pet[] pets = Pets.createArray(8);</p>
<p>}</p>
<p>public class NonCollectionSequence32 </p>
<p>​       extends PetSequence implements Iterable {</p>
<p>​       public Iterator<pet> iterator() {</pet></p>
<p>​              return new Iterator<pet>() {</pet></p>
<p>​                     private int index = 0;</p>
<p>​                     public boolean hasNext() {</p>
<p>​                            return index &lt; pets.length;</p>
<p>​                     }      </p>
<p>​                     public Pet next() { return pets[index++]; }</p>
<p>​                     public void remove() {</p>
<p>​                            throw new UnsupportedOperationException();</p>
<p>​                     }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public Iterable<pet> reversed() {</pet></p>
<p>​              return new Iterable<pet>() {</pet></p>
<p>​                     public Iterator<pet> iterator() {</pet></p>
<p>​                            return new Iterator<pet>() {</pet></p>
<p>​                                   int current = pets.length - 1;</p>
<p>​                                   public boolean hasNext() {</p>
<p>​                                          return current &gt; -1;</p>
<p>​                                   }</p>
<p>​                                   public Pet next() {</p>
<p>​                                          return pets[current–];</p>
<p>​                                   }</p>
<p>​                                   public void remove() {</p>
<p>​                                          throw new</p>
<p>​                                          UnsupportedOperationException();</p>
<p>​                                   }</p>
<p>​                            };</p>
<p>​                     }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public Iterable<pet> randomized() {</pet></p>
<p>​              return new Iterable<pet>() {</pet></p>
<p>​                     public Iterator<pet> iterator() {</pet></p>
<p>​                            List<pet> shuffled = new</pet></p>
<p>​                                  ArrayList<pet>(Arrays.asList(pets));</pet></p>
<p>​                            Collections.shuffle(shuffled, new Random());</p>
<p>​                            return shuffled.iterator();</p>
<p>​                     }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              NonCollectionSequence32 nc = new NonCollectionSequence32();</p>
<p>​              print(“pets: “);</p>
<p>​              for(Pet p : nc.pets)</p>
<p>​                     print(p + “ “);</p>
<p>​              println();</p>
<p>​              print(“reversed: “);</p>
<p>​              for(Pet p : nc.reversed())</p>
<p>​                     print(p + “ “);</p>
<p>​              println();</p>
<p>​              print(“randomized: “);</p>
<p>​              for(Pet p : nc.randomized())</p>
<p>​                     print(p + “ “);</p>
<p>​       }</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解泛型/" itemprop="url">Java题解泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h2><p>class Robot {</p>
<p>​       private String name;</p>
<p>​       public Robot(String name) { this.name = name; }</p>
<p>​       public String toString() { </p>
<p>​              return name;</p>
<p>​       }</p>
<p>}</p>
<p>public class HolderEx2<t> {</t></p>
<p>​       private T x, y, z;</p>
<p>​       public HolderEx2(T x, T y, T z) { </p>
<p>​              this.x = x;</p>
<p>​              this.y = y;</p>
<p>​              this.z = z;</p>
<p>​        }</p>
<p>​       public void setX(T x) { this.x = x; }</p>
<p>​       public void setY(T y) { this.y = y; }</p>
<p>​       public void setZ(T z) { this.z = z; }</p>
<p>​       public T getX() { return x; }</p>
<p>​       public T getY() { return y; }</p>
<p>​       public T getZ() { return z; }</p>
<p>​       public String toString() {</p>
<p>​              return x + “, “ + y + “, “ + z;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Robot a = new Robot(“bot1”);</p>
<p>​              Robot b = new Robot(“bot2”);</p>
<p>​              Robot c = new Robot(“bot3”);</p>
<p>​              HolderEx2<robot> hEx2 = </robot></p>
<p>​                     new HolderEx2<robot>(a, b, c);</robot></p>
<p>​              System.out.println(“Holding: “ + hEx2);</p>
<p>​       }</p>
<p>}</p>
<p>class Robot {}</p>
<p>class Amphibian {}</p>
<p>class Vehicle {}</p>
<p>class SixTuple&lt;A,B,C,D,E,F&gt;</p>
<p>extends FiveTuple&lt;A,B,C,D,E&gt; {</p>
<p>  public final F sixth;</p>
<p>  public SixTuple(A a, B b, C c, D d, E e, F f) {</p>
<p>​    super(a, b, c, d, e);</p>
<p>​    sixth = f;</p>
<p>  }</p>
<p>  public String toString() {</p>
<p>​    return “(“ + first + “, “ + second + “, “ +</p>
<p>​      third + “, “ + fourth + “, “ + fifth + “, “ + sixth +”)”;</p>
<p>  }</p>
<p>} </p>
<p>public class SixTupleTest {</p>
<p>​       static SixTuple&lt;Robot, Vehicle, Amphibian, String, Integer, Double&gt; f() {</p>
<p>​              return new SixTuple&lt;Robot, Vehicle, Amphibian, String, Integer, Double&gt;( </p>
<p>​              new Robot(), new Vehicle(), new Amphibian(), “hi”, 47, 11.1);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              SixTuple&lt;Robot, Vehicle, Amphibian, String, Integer, Double&gt; st = f();</p>
<p>​              System.out.println(st);</p>
<p>​              System.out.println(f());         </p>
<p>​       }</p>
<p>} </p>
<p>interface Selector {</p>
<p>​       boolean end();</p>
<p>​       Object current();</p>
<p>​       void next();</p>
<p>}</p>
<p>public class GenericSequence<e> {    </e></p>
<p>​       private List<e> list = new ArrayList<e>();</e></e></p>
<p>​       private int next = 0;</p>
<p>​       public GenericSequence(List<e> list) { this.list = list; }</e></p>
<p>​       public void add(E e) { list.add(e); }</p>
<p>​       private class SequenceSelector implements Selector {</p>
<p>​              private int i = 0;</p>
<p>​              public boolean end() { return i == list.size(); }</p>
<p>​              public Object current() { return list.get(i); }</p>
<p>​              public void next() { if(i &lt; list.size()) i++; } </p>
<p>​       }</p>
<p>​       public Selector selector() {</p>
<p>​              return new SequenceSelector();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<string> ls = new ArrayList<string>();</string></string></p>
<p>​              GenericSequence<string> gs = new GenericSequence<string>(ls);</string></string></p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     gs.add(Integer.toString(i));</p>
<p>​              Selector selector = gs.selector();</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class LinkedStack5<t> {</t></p>
<p>​             private class Node {</p>
<p>​              T item;</p>
<p>​              Node next;</p>
<p>​              Node() { item = null; next = null; }</p>
<p>​              Node(T item, Node next) {</p>
<p>​                     this.item = item;</p>
<p>​                     this.next = next;</p>
<p>​              }</p>
<p>​              boolean end() { return item == null &amp;&amp; next == null; }</p>
<p>​       }</p>
<p>​       private Node top = new Node();      public void push(T item) {</p>
<p>​              top = new Node(item, top);</p>
<p>​       }</p>
<p>​       public T pop() {</p>
<p>​              T result = top.item;</p>
<p>​              if(!top.end())</p>
<p>​                     top = top.next;</p>
<p>​              return result;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              LinkedStack5<string> lss = new LinkedStack5<string>();</string></string></p>
<p>​              for(String s: “Phasers on stun!”.split(“ “)) </p>
<p>​                     lss.push(s);</p>
<p>​              String s;</p>
<p>​              while((s = lss.pop()) != null)</p>
<p>​                     System.out.println(s);</p>
<p>​       }</p>
<p>}</p>
<p>public class RandomList6<t> {</t></p>
<p>​       private ArrayList<t> storage = new ArrayList<t>();</t></t></p>
<p>​       private Random rand = new Random(47);</p>
<p>​       public void add(T item) { storage.add(item); }</p>
<p>​       public T select() {</p>
<p>​              return storage.get(rand.nextInt(storage.size()));</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              RandomList6<string> rs = new RandomList6<string>();</string></string></p>
<p>​              for(String s : (“The quick brown fox jumped over “ +</p>
<p>​                     “the lazy brown dog”).split(“ “))</p>
<p>​                     rs.add(s);</p>
<p>​              for(int i = 0; i &lt; 11; i++)</p>
<p>​                     System.out.print(rs.select() + “ “);</p>
<p>​              System.out.println();</p>
<p>​              RandomList6<integer> ri = new RandomList6<integer>();</integer></integer></p>
<p>​              for(int i = 0; i &lt; 11; i++)</p>
<p>​                     ri.add(i);               for(int i = 0; i &lt; 11; i++)</p>
<p>​                     System.out.print(ri.select() + “ “); </p>
<p>​              System.out.println();</p>
<p>​              RandomList6<pet> rp = new RandomList6<pet>();</pet></pet></p>
<p>​              for(Pet p : Pets.arrayList(10))</p>
<p>​                     rp.add(p);</p>
<p>​              for(int i = 0; i &lt; 11; i++)</p>
<p>​                     System.out.print(rp.select() + “ “);      </p>
<p>​       }</p>
<p>}</p>
<p>public class Fibonacci7 implements Generator<integer>, Iterable<integer> {</integer></integer></p>
<p>​       private int count = 0;</p>
<p>​       private int m;</p>
<p>​       public Integer next() { return fib(count++); }</p>
<p>​       private int fib(int n) {</p>
<p>​              if(n &lt; 2) return 1;</p>
<p>​              return fib(n - 2) + fib(n - 1);</p>
<p>​       }</p>
<p>​       public Fibonacci7() {}</p>
<p>​       public Fibonacci7(int m) { this.m = m; }</p>
<p>​       public Iterator<integer> iterator() {</integer></p>
<p>​              return new Iterator<integer>() {</integer></p>
<p>​                     public boolean hasNext() { return m &gt; 0; }</p>
<p>​                     public Integer next() {</p>
<p>​                            m–;</p>
<p>​                            return Fibonacci7.this.next();</p>
<p>​                     }</p>
<p>​                     public void remove() {                             throw new UnsupportedOperationException();</p>
<p>​                     }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Fibonacci7 gen = new Fibonacci7();</p>
<p>​              for(int i = 0; i &lt; 18; i++)</p>
<p>​                     System.out.print(gen.next() + “ “);</p>
<p>​              System.out.println();</p>
<p>​              Iterator it = new Fibonacci7(20).iterator();</p>
<p>​              while(it.hasNext())</p>
<p>​                     System.out.print(it.next() + “ “);</p>
<p>​       }</p>
<p>​       </p>
<p>}</p>
<p>public class StoryCharacterGenerator </p>
<p>​       implements Generator<storycharacter>,  Iterable<storycharacter> {</storycharacter></storycharacter></p>
<p>​       private Class[] types = { DarthVader.class, JabbaTheHut.class, </p>
<p>​              LukeSkywalker.class, Yoda.class };</p>
<p>​       private static Random rand = new Random();</p>
<p>​       public StoryCharacterGenerator() {}</p>
<p>​             private int size = 0;</p>
<p>​       public StoryCharacterGenerator(int sz) { size = sz; }</p>
<p>​       public StoryCharacter next() {</p>
<p>​              try {</p>
<p>​                     return </p>
<p>​                     (StoryCharacter)types[rand.nextInt(types.length)].newInstance();</p>
<p>​                           } catch(Exception e) {</p>
<p>​                     throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​       }      </p>
<p>​       class StoryCharacterIterator implements Iterator<storycharacter> {</storycharacter></p>
<p>​              int count = size;</p>
<p>​              public boolean hasNext() { return count &gt; 0; }</p>
<p>​              public StoryCharacter next() {</p>
<p>​                     count–;</p>
<p>​                     return StoryCharacterGenerator.this.next();</p>
<p>​              }</p>
<p>​              public void remove() {                      throw new UnsupportedOperationException();</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public Iterator<storycharacter> iterator() {</storycharacter></p>
<p>​              return new StoryCharacterIterator();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              StoryCharacterGenerator gen = new StoryCharacterGenerator();</p>
<p>​              for(int i = 0; i &lt; 5; i++)</p>
<p>​                     System.out.println(gen.next());</p>
<p>​              for(StoryCharacter s : new StoryCharacterGenerator(5))</p>
<p>​                     System.out.println(s); </p>
<p>​       }</p>
<p>}</p>
<p>  public class GenericMethods9 {</p>
<p>​       public &lt;T, U, V&gt; void f(T x, U y, V z) {</p>
<p>​              System.out.println(x.getClass().getName() +</p>
<p>​              “ “ + y.getClass().getName() +</p>
<p>​              “ “ + z.getClass().getName());</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GenericMethods9 gm = new GenericMethods9();</p>
<p>​              gm.f(“”, 1, 1.0);</p>
<p>​              gm.f(1.0F, ‘c’, gm);</p>
<p>​       }</p>
<p>}</p>
<p>  public class GenericMethods10 {</p>
<p>​       public &lt;T, U&gt; void f(T x, U y, Integer z) {</p>
<p>​              System.out.println(x.getClass().getName() +</p>
<p>​              “ “ + y.getClass().getName() +</p>
<p>​              “ “ + z.getClass().getName());</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GenericMethods10 gm = new GenericMethods10();</p>
<p>​              gm.f(“”, 1, 1);</p>
<p>​              gm.f(1.0F, ‘c’, 1);</p>
<p>​       }</p>
<p>}</p>
<p>class A { public String toString() { return “A”; } }</p>
<p>class B { public String toString() { return “B”; } }</p>
<p>class C extends B { </p>
<p>​       public String toString() { return “C”; }</p>
<p>}  </p>
<p>public class New11 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              A a = new A();</p>
<p>​              B b = new B();</p>
<p>​              C c = new C();</p>
<p>​              List<c> lc = New.list();</c></p>
<p>​              lc.add(new C());</p>
<p>​              Map&lt;A,List&lt;? extends B&gt;&gt; mab = New.map();</p>
<p>​              mab.put(a,lc);</p>
<p>​              LinkedList<b> llb = New.lList();</b></p>
<p>​              llb.add(new B());</p>
<p>​              Set<a> sa = New.set();</a></p>
<p>​              sa.add(new A());</p>
<p>​              Queue<b> qb = New.queue();</b></p>
<p>​              qb.add(new B());</p>
<p>​              println(lc);</p>
<p>​              println(mab);</p>
<p>​              println(llb);</p>
<p>​              println(sa);</p>
<p>​              println(qb);</p>
<p>​       }</p>
<p>}</p>
<p>public class LimitsOfInference12 {</p>
<p>​       static void f(Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople) {}</p>
<p>​       public static void main(String[] args) {</p>
<p>​              f(New.&lt;Person, List&lt;? extends Pet&gt;&gt;map()); </p>
<p>​       }</p>
<p>}</p>
<p>public class Generators13 {</p>
<p>​       public static <t> Collection<t> fill(Collection<t> coll, Generator<t> gen, int n) {</t></t></t></t></p>
<p>​              for(int i = 0; i &lt; n; i++) coll.add(gen.next());</p>
<p>​              return coll;</p>
<p>​       }</p>
<p>​       public static <t> List<t> fill(List<t> l, Generator<t> gen, int n) {</t></t></t></t></p>
<p>​              for(int i = 0; i &lt; n; i++) l.add(gen.next());</p>
<p>​              return l;</p>
<p>​       }</p>
<p>​       public static <t> Queue<t> fill(Queue<t> q, Generator<t> gen, int n) {</t></t></t></t></p>
<p>​              for(int i = 0; i &lt; n; i++) q.add(gen.next());</p>
<p>​              return q;</p>
<p>​       }</p>
<p>​       public static <t> Set<t> fill(Set<t> s, Generator<t> gen, int n) {</t></t></t></t></p>
<p>​              for(int i = 0; i &lt; n; i++) s.add(gen.next());</p>
<p>​              return s;</p>
<p>​       }</p>
<p>​             public static <t> LinkedList<t> fill(LinkedList<t> ll, Generator<t> gen, int n) {</t></t></t></t></p>
<p>​              for(int i = 0; i &lt; n; i++) ll.add(gen.next());</p>
<p>​              return ll;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Collection<coffee> coffee = fill(new ArrayList<coffee>(), new CoffeeGenerator(), 4);</coffee></coffee></p>
<p>​              for(Coffee c : coffee) System.out.println(c);</p>
<p>​              Collection<integer> fnumbers = fill(new ArrayList<integer>(), new Fibonacci(), 12);</integer></integer></p>
<p>​              for(int i : fnumbers) System.out.print(i + “, “);</p>
<p>​              println();</p>
<p>​              List<coffee> coffeeList = fill(new ArrayList<coffee>(), new CoffeeGenerator(), 5);</coffee></coffee></p>
<p>​              println(“List type: “ + coffeeList.getClass());</p>
<p>​              println(“coffeeList:” + coffeeList);        </p>
<p>​              Queue<coffee> coffeeQueue = fill(new ArrayDeque<coffee>(), new CoffeeGenerator(), 5);</coffee></coffee></p>
<p>​              println(“Queue type: “ + coffeeQueue.getClass());</p>
<p>​              println(“coffeeQueue: “ + coffeeQueue); </p>
<p>​              Set<coffee> coffeeSet = fill(new HashSet<coffee>(), new CoffeeGenerator(), 5);</coffee></coffee></p>
<p>​              println(“Set type: “ + coffeeSet.getClass());</p>
<p>​              println(“coffeeSet: “ + coffeeSet);</p>
<p>​              LinkedList<coffee> coffeeLinkedList = fill(new LinkedList<coffee>(), new CoffeeGenerator(), 5);</coffee></coffee></p>
<p>​              println(“LinkedList type: “ + coffeeLinkedList.getClass());</p>
<p>​              println(“coffeeLinkedList: “ + coffeeLinkedList);</p>
<p>​       }</p>
<p>}</p>
<p>public class BasicGeneratorDemo14  {     </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Generator<countedobject> gen = </countedobject></p>
<p>​                     new BasicGenerator<countedobject>(CountedObject.class);</countedobject></p>
<p>​              for(int i = 0; i &lt; 5; i++)</p>
<p>​                     System.out.println(gen.next());</p>
<p>​       }</p>
<p>}</p>
<p>public class TupleTest15 {</p>
<p>​       static TwoTuple&lt;String,Integer&gt; f() {</p>
<p>​              return tuple(“hi”, 47);</p>
<p>​       }</p>
<p>​       static TwoTuple f2() { return tuple(“hi”, 47); }</p>
<p>​       static ThreeTuple&lt;Amphibian,String,Integer&gt; g() {</p>
<p>​              return tuple(new Amphibian(), “hi”, 47);</p>
<p>​       }</p>
<p>​       static FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; h() {</p>
<p>​              return tuple(new Vehicle(), new Amphibian(), “hi”, 47);</p>
<p>​       }</p>
<p>​       static FiveTuple&lt;Vehicle,Amphibian,String,Integer,Double&gt; k() {</p>
<p>​              return tuple(new Vehicle(), new Amphibian(), “hi”, 47,</p>
<p>​              11.1);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              TwoTuple&lt;String,Integer&gt; ttsi = f();</p>
<p>​                           TwoTuple&lt;String,Integer&gt; ttsi2 = f2();</p>
<p>​              System.out.println(ttsi);</p>
<p>​              System.out.println(f2());</p>
<p>​              System.out.println(g());</p>
<p>​              System.out.println(h());</p>
<p>​              System.out.println(k());</p>
<p>​       }</p>
<p>}</p>
<p>public class TupleTest16 {</p>
<p>​       static TwoTuple&lt;String,Integer&gt; f() {</p>
<p>​              return tuple(“hi”, 47);</p>
<p>​       }</p>
<p>​       static TwoTuple f2() { return tuple(“hi”, 47); }</p>
<p>​       static ThreeTuple&lt;Amphibian,String,Integer&gt; g() {</p>
<p>​              return tuple(new Amphibian(), “hi”, 47);</p>
<p>​       }</p>
<p>​       static FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; h() {</p>
<p>​              return tuple(new Vehicle(), new Amphibian(), “hi”, 47);</p>
<p>​       }</p>
<p>​       static FiveTuple&lt;Vehicle,Amphibian,String,Integer,Double&gt; k() {</p>
<p>​              return tuple(new Vehicle(), new Amphibian(), “hi”, 47,</p>
<p>​              11.1);</p>
<p>​       }</p>
<p>​             static org.greggordon.util.SixTuple&lt;Robot,Vehicle,Amphibian,String,Integer,Double&gt; m() {</p>
<p>​              return tuple(new Robot(), new Vehicle(), new Amphibian(), “hi”, 47, 11.1);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              TwoTuple&lt;String,Integer&gt; ttsi = f();</p>
<p>​              System.out.println(ttsi);</p>
<p>​              System.out.println(f2());</p>
<p>​              System.out.println(g());</p>
<p>​              System.out.println(h());</p>
<p>​              System.out.println(k());</p>
<p>​              System.out.println(m());</p>
<p>​       }</p>
<p>}</p>
<p>public class Sets17 {     </p>
<p>​       public static <t> Set<t> union(Set<t> a, Set<t> b) {          </t></t></t></t></p>
<p>​              try {</p>
<p>​                     if(a instanceof EnumSet) {</p>
<p>​                            Set<t> result = ((EnumSet<t>)a).clone();</t></t></p>
<p>​                            result.addAll(b);</p>
<p>​                                return result;</p>
<p>​                            }</p>
<p>​              } catch(Exception e) {</p>
<p>​                     throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​              Set<t> result = new HashSet<t>(a);</t></t></p>
<p>​                  result.addAll(b);</p>
<p>​                  return result;</p>
<p>​       }      </p>
<p>​      public static <t> Set<t> intersection(Set<t> a, Set<t> b) {</t></t></t></t></p>
<p>​              try {</p>
<p>​                     if(a instanceof EnumSet) {</p>
<p>​                            Set<t> result = ((EnumSet<t>)a).clone();</t></t></p>
<p>​                            result.retainAll(b);</p>
<p>​                                return result;</p>
<p>​                            }</p>
<p>​              } catch(Exception e) {</p>
<p>​                     throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​                  Set<t> result = new HashSet<t>(a);</t></t></p>
<p>​                  result.retainAll(b);</p>
<p>​                  return result;</p>
<p>​      }      </p>
<p>​           public static <t> Set<t>  difference(Set<t> superset, Set<t> subset) {</t></t></t></t></p>
<p>​              try {</p>
<p>​                     if(superset instanceof EnumSet) {</p>
<p>​                            Set<t> result = ((EnumSet<t>)superset).clone();</t></t></p>
<p>​                            result.removeAll(subset);</p>
<p>​                                return result;</p>
<p>​                            }</p>
<p>​              } catch(Exception e) {</p>
<p>​                     throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​                  Set<t> result = new HashSet<t>(superset);</t></t></p>
<p>​                  result.removeAll(subset);</p>
<p>​                  return result;</p>
<p>​      }</p>
<p>​           public static <t> Set<t> complement(Set<t> a, Set<t> b) {</t></t></t></t></p>
<p>​                  return difference(union(a, b), intersection(a, b));</p>
<p>​      }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Set<watercolors> set1 =</watercolors></p>
<p>​                     EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);</p>
<p>​              Set<watercolors> set2 =</watercolors></p>
<p>​                     EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);</p>
<p>​              print(“set1: “ + set1);</p>
<p>​              print(“set2: “ + set2);</p>
<p>​              print(“union(set1, set2): “ + union(set1, set2));</p>
<p>​              Set<watercolors> subset = intersection(set1, set2);</watercolors></p>
<p>​              print(“intersection(set1, set2): “ + subset);</p>
<p>​              print(“difference(set1, set2): “ + </p>
<p>​                     difference(set1, set2));</p>
<p>​              print(“difference(set2, subset): “ + </p>
<p>​                     difference(set2, subset));</p>
<p>​              print(“complement(set1, set2): “ + </p>
<p>​                     complement(set1, set2));</p>
<p>​       }</p>
<p>} </p>
<p>class BigFish {</p>
<p>​       private static long counter = 0;</p>
<p>​       private final long id = ++counter;</p>
<p>​       private BigFish() {}</p>
<p>​       public String toString() {</p>
<p>​              return “BigFish” + id;</p>
<p>​       }</p>
<p>​       public static Generator<bigfish> generator() {</bigfish></p>
<p>​              return new Generator<bigfish>() {</bigfish></p>
<p>​                     public BigFish next() {</p>
<p>​                            return new BigFish();</p>
<p>​                     }      </p>
<p>​              };</p>
<p>​       }</p>
<p>}</p>
<p>class LittleFish {</p>
<p>​       private static long counter = 0;</p>
<p>​       private final long id = ++counter;</p>
<p>​       private LittleFish() {}</p>
<p>​       public String toString() {</p>
<p>​              return “LittleFish” + id;</p>
<p>​       }</p>
<p>​       public static Generator<littlefish> generator =</littlefish></p>
<p>​              new Generator<littlefish>() {</littlefish></p>
<p>​                     public LittleFish next() {</p>
<p>​                            return new LittleFish();</p>
<p>​                     }</p>
<p>​              };</p>
<p>}</p>
<p>public class Ocean18 {</p>
<p>​       public static void eat(BigFish bf, LittleFish lf) {</p>
<p>​              System.out.println(bf + “ eats “ + lf);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Random rand = new Random();</p>
<p>​              List<bigfish> hunters = new ArrayList<bigfish>();</bigfish></bigfish></p>
<p>​              Generators.fill(hunters, BigFish.generator(), 3);</p>
<p>​              Queue<littlefish> school = new LinkedList<littlefish>();</littlefish></littlefish></p>
<p>​              Generators.fill(school, LittleFish.generator, 15);</p>
<p>​              for(LittleFish f : school)</p>
<p>​                     eat(hunters.get(rand.nextInt(hunters.size())), f);</p>
<p>​       }</p>
<p>}</p>
<p>class Item {</p>
<p>​       private final int id;</p>
<p>​       private String description;</p>
<p>​       private String destination;</p>
<p>​       private double price;</p>
<p>​       public Item(int idNumber, String what, String whereTo, double price) {</p>
<p>​              id = idNumber;</p>
<p>​              description = what;</p>
<p>​              destination = whereTo;</p>
<p>​              this.price = price;</p>
<p>​              System.out.println(toString());</p>
<p>​       } </p>
<p>​       public String toString() {</p>
<p>​              return id + “, “ + description + “, “ + “$” + price + “, to: “ +</p>
<p>​                     destination;</p>
<p>​       }</p>
<p>​       public void priceChange(double change) {</p>
<p>​              price += change;</p>
<p>​       }</p>
<p>​       public static Generator<item> generator = </item></p>
<p>​              new Generator<item>() {</item></p>
<p>​                     private Random rand = new Random();</p>
<p>​                     public Item next() {</p>
<p>​                            return new Item(rand.nextInt(1000), </p>
<p>​                            “Very nice … “,  “Destination: …”, </p>
<p>​                            Math.round(rand.nextDouble() * 1000.0)); </p>
<p>​                     }</p>
<p>​              };</p>
<p>}</p>
<p>class Shelf extends ArrayList<item> {</item></p>
<p>​       public Shelf(int nItems) {</p>
<p>​              Generators.fill(this, Item.generator, nItems);</p>
<p>​       }</p>
<p>}</p>
<p>class StorageArea extends ArrayList<shelf> {</shelf></p>
<p>​       public StorageArea(int nShelves, int nItems) {</p>
<p>​              for(int i = 0; i &lt; nShelves; i++)</p>
<p>​                     add(new Shelf(nItems));</p>
<p>​       }</p>
<p>}</p>
<p>class Deck extends ArrayList<storagearea> {</storagearea></p>
<p>​       public Deck(int nStorageAreas, int nShelves, int nItems) {</p>
<p>​              for(int i = 0; i &lt; nStorageAreas; i++)</p>
<p>​                     add(new StorageArea(nShelves, nItems));</p>
<p>​       }</p>
<p>}</p>
<p>class Office {}</p>
<p>public class CargoShip19 extends ArrayList<deck> {</deck></p>
<p>​       private Office office;</p>
<p>​       public CargoShip19(int nDecks, int nStorageAreas, int nShelves, int nItems) {</p>
<p>​              for(int i = 0; i &lt; nDecks; i++)</p>
<p>​                     add(new Deck(nStorageAreas, nShelves, nItems));</p>
<p>​       }      </p>
<p>​       public String toString() {</p>
<p>​              StringBuilder result = new StringBuilder();</p>
<p>​              for(Deck d : this)</p>
<p>​                     for(StorageArea sa : d)</p>
<p>​                            for(Shelf s : sa)</p>
<p>​                                   for(Item i : s) {</p>
<p>​                                          result.append(i);</p>
<p>​                                          result.append(‘\n’);</p>
<p>​                                   }</p>
<p>​              return result.toString();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              System.out.println(new CargoShip19(3, 4, 3, 10));</p>
<p>​       }</p>
<p>}</p>
<p>interface A {</p>
<p>​       void f();</p>
<p>​       void g();</p>
<p>}</p>
<p>class A3 implements A {</p>
<p>​       public void f() { System.out.println(“A3.f()”); }</p>
<p>​       public void g() { System.out.println(“A3.g()”); }</p>
<p>​       public void h() { System.out.println(“A3.h()”); }</p>
<p>}</p>
<p>class G {</p>
<p>​       public static <t extends a> void j(T x) { </t></p>
<p>​              x.f();</p>
<p>​              x.g();</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex20 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              A3 a3 = new A3();</p>
<p>​              G.j(a3);    </p>
<p>​       }</p>
<p>}</p>
<p>public class ClassTypeCapture21<t> {</t></p>
<p>​       Class&lt;?&gt; kind;</p>
<p>​       Map&lt;String,Class&lt;?&gt;&gt; map;</p>
<p>​       public ClassTypeCapture21(Class&lt;?&gt; kind) {</p>
<p>​              this.kind = kind;</p>
<p>​       }</p>
<p>​       public ClassTypeCapture21(Class<?> kind, Map<string,class<?>&gt; map) {</string,class<?></p>
<p>​              this.kind = kind;</p>
<p>​              this.map = map;</p>
<p>​       }</p>
<p>​       public boolean f(Object arg) {</p>
<p>​              return kind.isInstance(arg);</p>
<p>​       }</p>
<p>​       public void addType(String typename, Class&lt;?&gt; kind) {</p>
<p>​              map.put(typename, kind);</p>
<p>​       }</p>
<p>​       public Object createNew(String typename) </p>
<p>​              throws IllegalAccessException, InstantiationException {</p>
<p>​              if(map.containsKey(typename))</p>
<p>​                     return map.get(typename).newInstance();                </p>
<p>​              System.out.println(typename + “ class not available”);</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ClassTypeCapture21<building> ctt1 = new ClassTypeCapture21<building>(Building.class);</building></building></p>
<p>​              println(ctt1.f(new Building()));</p>
<p>​              println(ctt1.f(new House()));</p>
<p>​              ClassTypeCapture21<house> ctt2 = new ClassTypeCapture21<house>(House.class);</house></house></p>
<p>​              println(ctt2.f(new Building()));</p>
<p>​              println(ctt2.f(new House()));</p>
<p>​              ClassTypeCapture21<building> ct = </building></p>
<p>​              new ClassTypeCapture21<building>(Building.class, new HashMap&lt;String, Class&lt;?&gt;&gt;());</building></p>
<p>​              ct.addType(“House”, House.class);</p>
<p>​              ct.addType(“Building”, Building.class);</p>
<p>​              println(“ct.map = “ + ct.map);</p>
<p>​              try {</p>
<p>​                     Building b = (Building)ct.createNew(“Building”);</p>
<p>​                     House h = (House)ct.createNew(“House”);</p>
<p>​                     print(“b.getClass().getName(): “);</p>
<p>​                     println(b.getClass().getName());</p>
<p>​                     print(“h.getClass().getName(): “);</p>
<p>​                     println(h.getClass().getName());</p>
<p>​                     print(“House h is instance House: “);</p>
<p>​                     println(h instanceof House);</p>
<p>​                     print(“House h is instance of Building: “);</p>
<p>​                     println(h instanceof Building);</p>
<p>​                     print(“Building b is instance of House: “);</p>
<p>​                     println(b instanceof House);</p>
<p>​                     ct.createNew(“String”);             } catch(IllegalAccessException e) {</p>
<p>​                     println(“IllegalAccessException in main”);</p>
<p>​              } catch(InstantiationException e) {</p>
<p>​                     println(“InstantiationException in main”);</p>
<p>​              }             </p>
<p>​       }</p>
<p>}</p>
<p>class Building {}</p>
<p>class House extends Building {</p>
<p>​       private String location;</p>
<p>​       private Integer area;</p>
<p>​       public House() { location = null; }</p>
<p>​       public House(Integer area) { this.area = area; }</p>
<p>​       public House(String location) {</p>
<p>​              this.location = location;</p>
<p>​       }</p>
<p>​       public House(String location, Integer area) {</p>
<p>​              this.location = location;</p>
<p>​              this.area = area;</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              return “House” + ((location == null) ? “” :  “ in “ + location) +</p>
<p>​                     ((area != null) ? (“, “+ area + “ sqft”) : “”);</p>
<p>​       }</p>
<p>}</p>
<p>public class ClassTypeCreator22<t> {</t></p>
<p>​       Class&lt;?&gt; kind;</p>
<p>​       public ClassTypeCreator22(Class&lt;?&gt; kind) {</p>
<p>​              this.kind = kind;</p>
<p>​       }</p>
<p>​       public Object createNew(String typename) </p>
<p>​              throws   IllegalAccessException, </p>
<p>​                     InstantiationException, </p>
<p>​                     ClassNotFoundException {</p>
<p>​              return Class.forName(typename).newInstance();</p>
<p>​       }      </p>
<p>​             public Object createNew(String typename, Object… args) </p>
<p>​              throws   IllegalAccessException, </p>
<p>​                     InstantiationException, </p>
<p>​                     ClassNotFoundException,</p>
<p>​                     NoSuchMethodException,</p>
<p>​                     InvocationTargetException {</p>
<p>​              switch(args.length) {</p>
<p>​              case 1 : return Class.forName(typename).getConstructor(args[0].getClass()).newInstance(args[0]);</p>
<p>​              case 2 : return Class.forName(typename).getConstructor(args[0].getClass(), args[1].getClass()).</p>
<p>​                     newInstance(args[0], args[1]);</p>
<p>​              }</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ClassTypeCreator22<building> ctcb = new ClassTypeCreator22<building>(Building.class);</building></building></p>
<p>​              ClassTypeCreator22<house> ctch = new ClassTypeCreator22<house>(House.class);</house></house></p>
<p>​              try {</p>
<p>​                     Building b = (Building)ctcb.createNew(“Building”);</p>
<p>​                                         println(“House constructors:”);</p>
<p>​                     Constructor[] ctors = House.class.getConstructors();</p>
<p>​                     for(Constructor ctor : ctors) println(ctor);</p>
<p>​                                         House h = (House)ctch.createNew(“House”, “Hawaii”);</p>
<p>​                     House h2 = (House)ctch.createNew(“House”, 3000);</p>
<p>​                     House h3 = (House)ctch.createNew(“House”, “Manila”, 5000);</p>
<p>​                     println(“Constructed House objects:”);</p>
<p>​                     println(h);</p>
<p>​                     println(h2);</p>
<p>​                     println(h3);</p>
<p>​              } catch(IllegalAccessException e) {</p>
<p>​                     println(“IllegalAccessException in main”);</p>
<p>​              } catch(InstantiationException e) {</p>
<p>​                     println(“InstantiationException in main”);</p>
<p>​              } catch(ClassNotFoundException e) {</p>
<p>​                     println(“ClassNotFoundException in main”);</p>
<p>​              } catch(NoSuchMethodException e) {</p>
<p>​                     println(“NoSuchMethodException in main”);</p>
<p>​              } catch(InvocationTargetException e) {</p>
<p>​                     println(“InvocationTargetException in main”);</p>
<p>​              }             </p>
<p>​       }</p>
<p>}</p>
<p> interface FactoryI<t> {</t></p>
<p>​       T create(Integer i);</p>
<p>}</p>
<p>class Foo2<t> {</t></p>
<p>​       private T x;</p>
<p>​       public void get() { System.out.println(x); }</p>
<p>​       public &lt;F extends FactoryI<t>&gt; Foo2(F factory, Integer i) {</t></p>
<p>​              x = factory.create(i);</p>
<p>​       }</p>
<p>}</p>
<p>class IntegerFactory implements FactoryI<integer> {</integer></p>
<p>​       public Integer create(Integer i) {</p>
<p>​              return new Integer(i);</p>
<p>​       }</p>
<p>}</p>
<p>class Widget {</p>
<p>​       int i;</p>
<p>​       public static class Factory implements FactoryI<widget> {</widget></p>
<p>​              public Widget create(Integer i) {</p>
<p>​                     Widget w = new Widget();</p>
<p>​                     w.i = i;</p>
<p>​                     return w;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              return “Widget “ + i;     </p>
<p>​       }</p>
<p>}</p>
<p>public class FactoryConstraint23 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Foo2 f1 = new Foo2<integer>(new IntegerFactory(), 1);</integer></p>
<p>​              Foo2 f2 = new Foo2<widget>(new Widget.Factory(), 2);</widget></p>
<p>​              f1.get();</p>
<p>​              f2.get();</p>
<p>​              }</p>
<p>}</p>
<p>interface Factory<t> {</t></p>
<p>​       T create();</p>
<p>}</p>
<p>class Building {}</p>
<p>class House extends Building {}</p>
<p>class BuildingFactory implements Factory<building> {</building></p>
<p>​       public Building create() {</p>
<p>​              return new Building();</p>
<p>​       }</p>
<p>}</p>
<p>class HouseFactory implements Factory<house> {</house></p>
<p>​       public House create() {</p>
<p>​              return new House();</p>
<p>​       }</p>
<p>}</p>
<p>public class ClassTypeCapture24<t> {</t></p>
<p>​       Class&lt;?&gt; kind;</p>
<p>​       public ClassTypeCapture24(Class&lt;?&gt; kind) {</p>
<p>​              this.kind = kind;</p>
<p>​       }</p>
<p>​       Map&lt;String,Factory&gt; map;  </p>
<p>​       public ClassTypeCapture24(Class&lt;?&gt; kind, Map&lt;String,Factory&gt; map) {</p>
<p>​              this.kind = kind;</p>
<p>​              this.map = map;</p>
<p>​       }</p>
<p>​       public boolean f(Object arg) {</p>
<p>​              return kind.isInstance(arg);</p>
<p>​       }</p>
<p>​       public void addType(String typename, Factory factory) {</p>
<p>​              map.put(typename, factory);</p>
<p>​       }</p>
<p>​       public Object createNew(String typename) </p>
<p>​              throws IllegalAccessException, InstantiationException {</p>
<p>​              if(map.containsKey(typename))</p>
<p>​                     return map.get(typename).create();                  </p>
<p>​              System.out.println(typename + “ class not available”);</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ClassTypeCapture24<building> ctt1 = </building></p>
<p>​                     new ClassTypeCapture24<building>(Building.class);</building></p>
<p>​              println(ctt1.f(new Building()));</p>
<p>​              println(ctt1.f(new House()));</p>
<p>​              ClassTypeCapture24<house> ctt2 = </house></p>
<p>​                     new ClassTypeCapture24<house>(House.class);</house></p>
<p>​              println(ctt2.f(new Building()));</p>
<p>​              println(ctt2.f(new House()));</p>
<p>​              ClassTypeCapture24<building> ct = </building></p>
<p>​              new ClassTypeCapture24<building>(</building></p>
<p>​                     Building.class, new HashMap&lt;String,Factory&gt;());</p>
<p>​              ct.addType(“House”, new HouseFactory());</p>
<p>​              ct.addType(“Building”, new BuildingFactory());</p>
<p>​              println(“ct.map = “ + ct.map);</p>
<p>​              try {</p>
<p>​                     Building b = (Building)ct.createNew(“Building”);</p>
<p>​                     House h = (House)ct.createNew(“House”);</p>
<p>​                     print(“b.getClass().getName(): “);</p>
<p>​                     println(b.getClass().getName());</p>
<p>​                     print(“h.getClass().getName(): “);</p>
<p>​                     println(h.getClass().getName());</p>
<p>​                     print(“House h is instance House: “);</p>
<p>​                     println(h instanceof House);</p>
<p>​                     print(“House h is instance of Building: “);</p>
<p>​                     println(h instanceof Building);</p>
<p>​                     print(“Building b is instance of House: “);</p>
<p>​                     println(b instanceof House);</p>
<p>​                     ct.createNew(“String”);             } catch(IllegalAccessException e) {</p>
<p>​                     println(“IllegalAccessException in main”);</p>
<p>​              } catch(InstantiationException e) {</p>
<p>​                     println(“InstantiationException in main”);</p>
<p>​              }             </p>
<p>​       }</p>
<p>}</p>
<p>interface A {}</p>
<p>interface B {} </p>
<p>class C implements A, B {</p>
<p>​       public String toString() { return “C”; }</p>
<p>}</p>
<p>public class Ex25 {</p>
<p>​       <t extends a> void a(T t) { System.out.println(“a(“ + t + “)”); }</t></p>
<p>​       <t extends b> void b(T t) { System.out.println(“b(“ + t + “)”); }</t></p>
<p>​       public static void main(String[] args) {</p>
<p>​              C c = new C();</p>
<p>​              Ex25 ex = new Ex25();</p>
<p>​              ex.a(c);</p>
<p>​              ex.b(c);</p>
<p>​       }</p>
<p>}</p>
<p> public class Ex26 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Number[] numbers = new Integer[3];</p>
<p>​              numbers[0] = new Integer(0);</p>
<p>​              numbers[1] = new Integer(1);</p>
<p>​              numbers[2] = new Integer(2);</p>
<p>​                                        try {                     numbers[1] = new Double(3.4);</p>
<p>​              } catch(Exception e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }</p>
<p>​              for(Number n : numbers)</p>
<p>​                     System.out.println(n);</p>
<p>​                                                                               for(Number n : numbers)</p>
<p>​                     System.out.println(n.getClass().getSimpleName());    </p>
<p>​       }      </p>
<p>}</p>
<p>​    import java.util.*;</p>
<p>public class Ex27 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​                                        List&lt;? extends Number&gt; nlist = new ArrayList<integer>();</integer></p>
<p>​                                        nlist.add(null);             Number x = nlist.get(0);            System.out.println(nlist);</p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex28 {</p>
<p>​       class Generic1<t> {</t></p>
<p>​              T t;</p>
<p>​              void take(T t) { this.t = t; }</p>
<p>​       }</p>
<p>​             class Generic2<t> {</t></p>
<p>​              T t;</p>
<p>​              T give() { return t; }</p>
<p>​       }</p>
<p>​       <t> void contra(Generic1&lt;? super T&gt; g1t, T t) {</t></p>
<p>​              g1t.take(t);</p>
<p>​       }</p>
<p>​       <t> T co(Generic2&lt;? extends T&gt; g2t) {</t></p>
<p>​              return g2t.give();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex28 e28 = new Ex28();</p>
<p>​              e28.contra(e28.new Generic1<pet>(), new Cat(“kitty”));</pet></p>
<p>​              e28.co(e28.new Generic2<pet>());             </pet></p>
<p>​       }</p>
<p>}</p>
<p>public class Ex29 {</p>
<p>​       static void f1(Holder&lt;List&lt;?&gt;&gt; holder) {</p>
<p>​              println(“Calling methods for the Holder: “);</p>
<p>​              println(“holder: “ + holder);</p>
<p>​              println(“holder.get(): “ + holder.get());</p>
<p>​              println(“Calling holder.set(Arrays.asList(1,2,3)”);</p>
<p>​              holder.set(Arrays.asList(1,2,3));</p>
<p>​              println(“holder.get(): “ + holder.get());</p>
<p>​              int[] ia = {1,2,3};</p>
<p>​              println(“int[] ia = {1,2,3}”);</p>
<p>​              println(“holder.equals(ia): “ + holder.equals(ia));</p>
<p>​              List iaList = Arrays.asList(ia);</p>
<p>​              println(“List iaList = Arrays.asList(ia)”);</p>
<p>​              println(“holder.equals(iaList): “ + holder.equals(iaList));</p>
<p>​              List<integer> l = new ArrayList<integer>();</integer></integer></p>
<p>​              for(int i = 1; i &lt; 4; i++) l.add(i);</p>
<p>​              println(“l = List<integer>() and add 1,2,3”);</integer></p>
<p>​              println(“holder.equals(l): “ + holder.equals(l));</p>
<p>​              println();</p>
<p>​                                   </p>
<p>​              println(“Calling methods for the List: “);</p>
<p>​              println(“holder.get(): “ + holder.get());</p>
<p>​              println(“holder.get().getClass(): “ + holder.get().getClass());</p>
<p>​                                                     List&lt;?&gt; list = holder.get();</p>
<p>​              println(“list: “ + list); </p>
<p>​                           List list1 = holder.get();                                       println(“list1.getClass(): “ + list1.getClass());</p>
<p>​              println(“list.equals(list1): “ + list.equals(list1));</p>
<p>​                           println(“list.contains(1): “ + list.contains(1));              </p>
<p>​              Collection<integer> c = new HashSet<integer>();</integer></integer></p>
<p>​              for(int i = 1; i &lt; 4; i++) c.add(i);</p>
<p>​              println(“list.containsAll(c): “ + list.containsAll(c));       </p>
<p>​              println(“list.equals(c): “ + list.equals(c));</p>
<p>​              println(“list = “ + list);</p>
<p>​              println(“c = “ + c);</p>
<p>​              println(“c.getClass(): “ + c.getClass());              println(“list.get(0) = “ + list.get(0));</p>
<p>​              println(“list.hashCode() = “ + list.hashCode());</p>
<p>​              println(“list.indexOf(2) = “ + list.indexOf(2));      </p>
<p>​              ListIterator li = list.listIterator();</p>
<p>​              println(“After ListIterator li = list.listIterator():”);</p>
<p>​              println(“li.next() = “ + li.next());</p>
<p>​                                                                                            println(“list.size() = “ + list.size());</p>
<p>​              println(“list.subList(1,2) = “ + list.subList(1,2));</p>
<p>​              Object[] oa = list.toArray();</p>
<p>​              println(“After Object[] oa = list.toArray():”);</p>
<p>​              print(“oa = “);</p>
<p>​              for(Object o : oa) print(o + “ “);</p>
<p>​              println(); </p>
<p>​                                        Number[] na = list.toArray(new Number[3]);</p>
<p>​              println(“After Number[] na = list.toArray(new Number[3]):”);</p>
<p>​              print(“na = “);</p>
<p>​              for(Number n : na) print(n + “ “);</p>
<p>​              println();</p>
<p>​       }</p>
<p>​       static void f2(List&lt;Holder&lt;?&gt;&gt; list) {</p>
<p>​              println(“Calling methods for the List: “);</p>
<p>​              println(“list = “ + list);</p>
<p>​              println(“Adding Integer, String, Double”);</p>
<p>​              list.add(new Holder<integer>(1));</integer></p>
<p>​              list.add(new Holder<string>(“two”));</string></p>
<p>​              list.add(new Holder<double>(3.0));</double></p>
<p>​              println(“list = “ + list);</p>
<p>​              println(“Elements of list: “);</p>
<p>​              for(Holder h : list) </p>
<p>​                     println(“h.get() = “ + h.get());</p>
<p>​              println(“Adding Float”);</p>
<p>​              list.add(3, new Holder<float>(4.0f));</float></p>
<p>​              println(“list = “ + list);</p>
<p>​              println(“Elements of list: “);</p>
<p>​              for(Holder h : list) </p>
<p>​                     println(“h.get() = “ + h.get());</p>
<p>​              println(“list.clear()”);</p>
<p>​              list.clear();</p>
<p>​              println(“list = “ + list);</p>
<p>​              Collection&lt;Holder&lt;?&gt;&gt; c = </p>
<p>​                     new ArrayList&lt;Holder&lt;?&gt;&gt;();</p>
<p>​              c.add(new Holder<string>(“one”));</string></p>
<p>​              c.add(new Holder<float>(2.0f));</float></p>
<p>​              c.add(new Holder<double>(3.0));</double></p>
<p>​              list.addAll(c);</p>
<p>​              println(“Adding String, Float, Double”);</p>
<p>​              println(“list = “ + list);</p>
<p>​              println(“Elements of list: “);</p>
<p>​              for(Holder h : list) </p>
<p>​                     println(“h.get() = “ + h.get().getClass().getSimpleName() </p>
<p>​                            + “ “ + h.get());</p>
<p>​              list.add(3, new Holder<string>(“four”));</string></p>
<p>​              println(“Elements of list: “);</p>
<p>​              for(Holder h : list) </p>
<p>​                     println(“h.get() = “ + h.get().getClass().getSimpleName() </p>
<p>​                            + “ “ + h.get());</p>
<p>​              Object listClone = ((ArrayList)list).clone();</p>
<p>​              println(“((ArrayList)list).clone() = “ +  listClone);</p>
<p>​              println(“((ArrayList)list).clone().getClass() = “ +</p>
<p>​                     ((ArrayList)list).clone().getClass());</p>
<p>​                                        println(“Replacing element with h4, new Holder<integer>(4)”);</integer></p>
<p>​              Holder<integer> h4 = new Holder<integer>(4);</integer></integer></p>
<p>​              list.set(3, h4);</p>
<p>​              println(“Elements of list Holders: “);</p>
<p>​              for(Holder h : list) </p>
<p>​                     println(h.get().getClass().getSimpleName() </p>
<p>​                            + “ “ + h.get());</p>
<p>​              println(“list.contains(list.set(3, h4): “ + </p>
<p>​                            list.contains(list.set(3, h4)));</p>
<p>​              println(“list.contains(4): “ + list.contains(4));</p>
<p>​              println(“list.contains(h4): “ + list.contains(h4));</p>
<p>​              println(“Adding null member to list”);        </p>
<p>​              list.add(null);</p>
<p>​              println(“list.contains(null): “ + list.contains(null));</p>
<p>​              println(“list.get(0).get(): “ + list.get(0).get());</p>
<p>​              println(“list.indexOf(h4) = “ + list.indexOf(h4));</p>
<p>​              println(“list.indexOf(null) = “ + list.indexOf(null));</p>
<p>​              println(“list.isEmpty(): “ + list.isEmpty());</p>
<p>​              println(“list.lastIndexOf(null) = “ + list.lastIndexOf(null));  </p>
<p>​              println(“Removing index 0”);</p>
<p>​              list.remove(0);</p>
<p>​              println(“Elements of list Holders: “);</p>
<p>​              for(Holder h : list) {</p>
<p>​                     if(h == null) println(“null”);</p>
<p>​                     else</p>
<p>​                     println(h.get().getClass().getSimpleName() </p>
<p>​                            + “ “ + h.get());      </p>
<p>​                     }</p>
<p>​              println(“Removing null”);</p>
<p>​              println(“Elements of list Holders: “);</p>
<p>​              for(Holder h : list) {</p>
<p>​                     if(h == null) println(“null”);</p>
<p>​                     else</p>
<p>​                     println(h.get().getClass().getSimpleName() </p>
<p>​                            + “ “ + h.get());      </p>
<p>​                     }</p>
<p>​                                        println(“list.size() = “ + list.size());</p>
<p>​              Object[] oa = list.toArray();</p>
<p>​              print(“list.toArray() = “);</p>
<p>​              for(int i = 0; i &lt; oa.length; i++) </p>
<p>​                     print(oa[i] + “ “);</p>
<p>​              println();</p>
<p>​              Holder[] ha = ((ArrayList&lt;Holder&lt;?&gt;&gt;)list).toArray(new Holder[4]);</p>
<p>​              println(“(ArrayList&lt;Holder&lt;?&gt;&gt;list).toArray(new Holder[4]) = “);</p>
<p>​              for(int i = 0; i &lt; ha.length; i++)</p>
<p>​                     print(ha[i] + “ “);</p>
<p>​              println();</p>
<p>​              println(“Holder[4] Holders are holding: “);</p>
<p>​              for(Holder h : ha) {</p>
<p>​                     if(h == null) println(“null”);</p>
<p>​                     else println(h.get());</p>
<p>​              }</p>
<p>​              println();         </p>
<p>​       </p>
<p>​              println(“Calling methods for the Holder: “);</p>
<p>​              println(“list = “ + list);</p>
<p>​              print(“Three Holders (one null) in list:”);</p>
<p>​              for(int i = 0; i &lt; list.size(); i++) {</p>
<p>​                     if(list.get(i) == null) println(“null”); </p>
<p>​                     else</p>
<p>​                     println(list.get(i).getClass().getSimpleName());</p>
<p>​              }</p>
<p>​              list.remove(3);</p>
<p>​              println(“Holders are holding:”);</p>
<p>​              for(Holder h : list) println(h.get());</p>
<p>​              Holder&lt;?&gt; h1 = list.get(0);</p>
<p>​              Holder&lt;?&gt; h2 = list.get(1);</p>
<p>​              Holder&lt;?&gt; h3 = list.get(2);</p>
<p>​              println(list.get(0).getClass() + “: “ </p>
<p>​                     + list.get(0).get().getClass().getSimpleName() + “, “ </p>
<p>​                     + list.get(0).get());</p>
<p>​              println(list.get(1).getClass() + “: “ </p>
<p>​                     + list.get(1).get().getClass().getSimpleName() + “, “ </p>
<p>​                     + list.get(1).get());</p>
<p>​              println(list.get(2).getClass() + “: “ </p>
<p>​                     + list.get(2).get().getClass().getSimpleName() + “, “</p>
<p>​                     + list.get(2).get());</p>
<p>​                                                     </p>
<p>​       }      </p>
<p>​       public static void main(String[] args) {</p>
<p>​              println(“new Holder&lt;List&lt;?&gt;&gt; holder”);</p>
<p>​              f1(new Holder&lt;List&lt;?&gt;&gt;());</p>
<p>​              println();</p>
<p>​              println(“List&lt;Holder<?>> list = new ArrayList<holder<?>&gt;();”);</holder<?></p>
<p>​              List&lt;Holder<?>> list = new ArrayList<holder<?>&gt;();</holder<?></p>
<p>​              f2(list);</p>
<p>​       }</p>
<p>}</p>
<p>public class Holders30 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Holder<character> charHolder = new Holder<character>();</character></character></p>
<p>​              Holder<byte> byteHolder = new Holder<byte>();</byte></byte></p>
<p>​              Holder<short> shortHolder = new Holder<short>();</short></short></p>
<p>​              Holder<integer> intHolder = new Holder<integer>();</integer></integer></p>
<p>​              Holder<long> longHolder = new Holder<long>();</long></long></p>
<p>​              Holder<float> floatHolder = new Holder<float>();</float></float></p>
<p>​              Holder<double> doubleHolder = new Holder<double>();</double></double></p>
<p>​                           charHolder.set(‘a’);</p>
<p>​              print(charHolder.get() + “, “);</p>
<p>​              println(charHolder.get().getClass());</p>
<p>​              char c = charHolder.get();</p>
<p>​              println(“char c = charHolder.get() = “ + c);</p>
<p>​              byte b = 1;</p>
<p>​              byteHolder.set(b);</p>
<p>​              print(byteHolder.get() + “, “);</p>
<p>​              println(byteHolder.get().getClass());</p>
<p>​              byte bb = byteHolder.get();</p>
<p>​              println(“byte bb = byteHolder.get() = “ + bb);                </p>
<p>​              short s = 1;</p>
<p>​              shortHolder.set(s);</p>
<p>​              print(shortHolder.get() + “, “);</p>
<p>​              println(shortHolder.get().getClass());</p>
<p>​              short ss = shortHolder.get();</p>
<p>​              println(“short ss = shortHolder.get() = “ + ss);</p>
<p>​              intHolder.set(1);</p>
<p>​              print(intHolder.get() + “. “);</p>
<p>​              println(intHolder.get().getClass());</p>
<p>​              int i = intHolder.get();</p>
<p>​              println(“int i = intHolder.get() = “ + i);</p>
<p>​              long l = 2;</p>
<p>​              longHolder.set(l);</p>
<p>​              print(longHolder.get() + “, “);</p>
<p>​              println(longHolder.get().getClass());</p>
<p>​              long ll = longHolder.get();</p>
<p>​              println(“long ll = longHolder.get() = “ + ll);</p>
<p>​              float f = 1f;</p>
<p>​              floatHolder.set(f);</p>
<p>​              print(floatHolder.get() + “, “);</p>
<p>​              println(floatHolder.get().getClass());</p>
<p>​              float ff = floatHolder.get();</p>
<p>​              println(“float ff = floatHolder.get() = “ + ff);</p>
<p>​              double d = 1.1;</p>
<p>​              doubleHolder.set(d);</p>
<p>​              print(doubleHolder.get() + “, “);</p>
<p>​              println(doubleHolder.get().getClass());</p>
<p>​              double dd = doubleHolder.get();</p>
<p>​              println(“double dd = doubleHolder.get() = “ + dd);        </p>
<p>​       }             </p>
<p>​              </p>
<p>}</p>
<p>  interface Payable { float getPay(); }</p>
<p>class Employee implements Payable {</p>
<p>​       private float weeklyPay;</p>
<p>​       public float getPay() {</p>
<p>​              return weeklyPay;</p>
<p>​       }             </p>
<p>} </p>
<p>class Hourly extends Employee {</p>
<p>​       public String name;</p>
<p>​       protected float hourlyPay;</p>
<p>​       public int hoursWorked;</p>
<p>​       Hourly(String s, float pay, int hours) {</p>
<p>​              name = s;</p>
<p>​              hourlyPay = pay;</p>
<p>​              hoursWorked = hours;</p>
<p>​       }</p>
<p>​       public float getPay() {</p>
<p>​              System.out.println(“Pay “ + name + </p>
<p>​                     “ $” + hourlyPay * hoursWorked);</p>
<p>​              return hourlyPay * hoursWorked;      </p>
<p>​       }</p>
<p>}</p>
<p>public class MultipleInterfaceVariants31 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Hourly h = new Hourly(“Joe”, 50.00f, 40);</p>
<p>​              h.getPay();</p>
<p>​       }</p>
<p>}</p>
<p>class FixedSizeStack<t> {</t></p>
<p>​       private int index = 0;</p>
<p>​       private Object[] storage;</p>
<p>​       public FixedSizeStack(int size) {</p>
<p>​              storage = new Object[size];</p>
<p>​       }</p>
<p>​       int getIndex() { return index; } </p>
<p>​       public void push(T item) { storage[index++] = item; }</p>
<p>​       @SuppressWarnings(“unchecked”)</p>
<p>​       public T pop() { return (T)storage[–index]; }</p>
<p>}</p>
<p>public class GenericCast32 {</p>
<p>​       public static final int SIZE = 10;</p>
<p>​       public static void main(String[] args) {</p>
<p>​              FixedSizeStack<string> strings = </string></p>
<p>​                     new FixedSizeStack<string>(SIZE);</string></p>
<p>​              for(String s : “A B C D E F G H I J”.split(“ “))</p>
<p>​                     strings.push(s);</p>
<p>​                                        if(strings.getIndex() &lt; SIZE) strings.push(“oops”);</p>
<p>​              for(int i = 0; i &lt; SIZE; i++) {</p>
<p>​                     String s = strings.pop();</p>
<p>​                     System.out.print(s + “ “);</p>
<p>​              }                                  </p>
<p>​       }             </p>
<p>​              </p>
<p>}</p>
<p>class VariableSizeStack<t> { </t></p>
<p>​       private ArrayList<t> storage = new ArrayList<t>();</t></t></p>
<p>​           public int count() {</p>
<p>​              return storage.size();</p>
<p>​           } </p>
<p>​           public void push(T item) { </p>
<p>​              storage.add(item); </p>
<p>​           }</p>
<p>​           public T pop() { </p>
<p>​              return storage.remove(storage.size() - 1);</p>
<p>​           }</p>
<p>}</p>
<p>public class GenericCast33 {</p>
<p>​      public static void main(String[] args) {</p>
<p>​               VariableSizeStack<string> strings =</string></p>
<p>​                          new VariableSizeStack<string>();</string></p>
<p>​               for(String s : “A B C D E F G H I J”.split(“ “))</p>
<p>​                          strings.push(s);</p>
<p>​              int currentCount = strings.count();</p>
<p>​              for(int i = 0; i &lt; currentCount; i++) {</p>
<p>​                   String s = strings.pop();</p>
<p>​                   System.out.print(s + “ “);</p>
<p>​              }                }      }</p>
<p>abstract class SelfBoundedType&lt;T extends SelfBoundedType<t>&gt; {</t></p>
<p>​       abstract T f(T arg);</p>
<p>​       T g(T arg) { </p>
<p>​              System.out.println(“g(T arg)”);</p>
<p>​              return f(arg); </p>
<p>​       }      </p>
<p>}</p>
<p>class D extends SelfBoundedType<d> {</d></p>
<p>​       D f(D arg) { </p>
<p>​              System.out.println(“f(D arg)”);</p>
<p>​              return arg; </p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex34 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              D d = new D();</p>
<p>​              d.f(d).g(d);</p>
<p>​       }</p>
<p>}</p>
<p>public class CheckedList35 {</p>
<p>​       @SuppressWarnings(“unchecked”)</p>
<p>​       static void oldStyleMethod(List probablyMocha) {</p>
<p>​              probablyMocha.add(new Breve());</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<mocha> mocha1 = new ArrayList<mocha>();</mocha></mocha></p>
<p>​              oldStyleMethod(mocha1);                List<mocha> mocha2 = Collections.checkedList(</mocha></p>
<p>​                     new ArrayList<mocha>(), Mocha.class);</mocha></p>
<p>​              try {</p>
<p>​                     oldStyleMethod(mocha2);                } catch(Exception e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }</p>
<p>​                           List<coffee> coffee = Collections.checkedList(</coffee></p>
<p>​                     new ArrayList<coffee>(), Coffee.class);</coffee></p>
<p>​              coffee.add(new Mocha());</p>
<p>​              coffee.add(new Breve());             </p>
<p>​       }</p>
<p>}      </p>
<p>​    import java.util.*;</p>
<p>interface Processor&lt;T,E extends Exception, E2 extends Exception&gt; {</p>
<p>​       void process(List<t> resultCollector) throws E,E2;</t></p>
<p>}</p>
<p>class ProcessRunner&lt;T,E extends Exception, E2 extends Exception&gt; </p>
<p>extends ArrayList&lt;Processor&lt;T,E,E2&gt;&gt; {</p>
<p>​       List<t> processAll() throws E,E2 {</t></p>
<p>​              List<t> resultCollector = new ArrayList<t>();</t></t></p>
<p>​              for(Processor&lt;T,E,E2&gt; processor : this)</p>
<p>​                     processor.process(resultCollector);</p>
<p>​              return resultCollector;</p>
<p>​       }</p>
<p>}</p>
<p>class Failure1 extends Exception {}</p>
<p>class Failure3 extends Exception {}</p>
<p>class Processor1 implements Processor&lt;String,Failure1,Failure3&gt; {</p>
<p>​       static int count = 3;</p>
<p>​       public void</p>
<p>​       process(List<string> resultCollector) throws Failure1, Failure3 {</string></p>
<p>​              if(count– &gt; 1)</p>
<p>​                     resultCollector.add(“Hep!”);</p>
<p>​              else</p>
<p>​                     resultCollector.add(“Ho!”);</p>
<p>​              if(count &lt; 0)</p>
<p>​                     throw new Failure1();</p>
<p>​              if(count &lt; -1)</p>
<p>​                     throw new Failure3();</p>
<p>​       }</p>
<p>}</p>
<p>class Processor1b implements Processor&lt;String,Failure1,Failure3&gt; {</p>
<p>​       static int count = 3;</p>
<p>​       public void</p>
<p>​       process(List<string> resultCollector) throws Failure1, Failure3 {</string></p>
<p>​              if(count– &gt; 1)</p>
<p>​                     resultCollector.add(“Hep!”);</p>
<p>​              else</p>
<p>​                     resultCollector.add(“Ho!”);</p>
<p>​              if(count &lt; 0)</p>
<p>​                     throw new Failure1();</p>
<p>​              if(count == 1)</p>
<p>​                     throw new Failure3();</p>
<p>​       }</p>
<p>}</p>
<p>class Failure2 extends Exception {}</p>
<p>class Processor2 implements Processor&lt;Integer,Failure2,Failure3&gt; {</p>
<p>​       static int count = 2;</p>
<p>​       public void</p>
<p>​       process(List<integer> resultCollector) throws Failure2, Failure3 {</integer></p>
<p>​              if(count– == 0)</p>
<p>​                     resultCollector.add(47);</p>
<p>​              else {</p>
<p>​                     resultCollector.add(11);</p>
<p>​              }</p>
<p>​              if(count &lt; 0)</p>
<p>​                     throw new Failure2();</p>
<p>​              if(count &lt; -1)</p>
<p>​                     throw new Failure3();</p>
<p>​       }</p>
<p>}</p>
<p>class Processor2b implements Processor&lt;Integer,Failure2,Failure3&gt; {</p>
<p>​       static int count = 2;</p>
<p>​       public void</p>
<p>​       process(List<integer> resultCollector) throws Failure2, Failure3 {</integer></p>
<p>​              if(count– == 0)</p>
<p>​                     resultCollector.add(47);</p>
<p>​              else {</p>
<p>​                     resultCollector.add(11);</p>
<p>​              }</p>
<p>​              if(count &lt; 0)</p>
<p>​                     throw new Failure2();</p>
<p>​              if(count == 1)</p>
<p>​                     throw new Failure3();</p>
<p>​       }</p>
<p>}</p>
<p>public class ThrowGenericException36 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ProcessRunner&lt;String,Failure1,Failure3&gt; runner =</p>
<p>​                     new ProcessRunner&lt;String,Failure1,Failure3&gt;();</p>
<p>​              for(int i = 0; i &lt; 3; i++)</p>
<p>​                     runner.add(new Processor1());</p>
<p>​              try {</p>
<p>​                     System.out.println(runner.processAll());</p>
<p>​              } catch(Failure1 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              } catch(Failure3 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }</p>
<p>​              ProcessRunner&lt;String,Failure1,Failure3&gt; runnerb =</p>
<p>​                     new ProcessRunner&lt;String,Failure1,Failure3&gt;();</p>
<p>​              for(int i = 0; i &lt; 3; i++)</p>
<p>​                     runnerb.add(new Processor1b());</p>
<p>​              try {</p>
<p>​                     System.out.println(runnerb.processAll());</p>
<p>​              } catch(Failure1 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              } catch(Failure3 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }</p>
<p>​              ProcessRunner&lt;Integer,Failure2,Failure3&gt; runner2 =</p>
<p>​                     new ProcessRunner&lt;Integer,Failure2,Failure3&gt;();</p>
<p>​              for(int i = 0; i &lt; 3; i++)</p>
<p>​                     runner2.add(new Processor2());</p>
<p>​              try {</p>
<p>​                     System.out.println(runner2.processAll());</p>
<p>​              } catch(Failure2 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              } catch(Failure3 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }</p>
<p>​              ProcessRunner&lt;Integer,Failure2,Failure3&gt; runner2b =</p>
<p>​                     new ProcessRunner&lt;Integer,Failure2,Failure3&gt;();</p>
<p>​              for(int i = 0; i &lt; 3; i++)</p>
<p>​                     runner2b.add(new Processor2b());</p>
<p>​              try {</p>
<p>​                     System.out.println(runner2b.processAll());</p>
<p>​              } catch(Failure2 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              } catch(Failure3 e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       </p>
<p>}      </p>
<p>class TimeStampedImp implements TimeStamped {</p>
<p>​       private final long timeStamp;</p>
<p>​       public TimeStampedImp() {</p>
<p>​              timeStamp = new Date().getTime();</p>
<p>​       }</p>
<p>​       public long getStamp() { return timeStamp; }</p>
<p>}</p>
<p>interface SerialNumbered { long getSerialNumber(); }</p>
<p>class SerialNumberedImp implements SerialNumbered {</p>
<p>​       private static long counter = 1;</p>
<p>​       private final long serialNumber = counter++;</p>
<p>​       public long getSerialNumber() { return serialNumber; }</p>
<p>}</p>
<p>interface Color { String getColor();  }</p>
<p>class Colored implements Color {</p>
<p>​       private String color = “blue”;</p>
<p>​       public void setColor(String col) { color = col; }</p>
<p>​       public String getColor() { return color; }</p>
<p>}</p>
<p>interface Basic {</p>
<p>​       public void set(String val);</p>
<p>​       public String get();</p>
<p>}</p>
<p>class BasicImp implements Basic {</p>
<p>​       private String value;</p>
<p>​       public void set(String val) { value = val; }</p>
<p>​       public String get() { return value; }</p>
<p>}</p>
<p>class Mixin extends BasicImp </p>
<p>implements TimeStamped, SerialNumbered, Color {</p>
<p>​       private TimeStamped timeStamp = new TimeStampedImp();</p>
<p>​       private SerialNumbered serialNumber = new SerialNumberedImp();</p>
<p>​       private Colored color = new Colored();</p>
<p>​       public long getStamp() { return timeStamp.getStamp(); }</p>
<p>​       public long getSerialNumber() { </p>
<p>​              return serialNumber.getSerialNumber(); </p>
<p>​       }</p>
<p>​       public String getColor() { return color.getColor(); }</p>
<p>}</p>
<p>public class Mixins37 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Mixin mixin1 = new Mixin(), mixin2 = new Mixin();</p>
<p>​              mixin1.set(“test string 1”);</p>
<p>​              mixin2.set(“test string 2”);</p>
<p>​              System.out.println(mixin1.get() + “ “ + mixin1.getStamp() </p>
<p>​                     + “ “ + mixin1.getSerialNumber() + “ “ + </p>
<p>​                     mixin1.getColor());</p>
<p>​              System.out.println(mixin2.get() + “ “ + mixin2.getStamp() </p>
<p>​                     + “ “ + mixin2.getSerialNumber() + “ “ + </p>
<p>​                     mixin2.getColor());</p>
<p>​       }</p>
<p>}</p>
<p>class BasicCoffee {</p>
<p>​       private static long counter = 0;</p>
<p>​      private final long id = counter++;</p>
<p>​       private String value;</p>
<p>​       public void set(String val) { value = val; }</p>
<p>​       public String get() { return value; }</p>
<p>​      public String toString() {</p>
<p>​                  return getClass().getSimpleName() + “ “ + id;</p>
<p>​      }</p>
<p>}</p>
<p>class Decorator extends BasicCoffee {</p>
<p>​       protected BasicCoffee basicCoffee;</p>
<p>​       public Decorator(BasicCoffee basicCoffee) { </p>
<p>​              this.basicCoffee = basicCoffee; </p>
<p>​       }</p>
<p>​       public void set(String val) { basicCoffee.set(val); }</p>
<p>​       public String get() { return basicCoffee.get(); }</p>
<p>}</p>
<p>class SteamedMilk extends Decorator {</p>
<p>​       private final String steamedMilk = “steamedMilk”;</p>
<p>​       public SteamedMilk(BasicCoffee basicCoffee) {</p>
<p>​              super(basicCoffee);</p>
<p>​       }</p>
<p>​       public String getSteamedMilk() { return steamedMilk; }</p>
<p>}</p>
<p>class Foam extends Decorator {</p>
<p>​       private final String foam = “foam”;</p>
<p>​       public Foam(BasicCoffee basicCoffee) {</p>
<p>​              super(basicCoffee);</p>
<p>​       }</p>
<p>​       public String getFoam() { return foam; }</p>
<p>}</p>
<p>class Chocolate extends Decorator {</p>
<p>​       private final String chocolate = “chocolate”;</p>
<p>​       public Chocolate(BasicCoffee basicCoffee) {</p>
<p>​              super(basicCoffee);</p>
<p>​       }</p>
<p>​       public String getChocolate() { return chocolate; }</p>
<p>}</p>
<p>class Caramel extends Decorator {</p>
<p>​       private final String caramel = “caramel”;</p>
<p>​       public Caramel(BasicCoffee basicCoffee) {</p>
<p>​              super(basicCoffee);</p>
<p>​       }</p>
<p>​       public String getCaramel() { return caramel; }</p>
<p>}</p>
<p>class WhippedCream extends Decorator {</p>
<p>​       private final String whippedCream = “whippedCream”;</p>
<p>​       public WhippedCream(BasicCoffee basicCoffee) {</p>
<p>​              super(basicCoffee);</p>
<p>​       }</p>
<p>​       public String getWhippedCream() { return whippedCream; }</p>
<p>}</p>
<p>public class CoffeeDecoration38 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              SteamedMilk sm = new SteamedMilk(new BasicCoffee());</p>
<p>​              SteamedMilk sm2 = new SteamedMilk(</p>
<p>​                     new Foam(new BasicCoffee()));</p>
<p>​              Chocolate c = new Chocolate(new BasicCoffee());</p>
<p>​              WhippedCream wc = new WhippedCream(new Caramel(</p>
<p>​                     new Chocolate(new Foam(new SteamedMilk(</p>
<p>​                     new BasicCoffee())))));</p>
<p>​       }</p>
<p>}</p>
<p>class MixinProxy implements InvocationHandler {</p>
<p>​       Map&lt;String,Object&gt; delegatesByMethod;</p>
<p>​       public MixinProxy(TwoTuple&lt;Object,Class&lt;?&gt;&gt;… pairs) {</p>
<p>​              delegatesByMethod = new HashMap&lt;String,Object&gt;();</p>
<p>​              for(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair : pairs) {</p>
<p>​                     for(Method method : pair.second.getMethods()) {</p>
<p>​                            String methodName = method.getName();</p>
<p>​                                                                                  if(!delegatesByMethod.containsKey(methodName))</p>
<p>​                                   delegatesByMethod.put(methodName, pair.first);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</p>
<p>​              String methodName = method.getName();</p>
<p>​              Object delegate = delegatesByMethod.get(methodName);</p>
<p>​              return method.invoke(delegate, args);</p>
<p>​       }</p>
<p>​       @SuppressWarnings(“unchecked”)</p>
<p>​       public static Object newInstance(TwoTuple… pairs) {</p>
<p>​              Class[] interfaces = new Class[pairs.length];</p>
<p>​              for(int i = 0; i &lt; pairs.length; i++) {</p>
<p>​                     interfaces[i] = (Class)pairs[i].second;</p>
<p>​              }</p>
<p>​              ClassLoader cl = pairs[0].first.getClass().getClassLoader();</p>
<p>​              return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));</p>
<p>​       }</p>
<p>}</p>
<p>public class DynamicProxyMixin39 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Object mixin = MixinProxy.newInstance(tuple(new BasicImp(), Basic.class), </p>
<p>​                     tuple(new TimeStampedImp(), TimeStamped.class),</p>
<p>​                     tuple(new SerialNumberedImp(), SerialNumbered.class),</p>
<p>​                     tuple(new Colored(), Color.class));</p>
<p>​              Basic b = (Basic)mixin;</p>
<p>​              TimeStamped t = (TimeStamped)mixin;</p>
<p>​              SerialNumbered s = (SerialNumbered)mixin;</p>
<p>​              b.set(“Hello”);</p>
<p>​              Color c = (Color)mixin;</p>
<p>​              System.out.println(b.get());</p>
<p>​              System.out.println(t.getStamp());</p>
<p>​              System.out.println(s.getSerialNumber());</p>
<p>​              System.out.println(c.getColor());         </p>
<p>​       }</p>
<p>public class Apply40 {</p>
<p>​       public static &lt;T,S extends Iterable&lt;? extends T&gt;&gt; void apply(S seq, Method f, Object… args) {</p>
<p>​              try {</p>
<p>​                     for(T t : seq)</p>
<p>​                            f.invoke(t, args);</p>
<p>​              } catch(Exception e) {</p>
<p>​                                         throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class FilledList<t> extends ArrayList<t> { </t></t></p>
<p>​       public FilledList(Class&lt;? extends T&gt; type, int size) {</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; size; i++)</p>
<p>​                                                       add(type.newInstance());</p>
<p>​              } catch(Exception e) {</p>
<p>​                     throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class ApplyTest40 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​                           List<pet> pets = Pets.arrayList(10);</pet></p>
<p>​              print(“Random pets: “ + pets);</p>
<p>​                           Apply40.apply(pets, Pet.class.getMethod(“speak”));</p>
<p>​                           Apply40.apply(new FilledList<pet>(Dog.class, 5), Pet.class.getMethod(“speak”));</pet></p>
<p>​       }</p>
<p>}</p>
<p>interface Addable<t> { void add(T t); }</t></p>
<p>public class Fill41 {</p>
<p>​             public static <t> void fill(Addable<t> addable, </t></t></p>
<p>​       Class&lt;? extends T&gt; classToken, int size) {</p>
<p>​              for(int i = 0; i &lt; size; i++) </p>
<p>​                     try {</p>
<p>​                            addable.add(classToken.newInstance());</p>
<p>​                     } catch(Exception e) {</p>
<p>​                            throw new RuntimeException(e);</p>
<p>​                     }</p>
<p>​       }</p>
<p>​             public static <t> void fill(Addable<t> addable, </t></t></p>
<p>​       Generator<t> generator, int size) {</t></p>
<p>​              for(int i = 0; i &lt; size; i++)</p>
<p>​                     addable.add(generator.next());</p>
<p>​       }</p>
<p>}</p>
<p>  class AddableCollectionAdapter<t> implements Addable<t> {</t></t></p>
<p>​       private Collection<t> c;</t></p>
<p>​       public AddableCollectionAdapter(Collection<t> c) {</t></p>
<p>​              this.c = c;</p>
<p>​       }</p>
<p>​       public void add(T item) { c.add(item); }</p>
<p>}</p>
<p> class Adapter {</p>
<p>​       public static <t> </t></p>
<p>​       Addable<t> collectionAdapter(Collection<t> c) {</t></t></p>
<p>​              return new AddableCollectionAdapter<t>(c);          </t></p>
<p>​       }</p>
<p>}</p>
<p>  class AddableSimpleQueue<t></t></p>
<p>extends SimpleQueue<t> implements Addable<t> {</t></t></p>
<p>​       public void add(T item) { super.add(item); }</p>
<p>}</p>
<p>class Fill41Test {</p>
<p>​       public static void main(String[] args) {</p>
<p>​                           List<pet> pets = new ArrayList<pet>();</pet></pet></p>
<p>​              Fill41.fill(</p>
<p>​                     new AddableCollectionAdapter<pet>(pets),</pet></p>
<p>​                     Pet.class, 3);</p>
<p>​                           Fill41.fill(Adapter.collectionAdapter(pets), Manx.class, 2);</p>
<p>​              for(Pet p : pets) print(p);</p>
<p>​              print(“—————“);</p>
<p>​                           AddableSimpleQueue<pet> petQueue = </pet></p>
<p>​                     new AddableSimpleQueue<pet>();</pet></p>
<p>​              Fill41.fill(petQueue, Pug.class, 4);</p>
<p>​              Fill41.fill(petQueue, Gerbil.class, 1);</p>
<p>​              for(Pet p : petQueue) print(p);            </p>
<p>​       }</p>
<p>}</p>
<p> interface Combiner<t> { T combine(T x, T y); }</t></p>
<p>interface UnaryFunction&lt;R,T&gt; { R function(T x); }</p>
<p>interface Collector<t> extends UnaryFunction&lt;T,T&gt; {</t></p>
<p>​       T result();  }</p>
<p>class Food {</p>
<p>​       private String foodName = “”;</p>
<p>​       public Food() { foodName = “”; } </p>
<p>​       public Food(String name) { foodName = name; }</p>
<p>​       public void set(String name) { foodName = name; }</p>
<p>​       public String get() { return foodName; }</p>
<p>​       public void eat() { foodName = “”; }</p>
<p>​       public String toString() { return “Food: “ + foodName; }</p>
<p>}</p>
<p>class Drink {</p>
<p>​       private String drinkName = “”;</p>
<p>​       public Drink() { drinkName= “”; }</p>
<p>​       public Drink(String name) { drinkName = name; }</p>
<p>​       public void set(String name) { drinkName = name; }</p>
<p>​       public String get() { return drinkName; }</p>
<p>​       public void eat() { drinkName = “”; }</p>
<p>​       public String toString() { return “Drink: “ + drinkName; } </p>
<p>}</p>
<p>public class Functional42 {</p>
<p>​                   public static <t> T</t></p>
<p>​       reduce(Iterable<t> seq, Combiner<t> combiner) {</t></t></p>
<p>​              Iterator<t> it = seq.iterator();</t></p>
<p>​              if(it.hasNext()) {</p>
<p>​                     T result = it.next();</p>
<p>​                     while(it.hasNext())</p>
<p>​                            result = combiner.combine(result, it.next());</p>
<p>​                     return result;</p>
<p>​              }</p>
<p>​                           return null;   } </p>
<p>​                               public static <t> Collector<t></t></t></p>
<p>​       forEach(Iterable<t> seq, Collector<t> func) {</t></t></p>
<p>​              for(T t : seq) func.function(t);</p>
<p>​              return func;</p>
<p>​       }      </p>
<p>​       static class MealMaker implements Combiner<food> {</food></p>
<p>​              public Food combine(Food f1, Food f2) {</p>
<p>​                     return new Food(f1.get() + “ “ + f2.get());</p>
<p>​              }</p>
<p>​       }</p>
<p>​       static class DrinkMaker implements Combiner<drink> {</drink></p>
<p>​              public Drink combine(Drink d1, Drink d2) {</p>
<p>​                     return new Drink(d1.get() + “ “ + d2.get());</p>
<p>​              }</p>
<p>​       }</p>
<p>​       static class CookedMeal</p>
<p>​       implements Collector<food> {</food></p>
<p>​              private Food f = new Food(“”);</p>
<p>​              public Food function(Food x) {</p>
<p>​                     f = new Food(f.get() + “ “ + x.get());</p>
<p>​                     return f;</p>
<p>​              }</p>
<p>​              public Food result() { return new Food(“cooked “ + f.get()); }</p>
<p>​       }      </p>
<p>​       public static void main(String[] args) {</p>
<p>​              List<food> lf = Arrays.asList(new Food(“bread”),</food></p>
<p>​                     new Food(“ham”), new Food(“cheese”));</p>
<p>​              Food meal = reduce(lf, new MealMaker());</p>
<p>​              print(meal);</p>
<p>​              List<drink> ld = Arrays.asList(new Drink(“water”),</drink></p>
<p>​                     new Drink(“orange juice”), new Drink(“lemon”));</p>
<p>​              Drink drink = reduce(ld, new DrinkMaker());</p>
<p>​              print(drink);</p>
<p>​              print(forEach(lf, new CookedMeal()).result());</p>
<p>​              </p>
<p>​       }</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解并发/" itemprop="url">Java题解并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第二十一章-并发"><a href="#第二十一章-并发" class="headerlink" title="第二十一章 并发"></a>第二十一章 并发</h2><p>class Ex1RunnerA implements Runnable {</p>
<p>​       public Ex1RunnerA() {</p>
<p>​              System.out.println(“Constructing Ex1RunnerA”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex1RunnerA”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex1RunnerA task complete.”);</p>
<p>​              return;                         </p>
<p>​       }</p>
<p>}</p>
<p>class Ex1RunnerB implements Runnable {</p>
<p>​       public Ex1RunnerB() {</p>
<p>​              System.out.println(“Constructing Ex1RunnerB”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex1RunnerB”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex1RunnerB task complete.”);</p>
<p>​              return;</p>
<p>​       }</p>
<p>}</p>
<p>class Ex1RunnerC implements Runnable {</p>
<p>​       public Ex1RunnerC() {</p>
<p>​              System.out.println(“Constructing Ex1RunnerC”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex1RunnerC”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex1RunnerC task complete.”);</p>
<p>​              return;    </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex1 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Thread ta = new Thread(new Ex1RunnerA());           </p>
<p>​              Thread tb = new Thread(new Ex1RunnerB());           </p>
<p>​              Thread tc = new Thread(new Ex1RunnerC());</p>
<p>​              ta.start();</p>
<p>​              tb.start();</p>
<p>​              tc.start();</p>
<p>​       }</p>
<p>}      </p>
<p>class Ex1RunnerA implements Runnable {</p>
<p>​       public Ex1RunnerA() {</p>
<p>​              System.out.println(“Constructing Ex1RunnerA”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex1RunnerA”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex1RunnerA task complete.”);</p>
<p>​              return;                         </p>
<p>​       }</p>
<p>}</p>
<p>class Ex1RunnerB implements Runnable {</p>
<p>​       public Ex1RunnerB() {</p>
<p>​              System.out.println(“Constructing Ex1RunnerB”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex1RunnerB”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex1RunnerB task complete.”);</p>
<p>​              return;</p>
<p>​       }</p>
<p>}</p>
<p>class Ex1RunnerC implements Runnable {</p>
<p>​       public Ex1RunnerC() {</p>
<p>​              System.out.println(“Constructing Ex1RunnerC”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex1RunnerC”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex1RunnerC task complete.”);</p>
<p>​              return;    </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex1 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Thread ta = new Thread(new Ex1RunnerA());           </p>
<p>​              Thread tb = new Thread(new Ex1RunnerB());           </p>
<p>​              Thread tc = new Thread(new Ex1RunnerC());</p>
<p>​              ta.start();</p>
<p>​              tb.start();</p>
<p>​              tc.start();</p>
<p>​       }</p>
<p>}      </p>
<p>class Ex3RunnerA implements Runnable {</p>
<p>​       public Ex3RunnerA() {</p>
<p>​              System.out.println(“Constructing Ex3RunnerA”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex3RunnerA”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex3RunnerA task complete.”);</p>
<p>​              return;                         </p>
<p>​       }</p>
<p>}</p>
<p>class Ex3RunnerB implements Runnable {</p>
<p>​       public Ex3RunnerB() {</p>
<p>​              System.out.println(“Constructing Ex3RunnerB”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex3RunnerB”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex3RunnerB task complete.”);</p>
<p>​              return;</p>
<p>​       }</p>
<p>}</p>
<p>class Ex3RunnerC implements Runnable {</p>
<p>​       public Ex3RunnerC() {</p>
<p>​              System.out.println(“Constructing Ex3RunnerC”);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 3; i++) {</p>
<p>​                     System.out.println(“Hi from Ex3RunnerC”);       </p>
<p>​                     Thread.yield();</p>
<p>​              }</p>
<p>​              System.out.println(“Ex3RunnerC task complete.”);</p>
<p>​              return;    </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex3 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec1 = Executors.newCachedThreadPool();</p>
<p>​              exec1.execute(new Ex3RunnerA());</p>
<p>​              exec1.execute(new Ex3RunnerB());</p>
<p>​              exec1.execute(new Ex3RunnerC());</p>
<p>​              exec1.shutdown();</p>
<p>​              ExecutorService exec2 = Executors.newFixedThreadPool(3);</p>
<p>​              exec2.execute(new Ex3RunnerA());</p>
<p>​              exec2.execute(new Ex3RunnerB());</p>
<p>​              exec2.execute(new Ex3RunnerC());</p>
<p>​              exec2.shutdown();</p>
<p>​              ExecutorService exec3 = Executors.newSingleThreadExecutor();</p>
<p>​              exec3.execute(new Ex3RunnerA());</p>
<p>​              exec3.execute(new Ex3RunnerB());</p>
<p>​              exec3.execute(new Ex3RunnerC());</p>
<p>​              exec3.shutdown();</p>
<p>​       }</p>
<p>}      </p>
<p>class Ex4FibonacciA implements Runnable {</p>
<p>​       private int n = 0;</p>
<p>​       public Ex4FibonacciA(int n) {</p>
<p>​              this.n = n;</p>
<p>​       }</p>
<p>​       private int fib(int x) {</p>
<p>​              if(x &lt; 2) return 1;</p>
<p>​              return fib(x - 2) + fib(x - 1);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; n; i++)</p>
<p>​                     print(fib(i) + “ “);</p>
<p>​                     println();         </p>
<p>​       }</p>
<p>}</p>
<p>class Ex4FibonacciB implements Runnable {</p>
<p>​       private int n = 0;</p>
<p>​       public Ex4FibonacciB(int n) {</p>
<p>​              this.n = n;</p>
<p>​       }</p>
<p>​       private int fib(int x) {</p>
<p>​              if(x &lt; 2) return 1;</p>
<p>​              return fib(x - 2) + fib(x - 1);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; n; i++)</p>
<p>​                     print(fib(i) + “ “);</p>
<p>​                     println();         </p>
<p>​       }</p>
<p>}</p>
<p>class Ex4FibonacciC implements Runnable {</p>
<p>​       private int n = 0;</p>
<p>​       public Ex4FibonacciC(int n) {</p>
<p>​              this.n = n;</p>
<p>​       }</p>
<p>​       private int fib(int x) {</p>
<p>​              if(x &lt; 2) return 1;</p>
<p>​              return fib(x - 2) + fib(x - 1);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; n; i++)</p>
<p>​                     print(fib(i) + “ “);    </p>
<p>​                     println();  </p>
<p>​       }</p>
<p>}</p>
<p>class Ex4FibonacciD implements Runnable {</p>
<p>​       private int n = 0;</p>
<p>​       public Ex4FibonacciD(int n) {</p>
<p>​              this.n = n;</p>
<p>​       }</p>
<p>​       private int fib(int x) {</p>
<p>​              if(x &lt; 2) return 1;</p>
<p>​              return fib(x - 2) + fib(x - 1);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; n; i++)</p>
<p>​                     print(fib(i) + “ “);    </p>
<p>​                     println();  </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex4 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec1 = Executors.newCachedThreadPool();</p>
<p>​              exec1.execute(new Ex4FibonacciA(15));             </p>
<p>​              exec1.execute(new Ex4FibonacciB(15));             </p>
<p>​              exec1.execute(new Ex4FibonacciC(15));</p>
<p>​              exec1.execute(new Ex4FibonacciD(15));</p>
<p>​              exec1.shutdown();        </p>
<p>​              ExecutorService exec2 = Executors.newFixedThreadPool(4);</p>
<p>​              exec2.execute(new Ex4FibonacciA(15));             </p>
<p>​              exec2.execute(new Ex4FibonacciB(15));             </p>
<p>​              exec2.execute(new Ex4FibonacciC(15));</p>
<p>​              exec2.execute(new Ex4FibonacciD(15));</p>
<p>​              exec2.shutdown();</p>
<p>​              ExecutorService exec3 = Executors.newSingleThreadExecutor();</p>
<p>​              exec3.execute(new Ex4FibonacciA(15));             </p>
<p>​              exec3.execute(new Ex4FibonacciB(15));             </p>
<p>​              exec3.execute(new Ex4FibonacciC(15));</p>
<p>​              exec3.execute(new Ex4FibonacciD(15));</p>
<p>​              exec3.shutdown(); </p>
<p>​       }</p>
<p>}       </p>
<p>class Ex5Fibonacci implements Callable<integer> {</integer></p>
<p>​       private int n = 0;</p>
<p>​       public Ex5Fibonacci(int n) {</p>
<p>​              this.n = n;</p>
<p>​       }</p>
<p>​       private int fib(int x) {</p>
<p>​              if(x &lt; 2) return 1;</p>
<p>​              return fib(x - 2) + fib(x - 1);</p>
<p>​       }</p>
<p>​       public Integer call() {</p>
<p>​              int result = 0;</p>
<p>​              for(int i = 0; i &lt; n; i++) </p>
<p>​                     result += fib(i);             </p>
<p>​              return (Integer)result;</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex5 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              ArrayList&lt;Future<integer>&gt; results = new ArrayList&lt;Future<integer>&gt;();</integer></integer></p>
<p>​              for(int i = 0; i &lt; 20; i++)</p>
<p>​                     results.add(exec.submit(new Ex5Fibonacci(i)));</p>
<p>​              for(Future<integer> fs : results)</integer></p>
<p>​                     try {</p>
<p>​                                                       System.out.println(fs.get());</p>
<p>​                     } catch(InterruptedException e) {</p>
<p>​                            System.out.println(e);</p>
<p>​                            return;</p>
<p>​                     } catch(ExecutionException e) {</p>
<p>​                            System.out.println(e);    </p>
<p>​                     } finally {</p>
<p>​                            exec.shutdown();</p>
<p>​                     }                           </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex6 implements Runnable {</p>
<p>​       Random rand = new Random();</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     int t = 1000 * rand.nextInt(10);</p>
<p>​                     TimeUnit.MILLISECONDS.sleep(t);       </p>
<p>​                     System.out.println(“Slept “ + t                  return;                  </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     System.err.println(“Interrupted”);</p>
<p>​              }</p>
<p>​              </p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              if(args.length &lt; 1) {</p>
<p>​                     System.out.println(“Usage: enter a number”);</p>
<p>​              }             </p>
<p>​              if(args.length == 1) {</p>
<p>​                     int n = Integer.parseInt(args[0]);</p>
<p>​                     ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​                     for(int i = 0; i &lt; n; i++)</p>
<p>​                            exec.execute(new Ex6());</p>
<p>​                     exec.shutdown();</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Daemon implements Runnable {</p>
<p>​       private Thread[] t = new Thread[30];</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; t.length; i++) {</p>
<p>​                     t[i] = new Thread(new DaemonSpawn());</p>
<p>​                     t[i].start();</p>
<p>​                     printnb(“DaemonSpawn “ + i + “ started, “);</p>
<p>​              }</p>
<p>​              for(int i = 0; i &lt; t.length; i++)</p>
<p>​                     printnb(“t[“ + i + “].isDaemon() = “ + </p>
<p>​                            t[i].isDaemon() + “, “);</p>
<p>​              while(true)</p>
<p>​                     Thread.yield();</p>
<p>​       }</p>
<p>}</p>
<p>class DaemonSpawn implements Runnable {</p>
<p>​       public void run() {</p>
<p>​              while(true)</p>
<p>​                     Thread.yield();</p>
<p>​       }</p>
<p>}</p>
<p>public class Daemons7 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              Thread d = new Thread(new Daemon());</p>
<p>​              d.setDaemon(true);</p>
<p>​              d.start();</p>
<p>​              printnb(“d.isDaemon() = “ + d.isDaemon() + “, “);</p>
<p>​                                 }</p>
<p>}</p>
<p>public class MoreBasicThreads8 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              try {                     for(int i = 0; i &lt; 25; i++) { </p>
<p>​                            Thread t = new Thread(new LiftOff());</p>
<p>​                            t.setDaemon(true);</p>
<p>​                            t.start();                        </p>
<p>​                     }</p>
<p>​                     System.out.println(“Waiting for LiftOff”);    </p>
<p>​              </p>
<p>​              } finally {</p>
<p>​                     System.out.println(“Finally out of main”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class SimplePriorities9ThreadFactory implements ThreadFactory {</p>
<p>​       Random rand = new Random();</p>
<p>​       public Thread newThread(Runnable r) {</p>
<p>​              Thread t = new Thread(r);</p>
<p>​              int i = rand.nextInt(3);</p>
<p>​              switch(i) {</p>
<p>​                     case 0 : t.setPriority(MIN_PRIORITY); break;</p>
<p>​                     case 1 : t.setPriority(NORM_PRIORITY); break;</p>
<p>​                     case 2 : t.setPriority(MAX_PRIORITY); break;</p>
<p>​                     default:   </p>
<p>​              }</p>
<p>​              return t;  </p>
<p>​       }</p>
<p>}</p>
<p>public class SimplePriorities9 implements Runnable {</p>
<p>​       private int countDown = 5;</p>
<p>​       private volatile double d;   public String toString() {</p>
<p>​              return Thread.currentThread() + “: “ + countDown;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              while(true) {</p>
<p>​                                         for(int i = 0; i &lt; 100000; i++) {</p>
<p>​                            d += (Math.PI + Math.E)                         if(i % 1000 == 0)</p>
<p>​                                   Thread.yield();</p>
<p>​                     } </p>
<p>​              System.out.println(this);</p>
<p>​              if(–countDown == 0) return;</p>
<p>​              }             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              ExecutorService exec = </p>
<p>​                     Executors.newCachedThreadPool(new SimplePriorities9ThreadFactory());</p>
<p>​              for(int i = 0; i &lt; 5; i++)</p>
<p>​                     exec.execute(new SimplePriorities9());</p>
<p>​              exec.execute(new SimplePriorities9());</p>
<p>​              exec.shutdown();</p>
<p>​                     </p>
<p>​       }</p>
<p>}</p>
<p>class Ex10Fibonacci implements Callable<integer> {</integer></p>
<p>​       private Integer n = 0;</p>
<p>​       ExecutorService exec = Executors.newSingleThreadExecutor();</p>
<p>​       private int fib(int x) {</p>
<p>​              if(x &lt; 2) return 1;</p>
<p>​              return fib(x - 2) + fib(x - 1);</p>
<p>​       }      </p>
<p>​       public Integer call() {</p>
<p>​              int result = 0;</p>
<p>​              for(int i = 0; i &lt; n; i++) </p>
<p>​                     result += fib(i);             </p>
<p>​              return (Integer)result;</p>
<p>​       }</p>
<p>​       public Future<integer> runTask(Integer n) {</integer></p>
<p>​              this.n = n;      </p>
<p>​              return exec.submit(this);              </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex10 {</p>
<p>​       public static void main(String[] args) {       </p>
<p>​              Ex10Fibonacci fib = new Ex10Fibonacci();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 15; i++) {</p>
<p>​                            print(“Sum of first “ + i + </p>
<p>​                                   “ Fibonacci numbers = “);</p>
<p>​                            println(fib.runTask(i).get());</p>
<p>​                     }                    </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     System.out.println(e);</p>
<p>​                     return;</p>
<p>​              } catch(ExecutionException e) {</p>
<p>​                     System.out.println(e);    </p>
<p>​              } finally {</p>
<p>​                     fib.exec.shutdown();</p>
<p>​              }                    </p>
<p>​       }</p>
<p>}</p>
<p>abstract class NumRangeGenerator {       private volatile boolean canceled = false;</p>
<p>​       public abstract int[] next(); </p>
<p>​       public void cancel() { canceled = true; }</p>
<p>​       public boolean isCanceled() { return canceled; }</p>
<p>}</p>
<p>class NumRangeChecker11 implements Runnable {      private NumRangeGenerator generator;</p>
<p>​       private final int id;</p>
<p>​       public NumRangeChecker11(NumRangeGenerator g, int ident) {</p>
<p>​              generator = g;</p>
<p>​              id = ident;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              System.out.println(“Testing..”);</p>
<p>​              while(!generator.isCanceled()) {</p>
<p>​                     int[] range = generator.next();</p>
<p>​                    if( range[0] &gt; range[1]) {</p>
<p>​                            System.out.println(“Error in test #” + id + “: min “ + range[0] </p>
<p>​                                   + “ &gt; “ + “max “ + range[1] );</p>
<p>​                            generator.cancel();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static void test(NumRangeGenerator gen, int count) {</p>
<p>​              System.out.println(“Press Ctrl-C to exit”);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; count; i++) </p>
<p>​                     exec.execute(new NumRangeChecker11(gen, i));            </p>
<p>​              exec.shutdown();</p>
<p>​       }</p>
<p>​       public static void test(NumRangeGenerator gen) {</p>
<p>​              test(gen, 10);</p>
<p>​       }</p>
<p>}</p>
<p>public class NumRangeGenerator11 extends NumRangeGenerator {</p>
<p>​       private int min = 0;</p>
<p>​       private int max = 0;</p>
<p>​       private int[] range = { min, max };</p>
<p>​       private Random rand = new Random();</p>
<p>​       public int[] next() {             min = rand.nextInt(100);</p>
<p>​              max = rand.nextInt(100);</p>
<p>​              Thread.yield();</p>
<p>​              if(min &gt; max) max = min;</p>
<p>​              int[] ia = { min, max };</p>
<p>​              return ia;</p>
<p>​       }      </p>
<p>​       public static void main(String[] args) {</p>
<p>​              NumRangeChecker11.test(new NumRangeGenerator11());</p>
<p>​       }</p>
<p>}</p>
<p>public class AtomicityTest12 implements Runnable {</p>
<p>​       private int i = 0;</p>
<p>​       public synchronized int getValue() { return i; }</p>
<p>​       private synchronized void evenIncrement() { i++; i++; } </p>
<p>​       public void run() {</p>
<p>​              while(true) {</p>
<p>​                     evenIncrement();</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              AtomicityTest12 at = new AtomicityTest12();</p>
<p>​              exec.execute(at);</p>
<p>​              while(true) {</p>
<p>​                     int val = at.getValue();</p>
<p>​                     if(val % 2 != 0) {</p>
<p>​                            System.out.println(val);</p>
<p>​                            System.exit(0);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p> class CircularSet {</p>
<p>​       private int[] array;</p>
<p>​       private int len;</p>
<p>​       private int index = 0;</p>
<p>​       public CircularSet(int size) {</p>
<p>​              array = new int[size];</p>
<p>​              len = size;</p>
<p>​                                        for(int i = 0; i &lt; size; i++)</p>
<p>​                     array[i] = -1;</p>
<p>​       }</p>
<p>​       public synchronized void add(int i) {</p>
<p>​              array[index] = i;</p>
<p>​                           index = ++index % len;</p>
<p>​       }</p>
<p>​       public synchronized boolean contains(int val) {</p>
<p>​              for(int i = 0; i &lt; len; i++)</p>
<p>​                     if(array[i] == val) return true;</p>
<p>​              return false;</p>
<p>​       }</p>
<p>}</p>
<p>public class SerialNumberChecker13 {       </p>
<p>​       private static final int SIZE = 10;</p>
<p>​       private static CircularSet serials = new CircularSet(1000);</p>
<p>​       private static ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​       static class SerialChecker13 implements Runnable {</p>
<p>​              public void run() {</p>
<p>​                     while(true) {</p>
<p>​                            int serial = SerialNumberGenerator13.nextSerialNumber();</p>
<p>​                            if(serials.contains(serial)) {</p>
<p>​                                   System.out.println(“Duplicate: “ + serial);</p>
<p>​                                   System.exit(0);</p>
<p>​                            }</p>
<p>​                            serials.add(serial);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              for(int i = 0; i &lt; SIZE; i++)</p>
<p>​                     exec.execute(new SerialChecker13());</p>
<p>​                           if(args.length &gt; 0) {</p>
<p>​                     TimeUnit.SECONDS.sleep(new Integer(args[0]));</p>
<p>​                     System.out.println(“No duplicates detected”);</p>
<p>​                     System.exit(0);</p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex14 implements Runnable {</p>
<p>​       private static int timers = 0;</p>
<p>​       private static int tasks = 0;</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(timers &lt; 4000) {                             ++timers;</p>
<p>​                            Timer t = new Timer();         </p>
<p>​                            t.schedule(new TimerTask() {</p>
<p>​                                   public void run() {</p>
<p>​                                          ++tasks; </p>
<p>​                                          if(timers % 100 == 0)           </p>
<p>​                                                 System.out.println(timers + “ timers did “ </p>
<p>​                                                        + tasks + “ tasks”);</p>
<p>​                                   }</p>
<p>​                            }, 0);</p>
<p>​                            try {</p>
<p>​                                   TimeUnit.MILLISECONDS.sleep(30);                              } catch(InterruptedException e) {</p>
<p>​                                   System.out.println(“Sleep interrupted”);</p>
<p>​                            }</p>
<p>​                            t.cancel();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     System.out.println(“Done. “ + timers + “ timers completed “ </p>
<p>​                            + tasks + “ tasks”);</p>
<p>​              } </p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              exec.execute(new Ex14());</p>
<p>​              exec.shutdown();</p>
<p>​       }</p>
<p>}</p>
<p>class SyncTest1 {         public void f1() {</p>
<p>​              synchronized(this) {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“f1()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void g1() {</p>
<p>​              synchronized(this) {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“g1()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void h1() {</p>
<p>​              synchronized(this) {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“h1()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class SyncTest2 {         private Object syncObject1 = new Object();</p>
<p>​       private Object syncObject2 = new Object();</p>
<p>​       private Object syncObject3 = new Object();</p>
<p>​       public void f2() {</p>
<p>​              synchronized(syncObject1) {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“f2()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void g2() {</p>
<p>​              synchronized(syncObject2) {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“g2()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void h2() {</p>
<p>​              synchronized(syncObject3) {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“h2()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex15 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              final SyncTest1 st1 = new SyncTest1();</p>
<p>​              final SyncTest2 st2 = new SyncTest2();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st1.f1();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st1.g1();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st1.h1();</p>
<p>​                     }</p>
<p>​              }.start();          </p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st2.f2();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st2.g2();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st2.h2();</p>
<p>​                     }</p>
<p>​              }.start();                 </p>
<p>​       }</p>
<p>}</p>
<p>class SyncTest1 {         private Lock lock = new ReentrantLock();</p>
<p>​       public void f1() {</p>
<p>​              lock.lock();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“f1()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     lock.unlock();</p>
<p>​              }             </p>
<p>​       }</p>
<p>​       public void g1() {</p>
<p>​              lock.lock();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“g1()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     lock.unlock();</p>
<p>​              }      </p>
<p>​       }</p>
<p>​       public void h1() {</p>
<p>​              lock.lock();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“h1()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     lock.unlock();</p>
<p>​              }      </p>
<p>​       }</p>
<p>}</p>
<p>class SyncTest2 {         private Lock lock1 = new ReentrantLock();</p>
<p>​       private Lock lock2 = new ReentrantLock();</p>
<p>​       private Lock lock3 = new ReentrantLock();</p>
<p>​       </p>
<p>​       public void f2() {</p>
<p>​              lock1.lock();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“f2()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     lock1.unlock();</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void g2() {</p>
<p>​              lock2.lock();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“g2()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     lock2.unlock();</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void h2() {</p>
<p>​              lock3.lock();</p>
<p>​              try {</p>
<p>​                     for(int i = 0; i &lt; 5; i++) {</p>
<p>​                            print(“h2()”);</p>
<p>​                            Thread.yield();</p>
<p>​                     }</p>
<p>​              } finally {</p>
<p>​                     lock3.unlock();</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex16 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              final SyncTest1 st1 = new SyncTest1();</p>
<p>​              final SyncTest2 st2 = new SyncTest2();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st1.f1();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st1.g1();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st1.h1();</p>
<p>​                     }</p>
<p>​              }.start();          </p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st2.f2();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st2.g2();</p>
<p>​                     }</p>
<p>​              }.start();</p>
<p>​              new Thread() {</p>
<p>​                     public void run() {</p>
<p>​                            st2.h2();</p>
<p>​                     }</p>
<p>​              }.start();                 </p>
<p>​       }</p>
<p>}</p>
<p>class RadCount {</p>
<p>​       private int count = 0;</p>
<p>​       private Random rand = new Random();</p>
<p>​       public synchronized int increment() {</p>
<p>​              return count++;</p>
<p>​       }</p>
<p>​       public synchronized int value() { return count; } </p>
<p>}</p>
<p>class Sensor implements Runnable {</p>
<p>​       private static RadCount count = new RadCount();</p>
<p>​       private static List<sensor> sensors = new ArrayList<sensor>();</sensor></sensor></p>
<p>​       private int number = 0;</p>
<p>​             private final int id;</p>
<p>​       private static volatile boolean canceled = false;</p>
<p>​             public static void cancel() { canceled = true; }</p>
<p>​       public Sensor(int id) {</p>
<p>​              this.id = id;</p>
<p>​                                        sensors.add(this);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              while(!canceled) {</p>
<p>​                     synchronized(this) {</p>
<p>​                            ++number;</p>
<p>​                     }</p>
<p>​                     print(this + “ Total: “ + count.increment());</p>
<p>​                     try {</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(25);</p>
<p>​                     } catch(InterruptedException e) {</p>
<p>​                            print(“sleep interrupted”);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              print(“Stopping “ + this);</p>
<p>​       }</p>
<p>​       public synchronized int getValue() { return number; }</p>
<p>​       public String toString() {</p>
<p>​              return “Sensor “ + id + “: “ + getValue();</p>
<p>​       } </p>
<p>​       public static int getTotalCount() {</p>
<p>​              return count.value();</p>
<p>​       }</p>
<p>​       public static int sumSensors() {</p>
<p>​              int sum = 0;</p>
<p>​              for(Sensor sensor : sensors)</p>
<p>​                     sum += sensor.getValue();</p>
<p>​              return sum;</p>
<p>​       }</p>
<p>}</p>
<p>public class RadiationCounter17 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     exec.execute(new Sensor(i));</p>
<p>​                           TimeUnit.SECONDS.sleep(4);</p>
<p>​              Sensor.cancel();</p>
<p>​              exec.shutdown();</p>
<p>​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))</p>
<p>​                     print(“Some tasks were not terminated”);</p>
<p>​              print(“Total: “ + Sensor.getTotalCount());</p>
<p>​              print(“Sum of Sensors: “ + Sensor.sumSensors());</p>
<p>​       }</p>
<p>}</p>
<p>class Nontask {</p>
<p>​       public static void rest() {</p>
<p>​              try {</p>
<p>​                     TimeUnit.SECONDS.sleep(5);</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     System.out.println(“Sleep interrupted”);</p>
<p>​              } finally {</p>
<p>​                     System.out.println(“Good Bye”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Worker implements Runnable {</p>
<p>​       public void run() {</p>
<p>​              Nontask.rest();              </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex18 {</p>
<p>​       public static void main(String[] args) { </p>
<p>​                                        Thread t = new Thread(new Worker());</p>
<p>​              t.start();</p>
<p>​              t.interrupt();</p>
<p>​                           ExecutorService exec = Executors.newSingleThreadExecutor();</p>
<p>​              exec.execute(new Worker());              </p>
<p>​              exec.shutdownNow();</p>
<p>​                           ExecutorService exec2 = Executors.newSingleThreadExecutor();</p>
<p>​              Future&lt;?&gt; f = exec2.submit(new Worker());</p>
<p>​              try {</p>
<p>​                     TimeUnit.MILLISECONDS.sleep(100);              } catch(InterruptedException e) {</p>
<p>​                     System.out.println(“Sleep interrupted in main()”);</p>
<p>​              }</p>
<p>​              f.cancel(true);</p>
<p>​              exec2.shutdown();        </p>
<p>​       }</p>
<p>}</p>
<p>class Count {</p>
<p>​       private int count = 0;</p>
<p>​       private Random rand = new Random(47);</p>
<p>​             public synchronized int increment() {</p>
<p>​              int temp = count;</p>
<p>​              if(rand.nextBoolean())                      Thread.yield();</p>
<p>​              return (count = ++temp);</p>
<p>​       }</p>
<p>​       public synchronized int value() { return count; } </p>
<p>}</p>
<p>class Entrance implements Runnable {</p>
<p>​       private static Count count = new Count();</p>
<p>​       private static List<entrance> entrances = new ArrayList<entrance>();</entrance></entrance></p>
<p>​       private int number = 0;</p>
<p>​             private final int id;</p>
<p>​       private static volatile boolean canceled = false;</p>
<p>​             public static void cancel() { canceled = true; }</p>
<p>​       public Entrance(int id) {</p>
<p>​              this.id = id;</p>
<p>​                                        entrances.add(this);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              while(!canceled) {</p>
<p>​                     synchronized(this) {                          ++number;</p>
<p>​                     }</p>
<p>​                     print(this + “ Total: “ + count.increment());</p>
<p>​                     try {</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(50);</p>
<p>​                     } catch(InterruptedException e) {</p>
<p>​                            print(“sleep interrupted”);</p>
<p>​                            break;                 }</p>
<p>​              }</p>
<p>​              print(“Stopping “ + this);</p>
<p>​       }</p>
<p>​       public synchronized int getValue() { return number; }</p>
<p>​       public String toString() {</p>
<p>​              return “Entrance “ + id + “: “ + getValue();</p>
<p>​       } </p>
<p>​       public static int getTotalCount() {</p>
<p>​              return count.value();</p>
<p>​       }</p>
<p>​       public static int sumEntrances() {</p>
<p>​              int sum = 0;</p>
<p>​              for(Entrance entrance : entrances)</p>
<p>​                     sum += entrance.getValue();</p>
<p>​              return sum;</p>
<p>​       }</p>
<p>}</p>
<p>public class OrnamentalGarden19 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; 5; i++)</p>
<p>​                     exec.execute(new Entrance(i));</p>
<p>​                           TimeUnit.SECONDS.sleep(4);</p>
<p>​                           exec.shutdownNow();</p>
<p>​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))</p>
<p>​                     print(“Some tasks were not terminated”);</p>
<p>​              print(“Total: “ + Entrance.getTotalCount());</p>
<p>​              print(“Sum of Entrances: “ + Entrance.sumEntrances());</p>
<p>​       }</p>
<p>}</p>
<p>public class CachedThreadPool20 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              System.out.println(“Using LiftOff:”);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; 5; i++) {</p>
<p>​                     Future&lt;?&gt; f = exec.submit(new LiftOff());</p>
<p>​                     f.cancel(true);                                           </p>
<p>​              }</p>
<p>​              exec.shutdownNow();</p>
<p>​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))</p>
<p>​                     System.out.println(“Some tasks were not terminated”);</p>
<p>​                           System.out.println(“\nUsing LiftOff20:”); </p>
<p>​              ExecutorService exec20 = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; 5; i++) {</p>
<p>​                     Future&lt;?&gt; f = exec20.submit(new LiftOff20());</p>
<p>​                     f.cancel(true);                             </p>
<p>​              }</p>
<p>​              exec20.shutdownNow();</p>
<p>​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))</p>
<p>​                     System.out.println(“Some tasks were not terminated”);          </p>
<p>​       }</p>
<p>}</p>
<p>class A implements Runnable {</p>
<p>​       private volatile boolean signal = false;</p>
<p>​       public synchronized void run() {               try {</p>
<p>​                     while(!signal) {                                                                          println(“A.run() wait()”);</p>
<p>​                                                       wait();</p>
<p>​                            signal = true;</p>
<p>​                            println(“A is done waiting”);                            </p>
<p>​                     }                    </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     println(“A run() interrupted”);      </p>
<p>​              } finally {</p>
<p>​                     println(“Leaving A.run()”);    </p>
<p>​              }             </p>
<p>​       }</p>
<p>​       public synchronized void message() {</p>
<p>​              println(“Hi from A”);</p>
<p>​       }             </p>
<p>}</p>
<p>class B implements Runnable {    </p>
<p>​       private A a;</p>
<p>​       public A getA() { return a; }</p>
<p>​       B(A a) { this.a = a; } </p>
<p>​       public void run() {</p>
<p>​              try { </p>
<p>​                     TimeUnit.MILLISECONDS.sleep(2000);</p>
<p>​                     synchronized(a) {                             println(“B.run() a.notifyAll()”);</p>
<p>​                            a.notifyAll();</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                    System.out.println(“B sleep interrupted”);</p>
<p>​              }             </p>
<p>​       }      </p>
<p>}</p>
<p>public class Ex21 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              B b = new B(new A());</p>
<p>​              exec.execute(b.getA());</p>
<p>​              try { </p>
<p>​                     TimeUnit.MILLISECONDS.sleep(100);                </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                    System.out.println(“main() sleep interrupted”);</p>
<p>​              }</p>
<p>​              b.getA().message();</p>
<p>​              exec.execute(b);</p>
<p>​              try { </p>
<p>​                     TimeUnit.MILLISECONDS.sleep(2500);                      </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                    System.out.println(“main() sleep interrupted”);</p>
<p>​              }             </p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>}</p>
<p>class A implements Runnable {</p>
<p>​       boolean flag = false;</p>
<p>​       public synchronized void run() {</p>
<p>​              try {</p>
<p>​                     TimeUnit.SECONDS.sleep(2);</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     println(“sleep interrupted in A”);</p>
<p>​              }</p>
<p>​              println(“A setting flag = true”); </p>
<p>​              flag = true;            </p>
<p>​       }      </p>
<p>}</p>
<p>class BusyWait implements Runnable {</p>
<p>​       A a = new A();</p>
<p>​       long start, end;</p>
<p>​       public synchronized A getA() { return a; }</p>
<p>​       private BusyWait(A a) {</p>
<p>​              this.a = a;</p>
<p>​       }</p>
<p>​       public static BusyWait buildBusyWait(A a) {</p>
<p>​              return new BusyWait(a);</p>
<p>​       }</p>
<p>​       public synchronized void run() {</p>
<p>​              println(“Busy a.flag = “ + a.flag);         </p>
<p>​              while(!Thread.interrupted()) {      </p>
<p>​                     start = System.nanoTime();         </p>
<p>​                     if(a.flag) {</p>
<p>​                            a.flag = false;</p>
<p>​                            println(“BusyWait reset a.flag = false”);</p>
<p>​                            end = System.nanoTime();</p>
<p>​                            println(“Busy waiting “ + (end - start) + “ nanoseconds”);</p>
<p>​                     }</p>
<p>​              }             </p>
<p>​       }</p>
<p>}</p>
<p>class BetterWait implements Runnable {</p>
<p>​       private A a = new A();</p>
<p>​       public synchronized A getA() { return a; }</p>
<p>​       private BetterWait(A a) {</p>
<p>​              this.a = a;</p>
<p>​       }</p>
<p>​       public static BetterWait buildBetterWait(A a) {</p>
<p>​              return new BetterWait(a);</p>
<p>​       }</p>
<p>​       public synchronized void run() {</p>
<p>​              println(“Better a.flag = “ + a.flag);</p>
<p>​              try {               </p>
<p>​                     while(!a.flag) {</p>
<p>​                            wait();     </p>
<p>​                            a.flag = false;</p>
<p>​                            println(“BetterWait reset a.flag = false”);</p>
<p>​                     }                           </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     println(“BetterWait.run() interrupted”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex22 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              BusyWait busy = BusyWait.buildBusyWait(new A());</p>
<p>​              exec.execute(busy.a);</p>
<p>​              exec.execute(busy);</p>
<p>​              try {</p>
<p>​                     TimeUnit.SECONDS.sleep(3);</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     println(“sleep interrupted in main()”);</p>
<p>​              }</p>
<p>​              println();</p>
<p>​              BetterWait better = BetterWait.buildBetterWait(new A());</p>
<p>​              exec.execute(better.getA());</p>
<p>​              exec.execute(better);</p>
<p>​              try {</p>
<p>​                     TimeUnit.SECONDS.sleep(3);</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     println(“sleep interrupted in main()”);</p>
<p>​              }</p>
<p>​              synchronized(better) {</p>
<p>​                     println(“Sending better.notifyAll()”);</p>
<p>​                     better.notifyAll();</p>
<p>​              }</p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>}</p>
<p>class Car {</p>
<p>​       private boolean waxOn = false;</p>
<p>​       public synchronized void waxed() {</p>
<p>​              waxOn = true;                         notify();</p>
<p>​       }</p>
<p>​       public synchronized void buffed() {</p>
<p>​              waxOn = false;                        notify();</p>
<p>​       }</p>
<p>​       public synchronized void waitForWaxing() throws InterruptedException {</p>
<p>​              while(waxOn == false) wait();</p>
<p>​       }</p>
<p>​       public synchronized void waitForBuffing() throws InterruptedException {</p>
<p>​              while(waxOn == true) wait();</p>
<p>​       }</p>
<p>}      </p>
<p>class WaxOn implements Runnable {</p>
<p>​       private Car car;</p>
<p>​       public WaxOn(Car c) { car = c; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            printnb(“Wax On! “);</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(200);</p>
<p>​                            car.waxed();</p>
<p>​                            car.waitForBuffing();</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Exiting via interrupt”);</p>
<p>​              }</p>
<p>​              print(“Ending Wax On task”);</p>
<p>​       }</p>
<p>}</p>
<p>class WaxOff implements Runnable {</p>
<p>​       private Car car;</p>
<p>​       public WaxOff(Car c) { car = c; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            car.waitForWaxing();</p>
<p>​                            printnb(“Wax Off! “);</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(200);</p>
<p>​                            car.buffed();</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Exiting via interrupt”);</p>
<p>​              }</p>
<p>​              print(“Ending Wax Off task”);</p>
<p>​       }</p>
<p>}</p>
<p>public class WaxOMatic23 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              Car car = new Car();</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              exec.execute(new WaxOff(car));</p>
<p>​              exec.execute(new WaxOn(car));</p>
<p>​              TimeUnit.SECONDS.sleep(5);            exec.shutdownNow();         }</p>
<p>}      </p>
<p>class Item {</p>
<p>​       private final int itemNum;</p>
<p>​       public Item(int itemNum) { this.itemNum = itemNum; }</p>
<p>​       public String toString() { return “Item “ + itemNum; }</p>
<p>}</p>
<p>class Producer implements Runnable {</p>
<p>​       private int count = 0;</p>
<p>​       Market24 market;</p>
<p>​       Producer(Market24 m) { market = m; }</p>
<p>​       protected int getCount() { return count; }</p>
<p>​       public void run() {</p>
<p>​              while(!Thread.interrupted()) {</p>
<p>​                     try {</p>
<p>​                            while(count &lt; 100) {</p>
<p>​                                   Item item = new Item(++count);</p>
<p>​                                   if(market.storage.offer(item)) {</p>
<p>​                                          println(“Produced “ + item);</p>
<p>​                                                                                   synchronized(market.consumer) { </p>
<p>​                                                 market.consumer.notifyAll();</p>
<p>​                                          }      </p>
<p>​                                   }</p>
<p>​                                                                     synchronized(this) { </p>
<p>​                                          while(!(market.storage.size() &lt; 10)) {</p>
<p>​                                                 wait();</p>
<p>​                                          }</p>
<p>​                                   }</p>
<p>​                     }</p>
<p>​                                         println(“Produced “ + count + “ Items”</p>
<p>​                           + “\nStopping production”);</p>
<p>​                     market.exec.shutdownNow();      </p>
<p>​                     } catch(InterruptedException e) {</p>
<p>​                            println(“Producer interrupted”);</p>
<p>​                            println(“Produced “ + count + “ Items”); </p>
<p>​                     }                                  </p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Consumer implements Runnable {</p>
<p>​       int consumed = 0;</p>
<p>​       Market24 market;</p>
<p>​       List<item> cart = new ArrayList<item>();</item></item></p>
<p>​       Consumer(Market24 m) { market = m; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                                                       synchronized(this) {</p>
<p>​                                   while(!(cart.size() &lt; market.producer.getCount())) {</p>
<p>​                                          wait();</p>
<p>​                                   } </p>
<p>​                            }</p>
<p>​                                                       if(cart.add(market.storage.poll())) {</p>
<p>​                                   println(“Consuming Item “ + ++consumed); </p>
<p>​                                                                     synchronized(market.producer) {</p>
<p>​                                          market.producer.notifyAll();</p>
<p>​                                   }</p>
<p>​                            }                    </p>
<p>​                     }             </p>
<p>​              }</p>
<p>​              catch(InterruptedException e) {</p>
<p>​                     println(“Consumer interrupted”);</p>
<p>​                     println(“Consumed “ + consumed + “ Items”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Market24 {</p>
<p>​       ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​       Queue<item> storage = new LinkedList<item>();</item></item></p>
<p>​       Producer producer = new Producer(this);</p>
<p>​       Consumer consumer = new Consumer(this);</p>
<p>​       public Market24() {</p>
<p>​              exec.execute(producer);</p>
<p>​              exec.execute(consumer);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              new Market24();</p>
<p>​       }</p>
<p>}</p>
<p>class Meal {</p>
<p>​       private final int orderNum;</p>
<p>​       public Meal(int orderNum) { this.orderNum = orderNum; }</p>
<p>​       public String toString() { return “Meal “ + orderNum; }</p>
<p>}</p>
<p>class WaitPerson25 implements Runnable {</p>
<p>​       private Restaurant25 restaurant;</p>
<p>​       public WaitPerson25(Restaurant25 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            synchronized(this) {</p>
<p>​                                   while(restaurant.meal == null)</p>
<p>​                                          wait();                         }</p>
<p>​                            print(“WaitPerson25 got “ + restaurant.meal);</p>
<p>​                            synchronized(restaurant.chef) {</p>
<p>​                                   restaurant.meal = null;</p>
<p>​                                   restaurant.chef.notifyAll();                       }</p>
<p>​                     }      </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“WaitPerson25 interrupted”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Chef25 implements Runnable {</p>
<p>​       private Restaurant25 restaurant;</p>
<p>​       private int count = 0;</p>
<p>​       public Chef25(Restaurant25 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            synchronized(this) {</p>
<p>​                                   while(restaurant.meal != null) </p>
<p>​                                          wait();                         }</p>
<p>​                            if(++count == 10) {</p>
<p>​                                   print(“Out of food, closing”);</p>
<p>​                                   restaurant.exec.shutdownNow();</p>
<p>​                                   return;                        }</p>
<p>​                            printnb(“Order up! “);</p>
<p>​                            synchronized(restaurant.waitPerson) {</p>
<p>​                                   restaurant.meal = new Meal(count);</p>
<p>​                                   restaurant.waitPerson.notifyAll();</p>
<p>​                            }</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(100);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Chef25 interrupted”);</p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>public class Restaurant25 {</p>
<p>​       Meal meal;</p>
<p>​       ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​       WaitPerson25 waitPerson = new WaitPerson25(this);</p>
<p>​       Chef25 chef = new Chef25(this);</p>
<p>​       public Restaurant25() {</p>
<p>​              exec.execute(chef);</p>
<p>​              exec.execute(waitPerson);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              new Restaurant25();</p>
<p>​       }</p>
<p>}</p>
<p>class Meal {</p>
<p>​       private final int orderNum;</p>
<p>​       public Meal(int orderNum) { this.orderNum = orderNum; }</p>
<p>​       public String toString() { return “Meal “ + orderNum; }</p>
<p>}</p>
<p>class WaitPerson26 implements Runnable {</p>
<p>​       private Restaurant26 restaurant;</p>
<p>​       protected boolean clean = true;</p>
<p>​       protected Meal m;      public WaitPerson26(Restaurant26 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            synchronized(this) {</p>
<p>​                                   while(restaurant.meal == null)</p>
<p>​                                          wait();                         }</p>
<p>​                            m = restaurant.meal;</p>
<p>​                            print(“WaitPerson got “ + m);</p>
<p>​                            synchronized(restaurant.chef) {</p>
<p>​                                   restaurant.meal = null;</p>
<p>​                                   restaurant.chef.notifyAll();                       }</p>
<p>​                            print(“WaitPerson delivered “ + m);</p>
<p>​                            synchronized(restaurant.busBoy) { </p>
<p>​                                   clean = false;</p>
<p>​                                   restaurant.busBoy.notifyAll();                          }</p>
<p>​                     }      </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“WaitPerson interrupted”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Chef26 implements Runnable {</p>
<p>​       private Restaurant26 restaurant;</p>
<p>​       private int count = 0;</p>
<p>​       public Chef26(Restaurant26 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            synchronized(this) {</p>
<p>​                                   while(restaurant.meal != null) </p>
<p>​                                          wait();                         }</p>
<p>​                            if(++count == 10) {</p>
<p>​                                   print(“Out of food, closing”);</p>
<p>​                                   restaurant.exec.shutdownNow();</p>
<p>​                                   return;</p>
<p>​                            }</p>
<p>​                            print(“Order up! “);</p>
<p>​                            synchronized(restaurant.waitPerson) {</p>
<p>​                                   restaurant.meal = new Meal(count);</p>
<p>​                                   restaurant.waitPerson.notifyAll();</p>
<p>​                            }</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(100);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Chef interrupted”);</p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>class BusBoy26 implements Runnable {</p>
<p>​       private Restaurant26 restaurant;</p>
<p>​       public BusBoy26(Restaurant26 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            synchronized(this) {</p>
<p>​                                   while(restaurant.waitPerson.clean)</p>
<p>​                                          wait();</p>
<p>​                            }</p>
<p>​                            print(“BusBoy cleaning up “ + restaurant.waitPerson.m);</p>
<p>​                            restaurant.waitPerson.clean = true;</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“BusBoy interrupted”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Restaurant26 {</p>
<p>​       Meal meal;</p>
<p>​       ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​       WaitPerson26 waitPerson = new WaitPerson26(this);</p>
<p>​       BusBoy26 busBoy = new BusBoy26(this);</p>
<p>​       Chef26 chef = new Chef26(this);</p>
<p>​       public Restaurant26() {</p>
<p>​              exec.execute(chef);</p>
<p>​              exec.execute(waitPerson);</p>
<p>​              exec.execute(busBoy);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              new Restaurant26();</p>
<p>​       }</p>
<p>}</p>
<p>class Meal {</p>
<p>​       private final int orderNum;</p>
<p>​       public Meal(int orderNum) { this.orderNum = orderNum; }</p>
<p>​       public String toString() { return “Meal “ + orderNum; }</p>
<p>}</p>
<p>class WaitPerson27 implements Runnable {</p>
<p>​       private Restaurant27 restaurant;</p>
<p>​       protected Lock lock = new ReentrantLock();</p>
<p>​       protected Condition condition = lock.newCondition();</p>
<p>​       public WaitPerson27(Restaurant27 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            lock.lock();</p>
<p>​                            try {</p>
<p>​                                   while(restaurant.meal == null)</p>
<p>​                                          condition.await();</p>
<p>​                            } finally {</p>
<p>​                                   lock.unlock();</p>
<p>​                            }</p>
<p>​                            print(“waitPerson got “ + restaurant.meal);</p>
<p>​                            restaurant.chef.lock.lock();</p>
<p>​                            try {</p>
<p>​                                   restaurant.meal = null;</p>
<p>​                                   restaurant.chef.condition.signalAll();</p>
<p>​                            } finally {</p>
<p>​                                   restaurant.chef.lock.unlock();</p>
<p>​                            }                           </p>
<p>​                     }      </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“WaitPerson27 interrupted”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Chef27 implements Runnable {</p>
<p>​       private Restaurant27 restaurant;</p>
<p>​       private int count = 0;</p>
<p>​       protected Lock lock = new ReentrantLock();</p>
<p>​       protected Condition condition = lock.newCondition();</p>
<p>​       public Chef27(Restaurant27 r) { restaurant = r; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            lock.lock(); </p>
<p>​                            try {</p>
<p>​                                   while(restaurant.meal != null)</p>
<p>​                                          condition.await();</p>
<p>​                            } finally {</p>
<p>​                                   lock.unlock();</p>
<p>​                            }</p>
<p>​                            if(++count == 10) {</p>
<p>​                                   print(“Out of food, closing”);</p>
<p>​                                   restaurant.exec.shutdownNow();</p>
<p>​                                   return;</p>
<p>​                            }</p>
<p>​                            printnb(“Order up! “);</p>
<p>​                            restaurant.waitPerson.lock.lock();</p>
<p>​                            try {</p>
<p>​                                   restaurant.meal = new Meal(count);</p>
<p>​                                   restaurant.waitPerson.condition.signalAll();</p>
<p>​                            } finally {</p>
<p>​                                   restaurant.waitPerson.lock.unlock();</p>
<p>​                            }</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(100);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“chef interrupted”);</p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>public class Restaurant27 {</p>
<p>​       Meal meal;</p>
<p>​       ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​       WaitPerson27 waitPerson = new WaitPerson27(this);</p>
<p>​       Chef27 chef = new Chef27(this);</p>
<p>​       public Restaurant27() {</p>
<p>​              exec.execute(chef);</p>
<p>​              exec.execute(waitPerson);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              new Restaurant27();</p>
<p>​       }</p>
<p>}</p>
<p>class LiftOffRunner implements Runnable {</p>
<p>​       private BlockingQueue<liftoff> rockets;</liftoff></p>
<p>​       public LiftOffRunner(BlockingQueue<liftoff> queue) {</liftoff></p>
<p>​              rockets = queue;</p>
<p>​       } </p>
<p>​       public void add(LiftOff lo) {</p>
<p>​              try {</p>
<p>​                     rockets.put(lo);</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Interrupted during put()”);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            LiftOff rocket = rockets.take();</p>
<p>​                            rocket.run();                       }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Waking from take()”);</p>
<p>​              }</p>
<p>​              print(“Exiting LiftOffRunner”);</p>
<p>​       }</p>
<p>}</p>
<p>class LiftOffAdder implements Runnable {</p>
<p>​       private LiftOffRunner runner;</p>
<p>​       public LiftOffAdder(LiftOffRunner runner) {</p>
<p>​              this.runner = runner;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              for(int i = 0; i &lt; 5; i++)</p>
<p>​                     runner.add(new LiftOff(5));   </p>
<p>​       }</p>
<p>}</p>
<p>public class TestBlockingQueues28 {</p>
<p>​       static void getKey() {</p>
<p>​              try {</p>
<p>​                                                             new BufferedReader(new InputStreamReader(System.in)).readLine();</p>
<p>​              } catch(java.io.IOException e) {</p>
<p>​                     throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       static void getKey(String message) {</p>
<p>​              printnb(message);</p>
<p>​              getKey();</p>
<p>​       }</p>
<p>​       static void test(String msg, BlockingQueue<liftoff> queue) {</liftoff></p>
<p>​              print(msg);</p>
<p>​              LiftOffRunner runner = new LiftOffRunner(queue);</p>
<p>​              LiftOffAdder adder = new LiftOffAdder(runner);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              exec.execute(runner);</p>
<p>​              exec.execute(adder);</p>
<p>​              getKey(“Press ‘Enter’ (“ + msg + “)”);</p>
<p>​              print(“Finished “ + msg + “ test”);</p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              test(“LinkedBlockingQueue”,                   new LinkedBlockingQueue<liftoff>());</liftoff></p>
<p>​              test(“ArrayBlockingQueue”,                     new ArrayBlockingQueue<liftoff>(3));</liftoff></p>
<p>​              test(“SynchronousQueue”,                      new SynchronousQueue<liftoff>());</liftoff></p>
<p>​       }</p>
<p>}</p>
<p>class Toast {</p>
<p>​       public enum Status { DRY, JELLIED, PEANUTBUTTERED }</p>
<p>​       private Status status = Status.DRY;</p>
<p>​       private final int id;</p>
<p>​       public Toast(int idn) { id = idn; }</p>
<p>​       public void jelly() { status = Status.JELLIED; }</p>
<p>​       public void peanutButter() { status = Status.PEANUTBUTTERED; }</p>
<p>​       public Status getStatus() { return status; }</p>
<p>​       public int getId() { return id; }</p>
<p>​       public String toString() {</p>
<p>​              return “Toast “ + id + “: “ + status;</p>
<p>​       }</p>
<p>}</p>
<p>class ToastQueue extends LinkedBlockingQueue<toast> {}</toast></p>
<p>​       </p>
<p>class Toaster implements Runnable {</p>
<p>​       private ToastQueue toastQueue;</p>
<p>​       private int count = 0;</p>
<p>​       private Random rand = new Random();</p>
<p>​       public Toaster(ToastQueue tq) { toastQueue = tq; }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            TimeUnit.MILLISECONDS.sleep(</p>
<p>​                                   100 + rand.nextInt(500));</p>
<p>​                                                       Toast t = new Toast(count++);</p>
<p>​                            print(t);</p>
<p>​                                                       toastQueue.put(t);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Toaster interrupted”);</p>
<p>​              }</p>
<p>​              print(“Toaster off”);</p>
<p>​       }</p>
<p>}</p>
<p> class PeanutButterer implements Runnable {</p>
<p>​       private ToastQueue dryQueue, peanutButteredQueue;</p>
<p>​       public PeanutButterer(ToastQueue dry, ToastQueue peanutButtered) {</p>
<p>​              dryQueue = dry;</p>
<p>​              peanutButteredQueue = peanutButtered;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                                                       Toast t = dryQueue.take();</p>
<p>​                            t.peanutButter();</p>
<p>​                            print(t);</p>
<p>​                            peanutButteredQueue.put(t);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                    print(“PeanutButterer interrupted”);</p>
<p>​              }</p>
<p>​              print(“PeanutButterer off”);</p>
<p>​       }</p>
<p>}</p>
<p> class Jellyer implements Runnable {</p>
<p>​       private ToastQueue dryQueue, jelliedQueue;</p>
<p>​       public Jellyer(ToastQueue dry, ToastQueue jellied ) {</p>
<p>​              dryQueue = dry;</p>
<p>​              jelliedQueue = jellied;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                                                       Toast t = dryQueue.take();</p>
<p>​                            t.jelly();</p>
<p>​                            print(t);</p>
<p>​                            jelliedQueue.put(t);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“Jellyer interrupted”);</p>
<p>​              }</p>
<p>​              print(“Jellyer off”);</p>
<p>​       }</p>
<p>}</p>
<p>class Sandwich {</p>
<p>​       private Toast top, bottom;</p>
<p>​       private final int id;</p>
<p>​       public Sandwich(Toast top, Toast bottom, int id) {</p>
<p>​              this.top = top;</p>
<p>​              this.bottom = bottom;</p>
<p>​              this.id = id;</p>
<p>​       }</p>
<p>​       public int getId() {</p>
<p>​              return id;</p>
<p>​       }</p>
<p>​       public Toast getTop() { return top; }</p>
<p>​       public Toast getBottom() { return bottom; }</p>
<p>​       public String toString() {</p>
<p>​              return “Sandwich “ + id + “: top: “ + top + “ and bottom: “ + bottom;</p>
<p>​       }</p>
<p>}</p>
<p>class SandwichQueue extends LinkedBlockingQueue<sandwich> {}</sandwich></p>
<p> class SandwichMaker implements Runnable {</p>
<p>​       private int count = 0;</p>
<p>​       private ToastQueue jelliedQueue, peanutButteredQueue;</p>
<p>​       private SandwichQueue sandwichQueue;</p>
<p>​       public SandwichMaker(ToastQueue jellied, ToastQueue peanutButtered, SandwichQueue sq) {</p>
<p>​              jelliedQueue = jellied;</p>
<p>​              peanutButteredQueue = peanutButtered;</p>
<p>​              sandwichQueue = sq;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            Sandwich s = new Sandwich(</p>
<p>​                                   jelliedQueue.take(), peanutButteredQueue.take(), count++);</p>
<p>​                            print(s);</p>
<p>​                            sandwichQueue.put(s);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(“SandwichMaker interrupted”);</p>
<p>​              }</p>
<p>​              print(“Sandwich maker off”);</p>
<p>​       }</p>
<p>}</p>
<p> class SandwichEater implements Runnable {</p>
<p>​       private SandwichQueue sandwichQueue;</p>
<p>​       private int counter = 0;</p>
<p>​       public SandwichEater(SandwichQueue sq) {</p>
<p>​              sandwichQueue = sq;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                                                       Sandwich s = sandwichQueue.take();</p>
<p>​                                                                                  if(s.getId() != counter++ || </p>
<p>​                                   s.getTop().getStatus() != Toast.Status.JELLIED || </p>
<p>​                                   s.getBottom().getStatus() != Toast.Status.PEANUTBUTTERED) {</p>
<p>​                                          print(“&gt;&gt;&gt;&gt; Error: “ + s);</p>
<p>​                                          System.exit(1);</p>
<p>​                            } else</p>
<p>​                                   print(“NumNum! “ + s);</p>
<p>​                     } </p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                            print(“SandwichEater interruped”);</p>
<p>​              }</p>
<p>​              print(“SandwichEater off”);</p>
<p>​       }</p>
<p>}</p>
<p>public class ToastOMatic29 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              ToastQueue dryQueue = new ToastQueue(),</p>
<p>​                     jelliedQueue = new ToastQueue(),</p>
<p>​                     peanutButteredQueue = new ToastQueue();</p>
<p>​              SandwichQueue sandwichQueue = new SandwichQueue();</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              exec.execute(new Toaster(dryQueue));</p>
<p>​              exec.execute(new Jellyer(dryQueue, jelliedQueue));</p>
<p>​              exec.execute(new PeanutButterer(dryQueue, peanutButteredQueue));</p>
<p>​              exec.execute(new SandwichMaker(</p>
<p>​                     jelliedQueue, peanutButteredQueue, sandwichQueue));</p>
<p>​              exec.execute(new SandwichEater(sandwichQueue));</p>
<p>​              TimeUnit.SECONDS.sleep(5);</p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>}</p>
<p>class Sender implements Runnable {</p>
<p>​       private Random rand = new Random(47);</p>
<p>​       private LinkedBlockingQueue<character> queue;</character></p>
<p>​       public Sender(LinkedBlockingQueue<character> lbq) {</character></p>
<p>​              queue = lbq;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(true)</p>
<p>​                            for(char c = ‘A’; c &lt;= ‘z’; c++) {</p>
<p>​                                   queue.put(c);</p>
<p>​                                   TimeUnit.MILLISECONDS.sleep(rand.nextInt(500));</p>
<p>​                            }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(e + “ Sender sleep interrupted”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Receiver implements Runnable {</p>
<p>​       private LinkedBlockingQueue<character> queue;</character></p>
<p>​       public Receiver(LinkedBlockingQueue<character> lbq) {</character></p>
<p>​              queue = lbq;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​               try {</p>
<p>​                     while(true) {</p>
<p>​                                                       printnb(“Read: “ + (char)queue.take() + “, “);</p>
<p>​                     }</p>
<p>​               } catch(InterruptedException e) {</p>
<p>​                     print(e + “ Receiver read exception”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex30 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              LinkedBlockingQueue<character> lbq = new LinkedBlockingQueue<character>();</character></character></p>
<p>​              Sender sender = new Sender(lbq);</p>
<p>​              Receiver receiver = new Receiver(lbq);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              exec.execute(sender);</p>
<p>​              exec.execute(receiver);</p>
<p>​              TimeUnit.SECONDS.sleep(4);</p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>}</p>
<p>public class Philosopher31 implements Runnable {</p>
<p>​       private Chopstick left;</p>
<p>​       private Chopstick right;</p>
<p>​       private LinkedBlockingQueue<chopstick> bin;</chopstick></p>
<p>​       private final int id;</p>
<p>​       private final int ponderFactor;</p>
<p>​       private Random rand = new Random(47);</p>
<p>​       private void pause() throws InterruptedException {</p>
<p>​              if(ponderFactor == 0) return;</p>
<p>​              TimeUnit.MILLISECONDS.sleep(rand.nextInt(ponderFactor * 250));</p>
<p>​       }</p>
<p>​       public Philosopher31(Chopstick left, Chopstick right, </p>
<p>​              LinkedBlockingQueue<chopstick> bin, int ident, int ponder) {</chopstick></p>
<p>​              this.left = left;</p>
<p>​              this.right = right;</p>
<p>​              this.bin = bin;</p>
<p>​              id = ident;</p>
<p>​              ponderFactor = ponder;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            print(this + “ “ + “thinking”);</p>
<p>​                            pause();</p>
<p>​                                                       print(this + “ taking first, right chopstick”);</p>
<p>​                            right = bin.take();</p>
<p>​                            print(this + “ taking second, left chopstick”);</p>
<p>​                            left = bin.take();</p>
<p>​                            print(this + “ eating”);</p>
<p>​                            pause();</p>
<p>​                            print(this + “ returning chopsticks”);</p>
<p>​                            bin.put(right);</p>
<p>​                            bin.put(left);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                     print(this + “ “ + “exiting via interrupt”);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public String toString() { return “Philosopher “ + id; }</p>
<p>}</p>
<p>public class DeadlockingDiningPhilosophers31 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              int ponder = 5;</p>
<p>​              if(args.length &gt; 0)</p>
<p>​                     ponder = Integer.parseInt(args[0]);</p>
<p>​              int size = 5;</p>
<p>​              if(args.length &gt; 1)</p>
<p>​                     size = Integer.parseInt(args[1]);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​                           LinkedBlockingQueue<chopstick> bin = new LinkedBlockingQueue<chopstick>();</chopstick></chopstick></p>
<p>​              Chopstick[] sticks = new Chopstick[size];</p>
<p>​              for(int i = 0; i &lt; size; i++) {</p>
<p>​                     sticks[i] = new Chopstick();</p>
<p>​                     bin.put(sticks[i]);</p>
<p>​              }      </p>
<p>​              for(int i = 0; i &lt; size; i++)     </p>
<p>​                     exec.execute(new Philosopher31(sticks[i], sticks[(i + 1) % size], bin, i, ponder));</p>
<p>​              if(args.length == 3 &amp;&amp; args[2].equals(“timeout”))</p>
<p>​                     TimeUnit.SECONDS.sleep(5);</p>
<p>​              else {</p>
<p>​                     System.out.println(“Press ‘Enter’ to quit”);</p>
<p>​                     System.in.read();</p>
<p>​              }</p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>}</p>
<p>import java.util.concurrent.*;</p>
<p>import java.util.*;</p>
<p>import static net.mindview.util.Print.*;</p>
<p>class Count {</p>
<p>​       private int count = 0;</p>
<p>​       private Random rand = new Random(47);</p>
<p>​             public synchronized int increment() {</p>
<p>​              int temp = count;</p>
<p>​              if(rand.nextBoolean())                      Thread.yield();</p>
<p>​              return (count = ++temp);</p>
<p>​       }</p>
<p>​       public synchronized int value() { return count; } </p>
<p>}</p>
<p>class Entrance implements Runnable {</p>
<p>​       private static Count count = new Count();</p>
<p>​       private static List<entrance> entrances = new ArrayList<entrance>();</entrance></entrance></p>
<p>​       private int number = 0;</p>
<p>​       private final int id;</p>
<p>​       private final CountDownLatch doneSignal;</p>
<p>​       private static CountDownLatch stopSignal;</p>
<p>​       public Entrance(int id, CountDownLatch doneSignal, CountDownLatch stopSignal) {</p>
<p>​              this.id = id;</p>
<p>​              this.doneSignal = doneSignal;</p>
<p>​              this.stopSignal = stopSignal;</p>
<p>​                                        entrances.add(this);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              while(!(stopSignal.getCount() == 0)) {</p>
<p>​                     synchronized(this) {</p>
<p>​                            ++number;</p>
<p>​                     }</p>
<p>​                     print(this + “ Total: “ + count.increment());</p>
<p>​                     try { </p>
<p>​                            TimeUnit.MILLISECONDS.sleep(100);</p>
<p>​                     } catch(InterruptedException e) {</p>
<p>​                            print(“sleep interrupted”);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              print(“Closing “ + this);</p>
<p>​              doneSignal.countDown();</p>
<p>​       }</p>
<p>​       public synchronized int getValue() { return number; }</p>
<p>​       public String toString() {</p>
<p>​              return “Entrance “ + id + “: “ + getValue();</p>
<p>​       } </p>
<p>​       public static int getTotalCount() {</p>
<p>​              return count.value();</p>
<p>​       }</p>
<p>​       public static int sumEntrances() {</p>
<p>​              int sum = 0;</p>
<p>​              for(Entrance entrance : entrances)</p>
<p>​                     sum += entrance.getValue();</p>
<p>​              return sum;</p>
<p>​       }</p>
<p>}</p>
<p>public class OrnamentalGarden32 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              int SIZE = 5;</p>
<p>​              CountDownLatch stopSignal = new CountDownLatch(1);</p>
<p>​              CountDownLatch doneSignal = new CountDownLatch(SIZE);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; SIZE; i++)</p>
<p>​                     exec.execute(new Entrance(i, doneSignal, stopSignal));</p>
<p>​                           TimeUnit.SECONDS.sleep(2);</p>
<p>​                           stopSignal.countDown();</p>
<p>​                           doneSignal.await();</p>
<p>​              exec.shutdown();</p>
<p>​              print(“Total: “ + Entrance.getTotalCount());</p>
<p>​              print(“Sum of Entrances: “ + Entrance.sumEntrances());</p>
<p>​       }</p>
<p>}</p>
<p>class Count {</p>
<p>​       private int count = 0;</p>
<p>​       private Random rand = new Random(47);</p>
<p>​             public synchronized int increment() {</p>
<p>​              int temp = count;</p>
<p>​              if(rand.nextBoolean())                      Thread.yield();</p>
<p>​              return (count = ++temp);</p>
<p>​       }</p>
<p>​       public synchronized int value() { return count; } </p>
<p>}</p>
<p>class Entrance implements Runnable {</p>
<p>​       private static Count count = new Count();</p>
<p>​       private static List<entrance> entrances = new ArrayList<entrance>();</entrance></entrance></p>
<p>​       private int number = 0;</p>
<p>​       private final int id;</p>
<p>​       private final CountDownLatch doneSignal;</p>
<p>​       private static CountDownLatch stopSignal;</p>
<p>​       public Entrance(int id, CountDownLatch doneSignal, CountDownLatch stopSignal) {</p>
<p>​              this.id = id;</p>
<p>​              this.doneSignal = doneSignal;</p>
<p>​              this.stopSignal = stopSignal;</p>
<p>​                                        entrances.add(this);</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              while(!(stopSignal.getCount() == 0)) {</p>
<p>​                     synchronized(this) {</p>
<p>​                            ++number;</p>
<p>​                     }</p>
<p>​                     print(this + “ Total: “ + count.increment());</p>
<p>​                     try { </p>
<p>​                            TimeUnit.MILLISECONDS.sleep(100);</p>
<p>​                     } catch(InterruptedException e) {</p>
<p>​                            print(“sleep interrupted”);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              print(“Closing “ + this);</p>
<p>​              doneSignal.countDown();</p>
<p>​       }</p>
<p>​       public synchronized int getValue() { return number; }</p>
<p>​       public String toString() {</p>
<p>​              return “Entrance “ + id + “: “ + getValue();</p>
<p>​       } </p>
<p>​       public static int getTotalCount() {</p>
<p>​              return count.value();</p>
<p>​       }</p>
<p>​       public static int sumEntrances() {</p>
<p>​              int sum = 0;</p>
<p>​              for(Entrance entrance : entrances)</p>
<p>​                     sum += entrance.getValue();</p>
<p>​              return sum;</p>
<p>​       }</p>
<p>}</p>
<p>public class OrnamentalGarden32 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              int SIZE = 5;</p>
<p>​              CountDownLatch stopSignal = new CountDownLatch(1);</p>
<p>​              CountDownLatch doneSignal = new CountDownLatch(SIZE);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              for(int i = 0; i &lt; SIZE; i++)</p>
<p>​                     exec.execute(new Entrance(i, doneSignal, stopSignal));</p>
<p>​                           TimeUnit.SECONDS.sleep(2);</p>
<p>​                           stopSignal.countDown();</p>
<p>​                           doneSignal.await();</p>
<p>​              exec.shutdown();</p>
<p>​              print(“Total: “ + Entrance.getTotalCount());</p>
<p>​              print(“Sum of Entrances: “ + Entrance.sumEntrances());</p>
<p>​       }</p>
<p>}</p>
<p>abstract class DelayedGreenhouseTask implements Delayed, Runnable {</p>
<p>​       protected long delayTime;        public long trigger;     public DelayedGreenhouseTask() {</p>
<p>​              delayTime = 0;</p>
<p>​              trigger = System.nanoTime();</p>
<p>​       }</p>
<p>​       public DelayedGreenhouseTask(long d) { </p>
<p>​              delayTime = d; </p>
<p>​              trigger = System.nanoTime() + </p>
<p>​                     NANOSECONDS.convert(delayTime, MILLISECONDS);</p>
<p>​       }</p>
<p>​       public long getDelay(TimeUnit unit) {</p>
<p>​              return unit.convert(</p>
<p>​                     trigger - System.nanoTime(), NANOSECONDS);</p>
<p>​       }</p>
<p>​       public int compareTo(Delayed d) {</p>
<p>​              DelayedGreenhouseTask that = (DelayedGreenhouseTask)d;</p>
<p>​              if(trigger &lt; that.trigger) return -1;</p>
<p>​              if(trigger &gt; that.trigger) return 1;</p>
<p>​              return 0;</p>
<p>​       }</p>
<p>​             abstract public DelayedGreenhouseTask create(long d);</p>
<p>​       abstract public void run(); </p>
<p>}</p>
<p>class GreenhouseController33 {</p>
<p>​       private volatile boolean light = false;</p>
<p>​       private volatile boolean water = false;</p>
<p>​       private String thermostat = “Day”;</p>
<p>​       DelayQueue<delayedgreenhousetask> tasks = new DelayQueue<delayedgreenhousetask>();</delayedgreenhousetask></delayedgreenhousetask></p>
<p>​       public synchronized String getThermostat()  {</p>
<p>​              return thermostat;</p>
<p>​       }</p>
<p>​       public synchronized void setThermostat(String value) {</p>
<p>​              thermostat = value;</p>
<p>​       }</p>
<p>​       class LightOn33 extends DelayedGreenhouseTask {</p>
<p>​              public LightOn33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public LightOn33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public LightOn33 create(long d) {                   return new LightOn33(d);</p>
<p>​              }</p>
<p>​              public void run() { </p>
<p>​                     if(!light) {</p>
<p>​                            System.out.println(“Turning on lights”);</p>
<p>​                            light = true;</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       class LightOff33 extends DelayedGreenhouseTask {</p>
<p>​              public LightOff33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public LightOff33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public LightOff33 create(long d) { </p>
<p>​                     return new LightOff33(d);</p>
<p>​              }</p>
<p>​              public void run() { </p>
<p>​                     if(light) {</p>
<p>​                            System.out.println(“Turning off lights”);</p>
<p>​                            light = false;</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       class WaterOn33 extends DelayedGreenhouseTask {</p>
<p>​              public WaterOn33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public WaterOn33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public WaterOn33 create(long d) {                 return new WaterOn33(d);</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                                         System.out.println(“Turning greenhouse water on”);</p>
<p>​                     water = true;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       class WaterOff33 extends DelayedGreenhouseTask {</p>
<p>​              public WaterOff33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public WaterOff33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public WaterOff33 create(long d) { </p>
<p>​                     return new WaterOff33(d);</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                                         System.out.println(“Turning greenhouse water off”);</p>
<p>​                     water = false;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       class ThermostatNight33 extends DelayedGreenhouseTask {</p>
<p>​              public ThermostatNight33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public ThermostatNight33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public ThermostatNight33 create(long d) { </p>
<p>​                     return new ThermostatNight33(d);</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                                         System.out.println(“Thermostat to night setting”);</p>
<p>​                     setThermostat(“Night”);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       class ThermostatDay33 extends DelayedGreenhouseTask {</p>
<p>​              public ThermostatDay33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public ThermostatDay33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public ThermostatDay33 create(long d) { </p>
<p>​                     return new ThermostatDay33(d);</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                                         System.out.println(“Thermostat to day setting”);</p>
<p>​                     setThermostat(“Day”);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       class Bell33 extends DelayedGreenhouseTask {</p>
<p>​              public Bell33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public Bell33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public Bell33 create(long d) {</p>
<p>​                     return new Bell33(d);</p>
<p>​              }</p>
<p>​              public void run() { System.out.println(“Bing!”); }</p>
<p>​       }</p>
<p>​             static class DataPoint33 {</p>
<p>​              final Calendar time;</p>
<p>​              final float temperature;</p>
<p>​              final float humidity;</p>
<p>​              public DataPoint33(Calendar d, float temp, float hum) {</p>
<p>​                     time = d;</p>
<p>​                     temperature = temp;</p>
<p>​                     humidity = hum;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return time.getTime() + </p>
<p>​                            String.format(</p>
<p>​                                   “ temperature: %1$.1f humidity: %2$.2f”,</p>
<p>​                                   temperature, humidity);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       private Calendar lastTime = Calendar.getInstance();</p>
<p>​       {            lastTime.set(Calendar.MINUTE, 30);</p>
<p>​              lastTime.set(Calendar.SECOND, 00);</p>
<p>​       }</p>
<p>​       private float lastTemp = 65.0f;</p>
<p>​       private int tempDirection = +1;</p>
<p>​       private float lastHumidity = 50.0f;</p>
<p>​       private int humidityDirection = +1;</p>
<p>​       private Random rand = new Random(47);</p>
<p>​       List<datapoint33> data = Collections.synchronizedList(</datapoint33></p>
<p>​              new ArrayList<datapoint33>());</datapoint33></p>
<p>​       class CollectData33 extends DelayedGreenhouseTask {</p>
<p>​              public CollectData33() {</p>
<p>​                     super();</p>
<p>​              }</p>
<p>​              public CollectData33(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public CollectData33 create(long d) {</p>
<p>​                     return new CollectData33(d);</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                     System.out.println(“Collecting data”);</p>
<p>​                     synchronized(GreenhouseController33.this) {</p>
<p>​                                                       lastTime.set(Calendar.MINUTE, </p>
<p>​                                   lastTime.get(Calendar.MINUTE) + 30);</p>
<p>​                                                       if(rand.nextInt(5) == 4)</p>
<p>​                                   tempDirection = -tempDirection;</p>
<p>​                                                       lastTemp = lastTemp + </p>
<p>​                                   tempDirection * (1.0f + rand.nextFloat());</p>
<p>​                            if(rand.nextInt(5) == 4) </p>
<p>​                                   humidityDirection = -humidityDirection;</p>
<p>​                            lastHumidity = lastHumidity +</p>
<p>​                                   humidityDirection * rand.nextFloat();</p>
<p>​                                                                                                             data.add(new DataPoint33((Calendar)lastTime.clone(),</p>
<p>​                                   lastTemp, lastHumidity));</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public class StopController extends DelayedGreenhouseTask {</p>
<p>​              private ExecutorService exec;</p>
<p>​              public StopController(long delay, ExecutorService e) {</p>
<p>​                     super(delay);</p>
<p>​                     exec = e;</p>
<p>​              }</p>
<p>​              public StopController create(long delay) {</p>
<p>​                     return new StopController(delay, Executors.newCachedThreadPool());</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                     System.out.println(“Calling shutdownNow()”);</p>
<p>​                     exec.shutdownNow();</p>
<p>​                                         new Thread() {</p>
<p>​                            public void run() {</p>
<p>​                                   for(DataPoint33 d : data)</p>
<p>​                                          System.out.println(d);</p>
<p>​                            }</p>
<p>​                     }.start();</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static class GreenhouseGo implements Runnable {</p>
<p>​              private DelayQueue<delayedgreenhousetask> q;</delayedgreenhousetask></p>
<p>​              public GreenhouseGo(DelayQueue<delayedgreenhousetask> q) {</delayedgreenhousetask></p>
<p>​                     this.q = q;</p>
<p>​              }</p>
<p>​              public void run() {</p>
<p>​                                         try {</p>
<p>​                            while(!Thread.interrupted()) </p>
<p>​                                   q.take().run();                     } catch(InterruptedException e) {</p>
<p>​                                                }</p>
<p>​                     System.out.println(“Finished GreenhouseGo”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseScheduler33 {</p>
<p>​       public static void repeat(</p>
<p>​       GreenhouseController33 c, DelayedGreenhouseTask task, long interval, long duration) </p>
<p>​              throws Exception {</p>
<p>​              if(interval &lt;= duration) {</p>
<p>​                     for(int i = 0; i &lt; duration                          DelayedGreenhouseTask t = task.create(interval * (i + 1));</p>
<p>​                            c.tasks.put(t);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              GreenhouseController33 ghc = new GreenhouseController33();</p>
<p>​              repeat(ghc, ghc.new Bell33(), 1000, 4000);</p>
<p>​              repeat(ghc, ghc.new ThermostatNight33(), 2000, 4000);</p>
<p>​              repeat(ghc, ghc.new LightOn33(), 200, 4000);</p>
<p>​              repeat(ghc, ghc.new LightOff33(), 400, 4000);</p>
<p>​              repeat(ghc, ghc.new WaterOn33(), 600, 4000);</p>
<p>​              repeat(ghc, ghc.new WaterOff33(), 800, 4000);</p>
<p>​              repeat(ghc, ghc.new ThermostatDay33(), 1400, 4000);</p>
<p>​              repeat(ghc, ghc.new CollectData33(), 500, 4000);</p>
<p>​              ghc.tasks.put(ghc.new StopController(5000, exec));</p>
<p>​              exec.execute(new GreenhouseController33.GreenhouseGo(ghc.tasks));</p>
<p>​       }</p>
<p>}</p>
<p>class ExchangerProducer34<t> implements Runnable {</t></p>
<p>​       private Generator<t> generator;</t></p>
<p>​       private Exchanger&lt;List<t>&gt; exchanger;</t></p>
<p>​       private List<t> holder;</t></p>
<p>​       ExchangerProducer34(Exchanger&lt;List<t>&gt; exchg, Generator<t> gen, List<t> holder) {</t></t></t></p>
<p>​              exchanger = exchg;</p>
<p>​              generator = gen;</p>
<p>​              this.holder = holder;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            for(int i = 0; i &lt; ExchangerDemo34.size; i++)</p>
<p>​                                   holder.add(generator.next());</p>
<p>​                                                       holder = exchanger.exchange(holder);</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                                  }</p>
<p>​       }</p>
<p>}</p>
<p>class ExchangerConsumer34<t> implements Runnable {</t></p>
<p>​       private Exchanger&lt;List<t>&gt; exchanger;</t></p>
<p>​       private List<t> holder;</t></p>
<p>​       private volatile T value;</p>
<p>​       ExchangerConsumer34(Exchanger&lt;List<t>&gt; ex, List<t> holder) {</t></t></p>
<p>​              exchanger = ex;</p>
<p>​              this.holder = holder;</p>
<p>​       }</p>
<p>​       public void run() {</p>
<p>​              try {</p>
<p>​                     while(!Thread.interrupted()) {</p>
<p>​                            holder = exchanger.exchange(holder);</p>
<p>​                            for(T x : holder) {</p>
<p>​                                   value = x;                                 holder.remove(x);                            }</p>
<p>​                     }</p>
<p>​              } catch(InterruptedException e) {</p>
<p>​                                  }</p>
<p>​              System.out.println(“Final value: “ + value);</p>
<p>​       }</p>
<p>}</p>
<p>public class ExchangerDemo34 {</p>
<p>​       static int size = 10;</p>
<p>​       static int delay = 5;     public static void main(String[] args) throws Exception { </p>
<p>​              if(args.length &gt; 0) size = new Integer(args[0]);</p>
<p>​              if(args.length &gt; 1) delay = new Integer(args[1]);</p>
<p>​              ExecutorService exec = Executors.newCachedThreadPool();</p>
<p>​              Exchanger&lt;List<xctest34>&gt; xc = new Exchanger&lt;List<xctest34>&gt;();</xctest34></xctest34></p>
<p>​              List<xctest34></xctest34></p>
<p>​                     producerList = new CopyOnWriteArrayList<xctest34>(),</xctest34></p>
<p>​                     consumerList = new CopyOnWriteArrayList<xctest34>();</xctest34></p>
<p>​             exec.execute(new ExchangerProducer34<xctest34>(xc, BasicGenerator.create(XCTest34.class), producerList));</xctest34></p>
<p>​              exec.execute(new ExchangerConsumer34<xctest34>(xc, consumerList));</xctest34></p>
<p>​              TimeUnit.SECONDS.sleep(delay);</p>
<p>​              exec.shutdownNow();</p>
<p>​       }</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解内部类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解内部类/" itemprop="url">Java题解内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第十章内部类"><a href="#第十章内部类" class="headerlink" title="第十章内部类"></a>第十章内部类</h2><p>public class Outer1 {</p>
<p>​       class Inner { </p>
<p>​              Inner() { System.out.println(“Inner()”); }</p>
<p>​       }</p>
<p>​       Outer1() { System.out.println(“Outer1()”); }</p>
<p>​             Inner makeInner() {</p>
<p>​              return new Inner();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer1 o = new Outer1();</p>
<p>​              Inner i = o.makeInner();</p>
<p>​       }</p>
<p>}</p>
<p>class Word {</p>
<p>​       private String word;</p>
<p>​       public Word(String s) { word = s; }</p>
<p>​       public String toString() { return word; }</p>
<p>} </p>
<p>interface Selector {</p>
<p>​       boolean end();</p>
<p>​       Object current();</p>
<p>​       void next();</p>
<p>}</p>
<p>public class Sequence2 {</p>
<p>​       private Object[] items;</p>
<p>​       private int next = 0;</p>
<p>​       public Sequence2(int size) { items = new Object[size]; }</p>
<p>​       public void add(Object x) {</p>
<p>​              if(next &lt; items.length)</p>
<p>​                     items[next++] = x;</p>
<p>​       }</p>
<p>​       private class SequenceSelector implements Selector {</p>
<p>​              private int i = 0;</p>
<p>​              public boolean end() { return i == items.length; }</p>
<p>​              public Object current() { return items[i]; }</p>
<p>​              public void next() { if(i &lt; items.length) i++; } </p>
<p>​       }</p>
<p>​       public Selector selector() {</p>
<p>​              return new SequenceSelector();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Sequence2 sequence = new Sequence2(10);</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     sequence.add(new Word(Integer.toString(i)));</p>
<p>​              Selector selector = sequence.selector();</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​              Word w1 = new Word(“Peace”);</p>
<p>​              Word w2 = new Word(“Love”);</p>
<p>​              Word w3 = new Word(“Easter”);</p>
<p>​              Sequence2 message = new Sequence2(3);</p>
<p>​              message.add(w1);</p>
<p>​              message.add(w2);</p>
<p>​              message.add(w3);</p>
<p>​              Selector sel = message.selector();</p>
<p>​              while(!sel.end()) {</p>
<p>​                     System.out.print(sel.current() + “ “);</p>
<p>​                     sel.next();</p>
<p>​              }</p>
<p>​                     </p>
<p>​       }</p>
<p>}</p>
<p>public class Outer3 {</p>
<p>​       private String s;</p>
<p>​       class Inner3 { </p>
<p>​              Inner3() { System.out.println(“Inner()”); }</p>
<p>​              public String toString() { return s; }</p>
<p>​       }</p>
<p>​       Outer3(String s) { </p>
<p>​              System.out.println(“Outer1()”);</p>
<p>​              this.s = s;</p>
<p>​       }</p>
<p>​       Inner3 makeInner3() {</p>
<p>​              return new Inner3();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer3 o = new Outer3(“Hi is risen!”);</p>
<p>​              Inner3 i = o.makeInner3();</p>
<p>​              System.out.println(i.toString());</p>
<p>​       }</p>
<p>}</p>
<p>interface Selector {</p>
<p>​       boolean end();</p>
<p>​       Object current();</p>
<p>​       void next();</p>
<p>}</p>
<p>public class Sequence4 {</p>
<p>​       private Object[] items;</p>
<p>​       private int next = 0;</p>
<p>​             public void test() { System.out.println(“Sequence4.test()”); }</p>
<p>​       public Sequence4(int size) { items = new Object[size]; }</p>
<p>​       public void add(Object x) {</p>
<p>​              if(next &lt; items.length)</p>
<p>​                     items[next++] = x;</p>
<p>​       }</p>
<p>​       private class SequenceSelector implements Selector {</p>
<p>​              private int i = 0;</p>
<p>​              public boolean end() { return i == items.length; }</p>
<p>​              public Object current() { return items[i]; }</p>
<p>​              public void next() { if(i &lt; items.length) i++; } </p>
<p>​                           public Sequence4 sequence4() { return Sequence4.this; }</p>
<p>​       }</p>
<p>​       public Selector selector() {</p>
<p>​              return new SequenceSelector();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Sequence4 sequence = new Sequence4(10);</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     sequence.add(Integer.toString(i));</p>
<p>​              Selector selector = sequence.selector();</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​                           ((SequenceSelector)selector).sequence4().test();        </p>
<p>​       }</p>
<p>}</p>
<p>class Outer {</p>
<p>​       class Inner { </p>
<p>​              Inner() { System.out.println(“Outer.Inner()”); } </p>
<p>​       }      </p>
<p>}</p>
<p>public class OtherOuter { </p>
<p>​       public static void main(String[] args) {</p>
<p>​                           Outer o = new Outer();</p>
<p>​                           Outer.Inner oi = o.new Inner();                  </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex6 extends Ex6Base {</p>
<p>​       Ex6Interface getBaseInner() { </p>
<p>​              return this.new Ex6BaseInner();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex6 ex = new Ex6();</p>
<p>​              System.out.println(ex.getBaseInner().say());</p>
<p>​       }      </p>
<p>}</p>
<p>class Outer7 {</p>
<p>​       private int oi = 1;</p>
<p>​       private void hi() { System.out.println(“Outer hi”); }</p>
<p>​       class Inner {</p>
<p>​              void modifyOuter() { </p>
<p>​                     oi *= 2;</p>
<p>​                     hi(); </p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void showOi() { System.out.println(oi); }</p>
<p>​       void testInner() {</p>
<p>​              Inner in = new Inner();</p>
<p>​              in.modifyOuter();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer7 out = new Outer7();</p>
<p>​              out.showOi();</p>
<p>​              out.testInner();</p>
<p>​              out.showOi();</p>
<p>​       }</p>
<p>}</p>
<p>class Outer8 { </p>
<p>​       class Inner {</p>
<p>​              private int ii1 = 1;</p>
<p>​              private int ii2 = 2;</p>
<p>​              private void showIi2() { System.out.println(ii2); }</p>
<p>​              private void hi() { System.out.println(“Inner hi”); }</p>
<p>​              }</p>
<p>​             int oi = new Inner().ii1;</p>
<p>​       void showOi() { System.out.println(oi); }</p>
<p>​       void showIi2() { new Inner().showIi2(); } </p>
<p>​       void outerHi() { new Inner().hi(); }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer8 out = new Outer8();</p>
<p>​              out.showOi();</p>
<p>​              out.showIi2();</p>
<p>​              out.outerHi();</p>
<p>​       }</p>
<p>}</p>
<p>interface Ex9Interface {</p>
<p>​       void say(String s); </p>
<p>}</p>
<p>public class Ex9 {   </p>
<p>​       Ex9Interface f() {</p>
<p>​              class Inner implements Ex9Interface {</p>
<p>​                     public void say(String s) {</p>
<p>​                            System.out.println(s); </p>
<p>​                     }</p>
<p>​              }</p>
<p>​              return new Inner();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex9 x = new Ex9();</p>
<p>​              x.f().say(“hi”);</p>
<p>​       } </p>
<p>}</p>
<p>interface Ex10Interface {</p>
<p>​       void say(String s); </p>
<p>}</p>
<p>public class Ex10 { </p>
<p>​       Ex10Interface f(boolean b) {</p>
<p>​              if(b) {</p>
<p>​                     class Inner implements Ex10Interface {</p>
<p>​                            public void say(String s) {</p>
<p>​                                   System.out.println(s); </p>
<p>​                            }</p>
<p>​                     }</p>
<p>​                     return new Inner();</p>
<p>​              }</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex10 x = new Ex10();</p>
<p>​              x.f(true).say(“hi”);</p>
<p>​       } </p>
<p>}</p>
<p>class Test {</p>
<p>​       private class Inner implements Ex11Interface {</p>
<p>​              public void say(String s) {</p>
<p>​                     System.out.println(s); </p>
<p>​              }</p>
<p>​       }</p>
<p>​       Ex11Interface f() {</p>
<p>​              return new Inner();</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex11 { </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Test t = new Test();</p>
<p>​              t.f().say(“hi”);</p>
<p>​                                 } </p>
<p>}</p>
<p>interface Inner12 {</p>
<p>​       void modifyOuter();</p>
<p>}</p>
<p>public class Outer12 {</p>
<p>​       private int oi = 1;</p>
<p>​       private void hi() { System.out.println(“Outer hi”); }</p>
<p>​       public Inner12 inner() {</p>
<p>​              return new Inner12() {</p>
<p>​                     public void modifyOuter() { </p>
<p>​                            oi *= 2;</p>
<p>​                            hi(); </p>
<p>​                     }</p>
<p>​              }; </p>
<p>​       }</p>
<p>​       public void showOi() { System.out.println(oi); }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer12 out = new Outer12();</p>
<p>​              out.showOi();</p>
<p>​              out.inner().modifyOuter();</p>
<p>​              out.showOi();</p>
<p>​       }</p>
<p>}</p>
<p>interface Ex13Interface {</p>
<p>​       String say(String s); </p>
<p>}</p>
<p>public class Outer13 {   </p>
<p>​       Ex13Interface f() {</p>
<p>​              return new Ex13Interface() {</p>
<p>​                     public String say(String s) { return s; }</p>
<p>​              };</p>
<p>​       } </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer13 o = new Outer13();</p>
<p>​              System.out.println(o.f().say(“Hi”));</p>
<p>​       }</p>
<p>}</p>
<p>interface Monster {</p>
<p>​       void menace();</p>
<p>}      </p>
<p>interface DangerousMonster extends Monster {</p>
<p>​       void destroy();</p>
<p>}      </p>
<p>interface Lethal {</p>
<p>​       void kill();</p>
<p>}</p>
<p>class DragonZilla implements DangerousMonster {</p>
<p>​       public void menace() {}</p>
<p>​       public void destroy() {}</p>
<p>}</p>
<p>interface Vampire extends DangerousMonster, Lethal {</p>
<p>​       void drinkBlood();</p>
<p>}</p>
<p>class VeryBadVampire implements Vampire {</p>
<p>​       public void menace() {}</p>
<p>​       public void destroy() {}</p>
<p>​       public void kill() {}</p>
<p>​       public void drinkBlood() {} </p>
<p>}</p>
<p>public class HorrorShow14 {</p>
<p>​       static void u(Monster b) { b.menace(); }</p>
<p>​       static void v(DangerousMonster d) {</p>
<p>​              d.menace();</p>
<p>​              d.destroy();</p>
<p>​       }</p>
<p>​       static void w(Lethal l) { l.kill(); }</p>
<p>​       public DangerousMonster monsterMaker() {</p>
<p>​              return new DangerousMonster() {</p>
<p>​                     public void menace() { println(“DangerousMonster Menace”); }</p>
<p>​                     public void destroy() { println(“DangerousMonster Destroy”); }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public Vampire vampireMaker() {</p>
<p>​              return new Vampire() {</p>
<p>​                     public void menace() { println(“Vampire Menace”); }</p>
<p>​                     public void destroy() { println(“Vampire Destroy”); }</p>
<p>​                     public void kill() { println(“Vampire Kill”); }</p>
<p>​                     public void drinkBlood() { println(“Vampire DrinkBlood”); }</p>
<p>​              };</p>
<p>​       }             </p>
<p>​       public static void main(String[] args) {</p>
<p>​              HorrorShow14 show = new HorrorShow14();</p>
<p>​              show.u(show.monsterMaker());</p>
<p>​              show.v(show.monsterMaker());</p>
<p>​              show.u(show.vampireMaker());</p>
<p>​              show.v(show.vampireMaker());</p>
<p>​              show.w(show.vampireMaker());</p>
<p>​       }</p>
<p>}</p>
<p>class One {</p>
<p>​       private String s;</p>
<p>​       One(String s) { this.s = s; } </p>
<p>​       public String showS() { return s; }</p>
<p>}</p>
<p>public class Ex15 {</p>
<p>​       public One makeOne(String s) {</p>
<p>​              return new One(s) { };</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex15 x = new Ex15();</p>
<p>​              System.out.println(x.makeOne(“hi”).showS());</p>
<p>​       }</p>
<p>}</p>
<p>interface Cycle {</p>
<p>​       void ride();</p>
<p>}</p>
<p>interface CycleFactory {</p>
<p>​       Cycle getCycle();</p>
<p>}</p>
<p>class Unicycle implements Cycle {</p>
<p>​       private Unicycle() { println(“Unicycle()”); }</p>
<p>​       public void ride() { println(“Ride Unicycle”); }</p>
<p>​       public static CycleFactory factory =</p>
<p>​              new CycleFactory() {</p>
<p>​                     public Cycle getCycle() { return new Unicycle(); }</p>
<p>​              };</p>
<p>}</p>
<p>class Bicycle implements Cycle {</p>
<p>​       private Bicycle() { println(“Bicycle()”); }</p>
<p>​       public void ride() { println(“Ride Bicycle”); }</p>
<p>​       public static CycleFactory factory =</p>
<p>​              new CycleFactory() {</p>
<p>​                     public Cycle getCycle() { return new Bicycle(); }</p>
<p>​              };</p>
<p>}</p>
<p>class Tricycle implements Cycle {</p>
<p>​       private Tricycle() { println(“Tricycle()”); }</p>
<p>​       public void ride() { println(“Ride Tricycle”); }</p>
<p>​       public static CycleFactory factory =</p>
<p>​              new CycleFactory() {</p>
<p>​                     public Cycle getCycle() { return new Tricycle(); }</p>
<p>​              }; </p>
<p>}</p>
<p>public class Cycles {</p>
<p>​       public static void rideCycle(CycleFactory factory) {</p>
<p>​              Cycle c = factory.getCycle();</p>
<p>​              c.ride();</p>
<p>​       }</p>
<p>​       public static void main(String [] args) {</p>
<p>​              rideCycle(Unicycle.factory);</p>
<p>​              rideCycle(Bicycle.factory);</p>
<p>​              rideCycle(Tricycle.factory);    </p>
<p>​       }</p>
<p>}</p>
<p>interface Games {</p>
<p>​       void play();</p>
<p>}</p>
<p>interface GamesFactory {</p>
<p>​       Games getGames();</p>
<p>}</p>
<p>class CoinToss implements Games {</p>
<p>​       Random rand = new Random();</p>
<p>​       public void play() { </p>
<p>​              print(“Toss Coin: “);</p>
<p>​              switch(rand.nextInt(2)) {</p>
<p>​                     case 0 : println(“Heads”); return;</p>
<p>​                     case 1 : println(“Tails”); return;</p>
<p>​                     default: println(“OnEdge”); return;</p>
<p>​              } </p>
<p>​       }</p>
<p>​       public static GamesFactory factory =</p>
<p>​              new GamesFactory() {</p>
<p>​                     public Games getGames() { return new CoinToss(); }       </p>
<p>​              };</p>
<p>}</p>
<p>class DiceThrow implements Games {</p>
<p>​       Random rand = new Random();</p>
<p>​       public void play() { </p>
<p>​              print(“Throw Dice: “ + (rand.nextInt(6) + 1));            </p>
<p>​       }</p>
<p>​       public static GamesFactory factory =</p>
<p>​              new GamesFactory() {</p>
<p>​                     public Games getGames() { return new DiceThrow(); }</p>
<p>​              };</p>
<p>}</p>
<p>public class Games17 {</p>
<p>​       public static void playGame(GamesFactory factory) {</p>
<p>​              Games g = factory.getGames();</p>
<p>​              g.play();</p>
<p>​       }</p>
<p>​       public static void main(String [] args) {</p>
<p>​              playGame(CoinToss.factory);</p>
<p>​              playGame(DiceThrow.factory);                  </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex18 {</p>
<p>​       Ex18() { System.out.println(“Ex18()”); }</p>
<p>​       public static class Ex18Nest1 {</p>
<p>​              Ex18Nest1() { System.out.println(“Ex18Nest1()”); }</p>
<p>​       }</p>
<p>​       private static class Ex18Nest2 {</p>
<p>​              Ex18Nest2() { System.out.println(“Ex18Nest2()”); }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex18Nest1 en1 = new Ex18Nest1();</p>
<p>​              Ex18Nest2 en2 = new Ex18Nest2();</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex19 {</p>
<p>​       Ex19() { System.out.println(“Ex19()”); }</p>
<p>​       private class Ex19Inner {</p>
<p>​              Ex19Inner() { System.out.println(“Ex19Inner()”); } </p>
<p>​              private class Ex19InnerInner {</p>
<p>​                     Ex19InnerInner() {</p>
<p>​                            System.out.println(“Ex19InnerInner()”);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       private static class Ex19Nested {</p>
<p>​              Ex19Nested() { System.out.println(“Ex19Nested()”); }</p>
<p>​              private static class Ex19NestedNested {</p>
<p>​                     Ex19NestedNested() { </p>
<p>​                     System.out.println(“Ex19NestedNested()”); </p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }      </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex19Nested en = new Ex19Nested();</p>
<p>​              Ex19Nested.Ex19NestedNested enn = new Ex19Nested.Ex19NestedNested();</p>
<p>​              Ex19 e19 = new Ex19();</p>
<p>​              Ex19.Ex19Inner ei = e19.new Ex19Inner();</p>
<p>​              Ex19.Ex19Inner.Ex19InnerInner eii = ei.new Ex19InnerInner();</p>
<p>​       }</p>
<p>}</p>
<p>interface In {</p>
<p>​       class Nested {</p>
<p>​              Nested() { System.out.println(“Nested()”); }</p>
<p>​              public void hi() { System.out.println(“hi”); }        </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex20 implements In {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              In.Nested in = new In.Nested();</p>
<p>​              in.hi();                          </p>
<p>​       }</p>
<p>}</p>
<p>interface In {</p>
<p>​       String f();</p>
<p>​       String g(); </p>
<p>​       class Nested {</p>
<p>​              static void testIn(In i) { </p>
<p>​                     System.out.println(i.f() + i.g());</p>
<p>​              }             </p>
<p>​       }             </p>
<p>}</p>
<p>public class Ex21 implements In {</p>
<p>​       public String f() { return “hello “; }</p>
<p>​       public String g() { return “friend”; }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex21 x = new Ex21();</p>
<p>​              In.Nested.testIn(x);                                    </p>
<p>​       }</p>
<p>}</p>
<p>interface U {</p>
<p>​       void f();</p>
<p>​       void g();</p>
<p>​       String toString();</p>
<p>}</p>
<p>class A {</p>
<p>​       U buildU() {</p>
<p>​              return new U() {</p>
<p>​                     public void f() { System.out.println(“f()”); }</p>
<p>​                     public void g() { System.out.println(“g()”); }</p>
<p>​                     public String toString() { return “I’m a U”; }</p>
<p>​              };</p>
<p>​       }</p>
<p>}</p>
<p>class B {</p>
<p>​       private U[] us;</p>
<p>​       B(int i) {</p>
<p>​              us = new U[i];</p>
<p>​       }</p>
<p>​       void addU(U u, int i) {</p>
<p>​              us[i] = u;</p>
<p>​       }</p>
<p>​       void eraseU(int i) {</p>
<p>​              us[i] = null;    </p>
<p>​       }</p>
<p>​       void testUs() {</p>
<p>​              for(U u : us) {</p>
<p>​                     u.f();</p>
<p>​                     u.g();</p>
<p>​                     u.toString();</p>
<p>​              }             </p>
<p>​       }</p>
<p>​       void showUs() {</p>
<p>​              for(U u : us) { </p>
<p>​                     if(u != null) System.out.println(u.toString());</p>
<p>​                     else System.out.println(“I’m null”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex23 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              A a0 = new A();</p>
<p>​              A a1 = new A();</p>
<p>​              A a2 = new A();</p>
<p>​              B b = new B(3);</p>
<p>​              b.addU(a0.buildU(), 0);</p>
<p>​              b.addU(a1.buildU(), 1);</p>
<p>​              b.addU(a2.buildU(), 2);</p>
<p>​              b.showUs();</p>
<p>​              b.testUs();</p>
<p>​              b.eraseU(0);</p>
<p>​              b.eraseU(1);</p>
<p>​              b.showUs();</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseController24 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls24 gc = new GreenhouseControls24();</p>
<p>​                                        gc.addEvent(gc.new Bell(900));</p>
<p>​              Event[] eventList = {</p>
<p>​                     gc.new ThermostatNight(0),</p>
<p>​                     gc.new LightOn(200),</p>
<p>​                     gc.new FanOn(300),</p>
<p>​                     gc.new LightOff(400),</p>
<p>​                     gc.new FanOff(500),</p>
<p>​                     gc.new WaterOn(600),</p>
<p>​                     gc.new WaterOff(800),</p>
<p>​                     gc.new ThermostatDay(1400),</p>
<p>​              };</p>
<p>​              gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​              if(args.length == 1)</p>
<p>​                     gc.addEvent(</p>
<p>​                            new GreenhouseControls24.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseControls24 extends Controller {</p>
<p>​       private boolean fan = false;</p>
<p>​       public class FanOn extends Event {</p>
<p>​              public FanOn(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             fan = true;</p>
<p>​              }</p>
<p>​              public String toString() { return “Fan is on”; }</p>
<p>​       }</p>
<p>​       public class FanOff extends Event {</p>
<p>​              public FanOff(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             fan = false;</p>
<p>​              }</p>
<p>​              public String toString() { return “Fan is off”; }</p>
<p>​       }</p>
<p>​       private boolean light = false;</p>
<p>​       public class LightOn extends Event {</p>
<p>​              public LightOn(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             light = true;</p>
<p>​              }</p>
<p>​              public String toString() { return “Light is on”; }</p>
<p>​       }</p>
<p>​       public class LightOff extends Event {</p>
<p>​              public LightOff(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             light = false;</p>
<p>​              }</p>
<p>​              public String toString() { return “Light is off”; }</p>
<p>​       }</p>
<p>​       private boolean water = false;</p>
<p>​       public class WaterOn extends Event {</p>
<p>​              public WaterOn(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                         water = true;</p>
<p>​              }</p>
<p>​              public String toString() { </p>
<p>​                     return “Greenhouse water is on”;</p>
<p>​              } </p>
<p>​       }</p>
<p>​       public class WaterOff extends Event {</p>
<p>​              public WaterOff(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                         water = false;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Greenhouse water is off”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       private String thermostat = “Day”;</p>
<p>​       public class ThermostatNight extends Event {</p>
<p>​              public ThermostatNight(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                                         thermostat = “Night”;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Thermostat on night setting”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public class ThermostatDay extends Event {</p>
<p>​              public ThermostatDay(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }      </p>
<p>​              public void action() {</p>
<p>​                                         thermostat = “Day”;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Thermostat on day setting”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​                   public class Bell extends Event {</p>
<p>​              public Bell(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                     addEvent(new Bell(delayTime));</p>
<p>​              }</p>
<p>​              public String toString() { return “Bing!”; }</p>
<p>​       }</p>
<p>​       public class Restart extends Event {</p>
<p>​              private Event[] eventList;</p>
<p>​              public Restart(long delayTime, Event[] eventList) {</p>
<p>​                     super(delayTime);</p>
<p>​                     this.eventList = eventList;</p>
<p>​                     for(Event e : eventList)</p>
<p>​                            addEvent(e);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                     for(Event e : eventList) {</p>
<p>​                            e.start();                             addEvent(e);</p>
<p>​                     }</p>
<p>​                     start();                 addEvent(this);</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Restarting system”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static class Terminate extends Event {</p>
<p>​              public Terminate(long delayTime) { super(delayTime); }</p>
<p>​              public void action() { System.exit(0); }</p>
<p>​              public String toString() { return “Terminating”; }</p>
<p>​       }</p>
<p>}      </p>
<p>public class GreenhouseController25 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls25 gc = new GreenhouseControls25();</p>
<p>​                                        gc.addEvent(gc.new Bell(900));</p>
<p>​              Event[] eventList = {</p>
<p>​                     gc.new ThermostatNight(0),</p>
<p>​                     gc.new LightOn(200),</p>
<p>​                     gc.new LightOff(400),</p>
<p>​                     gc.new WaterOn(600),</p>
<p>​                     gc.new WaterMistOn(650),</p>
<p>​                     gc.new WaterMistOff(700),</p>
<p>​                     gc.new WaterOff(800),</p>
<p>​                     gc.new ThermostatDay(1400),</p>
<p>​              };</p>
<p>​              gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​              if(args.length == 1)</p>
<p>​                     gc.addEvent(</p>
<p>​                            new GreenhouseControls.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseControls25 extends GreenhouseControls {</p>
<p>​       private boolean waterMist = false;</p>
<p>​       public class WaterMistOn extends Event {</p>
<p>​              public WaterMistOn(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                                                             waterMist = true;</p>
<p>​              }</p>
<p>​              public String toString() { </p>
<p>​                     return “Water mist generator on”;  </p>
<p>​              }</p>
<p>​       }      </p>
<p>​       public class WaterMistOff extends Event {</p>
<p>​              public WaterMistOff(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                                                             waterMist = false;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Water mist generator off”;</p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>class FirstOuter {</p>
<p>​       public class FirstInner {</p>
<p>​              FirstInner(String s) { </p>
<p>​                     System.out.println(“FirstOuter.FirstInner() “ + s ); </p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class SecondOuter {</p>
<p>​       public class SecondInner extends FirstOuter.FirstInner {</p>
<p>​              SecondInner(FirstOuter x) { </p>
<p>​                     x.super(“hello”); </p>
<p>​                     System.out.println(“SecondOuter.SecondInner()”); </p>
<p>​              }             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              FirstOuter fo = new FirstOuter();</p>
<p>​              SecondOuter so = new SecondOuter();</p>
<p>​              SecondInner si = so.new SecondInner(fo);        </p>
<p>​       }      </p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解IO/" itemprop="url">Java题解IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第十八章-IO"><a href="#第十八章-IO" class="headerlink" title="第十八章 IO"></a>第十八章 IO</h2><p>public class DirList1a {         </p>
<p>​       public static void main(final String[] args) {</p>
<p>​              File path = new File(“.”);</p>
<p>​              final String[] list;</p>
<p>​              if(args.length &lt; 2) { </p>
<p>​                     list = path.list();</p>
<p>​                     System.out.println(“Usage: enter filtering regex”);</p>
<p>​                     System.out.println(</p>
<p>​                     “followed by words, one or more of which each file must contain.”);</p>
<p>​              }</p>
<p>​              else {</p>
<p>​                     list = path.list(new FilenameFilter() {</p>
<p>​                            private Pattern pattern = Pattern.compile(args[0]);</p>
<p>​                            public boolean accept(File dir, String name) {</p>
<p>​                                   return pattern.matcher(name).matches() &amp;&amp;</p>
<p>​                                   !(Collections.disjoint(</p>
<p>​                                          Arrays.asList(args).subList(1, args.length),</p>
<p>​                                          new TextFile(name, “\W+”)</p>
<p>​                                   ));</p>
<p>​                            }</p>
<p>​                     });</p>
<p>​              }</p>
<p>​              Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</p>
<p>​              for(String dirItem : list)</p>
<p>​                     System.out.println(dirItem);</p>
<p>​       }</p>
<p>}</p>
<p>public class DirList1b {         </p>
<p>​       public static void main(final String[] args) {</p>
<p>​              File path = new File(“.”);</p>
<p>​              final String[] list;</p>
<p>​              if(args.length == 0) { </p>
<p>​                     list = path.list();</p>
<p>​                     System.out.println(</p>
<p>​                            “Usage: enter words, one or more of which each file must contain”);</p>
<p>​              }</p>
<p>​              else {</p>
<p>​                     list = path.list(new FilenameFilter() {</p>
<p>​                            public boolean accept(File dir, String name) {</p>
<p>​                                   return !(Collections.disjoint(</p>
<p>​                                                 Arrays.asList(args),</p>
<p>​                                                 new TextFile(name, “\W+”)</p>
<p>​                                          )</p>
<p>​                                   );</p>
<p>​                            }</p>
<p>​                     });</p>
<p>​              }</p>
<p>​              Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</p>
<p>​              for(String dirItem : list)</p>
<p>​                     System.out.println(dirItem);</p>
<p>​       }</p>
<p>}</p>
<p>public class SortedDirList2 {</p>
<p>​       private String[] dirList;</p>
<p>​       public SortedDirList2(File dir) {</p>
<p>​              dirList = dir.list();</p>
<p>​              Arrays.sort(dirList, String.CASE_INSENSITIVE_ORDER);</p>
<p>​       }</p>
<p>​       public String[] list() { return dirList; }</p>
<p>​       public String[] list(String regex) {</p>
<p>​              Pattern pattern = Pattern.compile(regex);</p>
<p>​              ArrayList<string> slist = new ArrayList<string>();</string></string></p>
<p>​              int count = 0;</p>
<p>​              for(String s : dirList) {</p>
<p>​                     if(pattern.matcher(s).matches()) {</p>
<p>​                            count++;</p>
<p>​                            slist.add(s);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              return slist.toArray(new String[count]);</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              StringBuilder sb = new StringBuilder();</p>
<p>​              for(String s : dirList) sb.append(s + ‘\n’);</p>
<p>​              return sb.toString();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              SortedDirList2 dirList = new SortedDirList2(new File(“.”));</p>
<p>​              System.out.println(dirList);</p>
<p>​              for(String s : dirList.list()) </p>
<p>​                     System.out.println(s);</p>
<p>​              System.out.println();</p>
<p>​              for(String s : dirList.list(“.+\.java”))</p>
<p>​                     System.out.println(s);</p>
<p>​       }</p>
<p>}</p>
<p>public class DirListFileSizes { </p>
<p>​       public static void main(final String[] args) {</p>
<p>​              File path = new File(“.”);</p>
<p>​              File[] files;</p>
<p>​              if(args.length == 0)</p>
<p>​                    files = path.listFiles(); </p>
<p>​              else</p>
<p>​                     files = path.listFiles(new FileFilter() {</p>
<p>​                            private Pattern pattern = Pattern.compile(args[0]);</p>
<p>​                            public boolean accept(File file) {</p>
<p>​                                   return pattern.matcher(file.getPath()).matches();</p>
<p>​                            }</p>
<p>​                     });</p>
<p>​              Arrays.sort(files);</p>
<p>​              long sum = 0;</p>
<p>​              for(File f : files) {</p>
<p>​                     System.out.print(f + “: “);</p>
<p>​                     System.out.println(f.length());</p>
<p>​                     sum += f.length();</p>
<p>​              }</p>
<p>​              System.out.println(“Total size: “ + sum);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex4 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              long sum = 0;</p>
<p>​              if(args.length == 0) {</p>
<p>​                     for(File file : Directory.walk(“.”).files) {</p>
<p>​                            System.out.print(file + “: “);</p>
<p>​                            System.out.println(file.length());</p>
<p>​                            sum += file.length();</p>
<p>​                     }</p>
<p>​                     </p>
<p>​              }</p>
<p>​              else </p>
<p>​                     for(String arg : args) {</p>
<p>​                            {</p>
<p>​                            for(File file : Directory.walk(“.”, arg).files) {</p>
<p>​                                   System.out.print(file + “: “);</p>
<p>​                                   System.out.println(file.length());</p>
<p>​                                   sum += file.length();</p>
<p>​                            }</p>
<p>​                            System.out.println();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              System.out.println(“Total size: “ + sum);</p>
<p>​       }</p>
<p>}</p>
<p>public class ProcessFiles5 {</p>
<p>​       public interface Strategy {</p>
<p>​                  void process(File file);</p>
<p>​      }</p>
<p>​      private Strategy strategy;</p>
<p>​      private String regex;</p>
<p>​       public ProcessFiles5(Strategy strategy, String regex) {</p>
<p>​                  this.strategy = strategy;</p>
<p>​           this.regex = regex;</p>
<p>​      }</p>
<p>​      public void start(String[] args) {</p>
<p>​                  try {</p>
<p>​                        if(args.length == 0)</p>
<p>​                      processDirectoryTree(new File(“.”));</p>
<p>​                 else</p>
<p>​                      for(String arg : args) {</p>
<p>​                            File fileArg = new File(arg);</p>
<p>​                            if(fileArg.isDirectory())</p>
<p>​                                        processDirectoryTree(fileArg);</p>
<p>​                            else {</p>
<p>​                                   Pattern pattern = Pattern.compile(regex);</p>
<p>​                                   if(pattern.matcher(arg).matches())                                                    strategy.process(</p>
<p>​                                                     new File(arg).getCanonicalFile());</p>
<p>​                            }</p>
<p>​                      }</p>
<p>​                  } catch(IOException e) {</p>
<p>​                        throw new RuntimeException(e);</p>
<p>​                  }</p>
<p>​      }</p>
<p>​      public void processDirectoryTree(File root) throws IOException {</p>
<p>​                  for(File file : Directory.walk(</p>
<p>​                      root.getAbsolutePath(), regex))</p>
<p>​                 strategy.process(file.getCanonicalFile());</p>
<p>​      }</p>
<p>​           public static void main(String[] args) {</p>
<p>​                  new ProcessFiles5(new ProcessFiles5.Strategy() {</p>
<p>​                        public void process(File file) {</p>
<p>​                             System.out.println(file);</p>
<p>​                        }</p>
<p>​                  }, “.<em>D.</em>“).start(args);</p>
<p>​      }</p>
<p>} </p>
<p>public class ModifiedAfter6 {</p>
<p>​       public static void main(final String[] args) {</p>
<p>​              if(args.length != 2) {</p>
<p>​                     System.out.println(“Usage: directory date(mm                      System.out.println(“(Outputs a listing of all java files in the given directory” +</p>
<p>​                            “\nthat were last modified on or after the given date.)”);</p>
<p>​                     return;</p>
<p>​              }</p>
<p>​              final SimpleDateFormat sdf = new SimpleDateFormat(“MM        new ProcessFiles(new ProcessFiles.Strategy() {</p>
<p>​                     public void process(File file) {</p>
<p>​                            Date modDate = new Date(file.lastModified());</p>
<p>​                            try {</p>
<p>​                                   if(modDate.after(sdf.parse(args[1])))</p>
<p>​                                          System.out.println(file);</p>
<p>​                            } catch(ParseException e) {</p>
<p>​                                   System.out.println(e.getMessage());</p>
<p>​                            }</p>
<p>​                     }</p>
<p>​              }, “java”).start(args);</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLines7 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)</p>
<p>​                     list.add(s);            while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);               in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              System.out.print(readAndReverse(“ReverseLines7.java”));</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLines8 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)</p>
<p>​                     list.add(s);            while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);               in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length != 1) {</p>
<p>​                     System.out.println(“Usage: enter file name”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.print(readAndReverse(args[0]));</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLines9 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)</p>
<p>​                     list.add(s.toUpperCase());          while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);            in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length != 1) {</p>
<p>​                     System.out.println(“Usage: enter file name”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.print(readAndReverse(args[0]));</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLinesWordSearch10 {</p>
<p>​             public static String readReverseFind(String[] sa) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(sa[0]));</p>
<p>​              String s;</p>
<p>​              List<string> find = new ArrayList<string>();</string></string></p>
<p>​              for(String t : sa) find.add(t);</p>
<p>​              find.remove(0);           LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null) {</p>
<p>​                                         List<string> line = Arrays.asList(s.split(“\W+”));</string></p>
<p>​                                         if(!(Collections.disjoint(line, find))) </p>
<p>​                            list.add(s);            }</p>
<p>​              while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);               in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length &lt; 2) {</p>
<p>​                     System.out.println(“Usage: enter file name\n” +</p>
<p>​                            “followed by words to find in lines of that file”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.print(readReverseFind(args));</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseController11 {</p>
<p>​             public static Map&lt;String,Long&gt; readEvents(String filename) </p>
<p>​       throws IOException {</p>
<p>​              BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              Map&lt;String,Long&gt; map = new HashMap&lt;String,Long&gt;();</p>
<p>​              while((s = in.readLine()) != null) {</p>
<p>​                     String [] sa = s.split(“[()]”);</p>
<p>​                     map.put(sa[0], new Long(sa[1]));</p>
<p>​              }</p>
<p>​              in.close();</p>
<p>​              return map;</p>
<p>​       }</p>
<p>​             private static Event makeEvent(GreenhouseControls gc, Map.Entry&lt;String,Long&gt; me) {</p>
<p>​              String key = me.getKey();</p>
<p>​              Long value = me.getValue();</p>
<p>​              if(key.equals(“Bell”)) return gc.new Bell(value);</p>
<p>​              if(key.equals(“LightOn”)) return gc.new LightOn(value);</p>
<p>​              if(key.equals(“LightOff”)) return gc.new LightOff(value);</p>
<p>​              if(key.equals(“WaterOn”)) return gc.new WaterOn(value);</p>
<p>​              if(key.equals(“WaterOff”)) return gc.new WaterOff(value);</p>
<p>​              if(key.equals(“ThermostatDay”)) return gc.new ThermostatDay(value);</p>
<p>​              if(key.equals(“ThermostatNight”)) return gc.new ThermostatNight(value);</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls gc = new GreenhouseControls();</p>
<p>​                                        try {</p>
<p>​                                         Map&lt;String,Long&gt; map = readEvents(“Events.txt”);</p>
<p>​                     Event[] eventList = new Event[map.size()];</p>
<p>​                     int i = 0;</p>
<p>​                                         for(Map.Entry&lt;String,Long&gt; me : map.entrySet()) {</p>
<p>​                            eventList[i++] = makeEvent(gc, me);</p>
<p>​                     }</p>
<p>​                     gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​                     if(args.length != 1) {</p>
<p>​                            System.out.println(“Usage: enter integer terminate time”);</p>
<p>​                            System.exit(0);</p>
<p>​                     }</p>
<p>​                     if(args.length == 1)</p>
<p>​                            gc.addEvent(new GreenhouseControls.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }      </p>
<p>​       }      </p>
<p>}</p>
<p>interface EventFactory {</p>
<p>​       Event getEvent(GreenhouseControls gc, Long time);</p>
<p>}</p>
<p>class BellFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new Bell(time);</p>
<p>​       }</p>
<p>}</p>
<p>class LightOnFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new LightOn(time);</p>
<p>​       }</p>
<p>}</p>
<p>class LightOffFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new LightOff(time);</p>
<p>​       }</p>
<p>}</p>
<p>class WaterOnFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new WaterOn(time);</p>
<p>​       }</p>
<p>}</p>
<p>class WaterOffFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new WaterOff(time);</p>
<p>​       }</p>
<p>}</p>
<p>class ThermostatDayFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new ThermostatDay(time);</p>
<p>​       }</p>
<p>}</p>
<p>class ThermostatNightFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new ThermostatNight(time);</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseController11b {</p>
<p>​             public static Map&lt;String,Long&gt; readEvents(String filename) </p>
<p>​       throws IOException {</p>
<p>​              BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              Map&lt;String,Long&gt; map = new HashMap&lt;String,Long&gt;();</p>
<p>​              while((s = in.readLine()) != null) {</p>
<p>​                     String [] sa = s.split(“[()]”);</p>
<p>​                     map.put(sa[0], new Long(sa[1]));</p>
<p>​              }</p>
<p>​              in.close();</p>
<p>​              return map;</p>
<p>​       }</p>
<p>​             private static Event makeEvent(GreenhouseControls gc, Map.Entry&lt;String,Long&gt; me) {</p>
<p>​              String key = me.getKey();</p>
<p>​              Long value = me.getValue();</p>
<p>​              if(key.equals(“Bell”)) return new BellFactory().getEvent(gc,value);</p>
<p>​              if(key.equals(“LightOn”)) return new LightOnFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“LightOff”)) return new LightOffFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“WaterOn”)) return new WaterOnFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“WaterOff”)) return new WaterOffFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“ThermostatDay”)) </p>
<p>​                     return new ThermostatDayFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“ThermostatNight”)) </p>
<p>​                     return new ThermostatNightFactory().getEvent(gc, value);</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls gc = new GreenhouseControls();</p>
<p>​                                        try {</p>
<p>​                                         Map&lt;String,Long&gt; map = readEvents(“Events.txt”);</p>
<p>​                     Event[] eventList = new Event[map.size()];</p>
<p>​                     int i = 0;</p>
<p>​                                         for(Map.Entry&lt;String,Long&gt; me : map.entrySet()) {</p>
<p>​                            eventList[i++] = makeEvent(gc, me);</p>
<p>​                     }</p>
<p>​                     gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​                     if(args.length != 1) {</p>
<p>​                            System.out.println(“Usage: enter integer terminate time”);</p>
<p>​                            System.exit(0);</p>
<p>​                     }</p>
<p>​                     if(args.length == 1)</p>
<p>​                            gc.addEvent(new GreenhouseControls.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }      </p>
<p>​       }      </p>
<p>}</p>
<p>public class ReverseLines12 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           String[] temp = filename.split(“\.”);</p>
<p>​              String file = temp[0] + “Reversed.” + temp[1]; </p>
<p>​              PrintWriter out = new PrintWriter(file);            int lineCount = 1;</p>
<p>​              while((s = in.readLine()) != null)</p>
<p>​                                         list.add(lineCount++ + “ “ + s); </p>
<p>​              while(list.peekLast() != null) {                   String t = list.pollLast();                    out.println(t);</p>
<p>​                     sb.append(t + “\n”); </p>
<p>​              }</p>
<p>​              in.close();</p>
<p>​              out.close();          return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length != 1) {</p>
<p>​                     System.out.println(“Usage: enter file name”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.println(readAndReverse(args[0]));</p>
<p>​       }</p>
<p>}</p>
<p>public class BasicFileOutput13 {</p>
<p>​       static String file = “BasicFileOutput13.out”;</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              LineNumberReader in = new LineNumberReader(</p>
<p>​                     new FileReader(“BasicFileOutput13.java”));</p>
<p>​              PrintWriter out = new PrintWriter(file);</p>
<p>​              String s;</p>
<p>​              while((s = in.readLine()) != null )</p>
<p>​                     out.println(in.getLineNumber() + “: “ + s);</p>
<p>​              out.close();</p>
<p>​                           System.out.println(BufferedInputFile.read(file));</p>
<p>​       }             </p>
<p>}</p>
<p>public class BasicFileOutput14 {</p>
<p>​       static String file = “BasicFileOutput14.out”;</p>
<p>​       static String file2 = “BasicFileOutput142.out”;</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              BufferedReader in = new BufferedReader(</p>
<p>​                     new StringReader(</p>
<p>​                            BufferedInputFile.read(“BasicFileOutput14.java”)));</p>
<p>​                           PrintWriter out = new PrintWriter(</p>
<p>​                     new BufferedWriter(new FileWriter(file)));</p>
<p>​              int lineCount = 1;</p>
<p>​              String s;</p>
<p>​              long start = System.nanoTime();</p>
<p>​              while((s = in.readLine()) != null )</p>
<p>​                     out.println(lineCount++ + “: “ + s);</p>
<p>​              long duration = System.nanoTime() - start;</p>
<p>​              out.close();</p>
<p>​              System.out.println(“Buffered write:   “ + duration + “ nanoseconds”);</p>
<p>​              BufferedReader in2 = new BufferedReader(</p>
<p>​                     new StringReader(</p>
<p>​                            BufferedInputFile.read(“BasicFileOutput14.java”)));</p>
<p>​                           PrintWriter out2 = new PrintWriter(new FileWriter(file2));</p>
<p>​              int lineCount2 = 1;</p>
<p>​              String s2;</p>
<p>​              long start2 = System.nanoTime();</p>
<p>​              while((s2 = in2.readLine()) != null )</p>
<p>​                     out2.println(lineCount2++ + “: “ + s2);</p>
<p>​              long duration2 = System.nanoTime() - start2;</p>
<p>​              out2.close();</p>
<p>​              System.out.println(“Unbuffered write: “ + duration2 + “ nanoseconds”);</p>
<p>​                           System.out.println(“file: “ + BufferedInputFile.read(file));</p>
<p>​              System.out.println(“file2: “ + BufferedInputFile.read(file2));</p>
<p>​       }             </p>
<p>}</p>
<p>public class StoringAndRecoveringData15 {</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              DataOutputStream out = new DataOutputStream(</p>
<p>​                     new BufferedOutputStream(</p>
<p>​                            new FileOutputStream(“Data.txt”)));</p>
<p>​              println(“Initial out.size() = “ + out.size());</p>
<p>​              byte[] ba = {0,1,2,3};</p>
<p>​                           out.write(ba,0,3);</p>
<p>​                           out.write(ba);</p>
<p>​              out.write((int)255);             out.writeBoolean(true);</p>
<p>​              out.writeByte((int)1000000);</p>
<p>​              out.writeBytes((String)”hi”);</p>
<p>​              out.writeChar(120);</p>
<p>​              out.writeChars(“hi”);            </p>
<p>​              out.writeDouble(3.14159);</p>
<p>​              out.writeFloat(2.1f);</p>
<p>​              out.writeInt(1057);</p>
<p>​              out.writeLong(123456789L);</p>
<p>​              out.writeShort(123);</p>
<p>​              out.writeUTF(“Nice piece of work”);</p>
<p>​              println(“After writing, out.size() = “ + out.size());              </p>
<p>​              out.close();</p>
<p>​              println(“Reading:”);</p>
<p>​              DataInputStream in = new DataInputStream(</p>
<p>​                     new BufferedInputStream(</p>
<p>​                            new FileInputStream(“Data.txt”)));</p>
<p>​              byte[] baIn = new byte[3];</p>
<p>​              println(“bytes read by in.read(baIn, 0, 3) = “ + in.read(baIn, 0, 3));</p>
<p>​              print(“baIn = “);</p>
<p>​              for(int i = 0; i &lt; baIn.length; i++)</p>
<p>​                     print(baIn[i] + “ “);</p>
<p>​              println();</p>
<p>​                           println(“in.readInt() = “ + in.readInt());</p>
<p>​              println(“in.read() = “ + in.read());        </p>
<p>​              println(“in.readBoolean() = “ + in.readBoolean());            </p>
<p>​              println(“in.readByte() = “ + in.readByte());         </p>
<p>​              println(“in.read() = “ + in.read());             println(“in.read() = “ + in.read());             println(“in.readChar() = “ + in.readChar());</p>
<p>​              println(“in.readChar() = “ + in.readChar());</p>
<p>​              println(“in.readChar() = “ + in.readChar());</p>
<p>​              println(“in.readDouble() = “ + in.readDouble());</p>
<p>​              println(“in.readFloat() = “ + in.readFloat());</p>
<p>​              println(“in.readInt() = “ + in.readInt());</p>
<p>​              println(“in.readLong() = “ + in.readLong());</p>
<p>​              println(“in.readShort() = “ + in.readShort());</p>
<p>​              println(“in.readUTF() = “ + in.readUTF());          </p>
<p>​       }</p>
<p>}</p>
<p>public class UsingRandomAccessFile16 {</p>
<p>​       static String file = “r16test.dat”;</p>
<p>​       static void display() throws IOException {</p>
<p>​              RandomAccessFile rf = new RandomAccessFile(file, “r”);</p>
<p>​              byte[] bIn = new byte[3];</p>
<p>​              rf.read(bIn);</p>
<p>​              for(int i = 0; i &lt; bIn.length; i++)</p>
<p>​                     print(bIn[i] + “ “);</p>
<p>​              println();</p>
<p>​                           println(“rf.readInt() = “ + rf.readInt());</p>
<p>​              println(“rf.read() = “ + rf.read());         </p>
<p>​              println(“rf.readBoolean() = “ + rf.readBoolean());             </p>
<p>​              println(“rf.readByte() = “ + rf.readByte());          </p>
<p>​              println(“rf.read() = “ + rf.read());              println(“rf.read() = “ + rf.read());              println(“rf.readChar() = “ + rf.readChar());</p>
<p>​              println(“rf.readChar() = “ + rf.readChar());</p>
<p>​              println(“rf.readChar() = “ + rf.readChar());</p>
<p>​              println(“rf.readDouble() = “ + rf.readDouble());</p>
<p>​              println(“rf.readFloat() = “ + rf.readFloat());</p>
<p>​              println(“rf.readInt() = “ + rf.readInt());</p>
<p>​              println(“rf.readLong() = “ + rf.readLong());</p>
<p>​              println(“rf.readShort() = “ + rf.readShort());</p>
<p>​              println(“rf.readUTF() = “ + rf.readUTF());</p>
<p>​              rf.close();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {     </p>
<p>​              RandomAccessFile rf = new RandomAccessFile(file, “rw”);</p>
<p>​              byte[] ba = {0,1,2,3};</p>
<p>​                           rf.write(ba,0,3);</p>
<p>​                           rf.write(ba);</p>
<p>​              rf.write((int)255);                rf.writeBoolean(true);</p>
<p>​              rf.writeByte((int)1000000);</p>
<p>​              rf.writeBytes((String)”hi”);</p>
<p>​              rf.writeChar(120);</p>
<p>​              rf.writeChars(“hi”);        </p>
<p>​              rf.writeDouble(3.14159);</p>
<p>​              rf.writeFloat(2.1f);</p>
<p>​              rf.writeInt(1057);</p>
<p>​              rf.writeLong(123456789L);</p>
<p>​              rf.writeShort(123);</p>
<p>​              rf.writeUTF(“Nice piece of work”);              </p>
<p>​              display();        </p>
<p>​       }</p>
<p>}</p>
<p>public class CharCounter {</p>
<p>​       </p>
<p>​       public static void main(String[] args) {</p>
<p>​                           String fileName = “CharCounter.java”;</p>
<p>​                           char[] ca = read(fileName).toCharArray();</p>
<p>​                           Set<character> charSet = new TreeSet<character>();    </character></character></p>
<p>​              for(char c : ca) charSet.add(c);                       List<character> charList = new ArrayList<character>();</character></character></p>
<p>​              for(char c : ca) charList.add(c);</p>
<p>​              Map&lt;Character,Integer&gt; charMap = new HashMap&lt;Character,Integer&gt;();</p>
<p>​              for(Character c : charSet) {</p>
<p>​                     int count = 0;</p>
<p>​                     for(Character d : charList) {</p>
<p>​                            if(d.equals(c)) count++;</p>
<p>​                     }</p>
<p>​                     charMap.put(c, count);</p>
<p>​              }  </p>
<p>​              print();</p>
<p>​              print(charMap);            </p>
<p>​       }</p>
<p>}</p>
<p>public class TextFile18 extends ArrayList<string> {</string></p>
<p>​            public static String read(String fileName) throws IOException {</p>
<p>​                  StringBuilder sb = new StringBuilder();</p>
<p>​                  BufferedReader in = new BufferedReader(new FileReader(</p>
<p>​                      new File(fileName).getAbsoluteFile()));</p>
<p>​                 try {</p>
<p>​                      String s;</p>
<p>​                      while((s = in.readLine()) != null) {</p>
<p>​                            sb.append(s);</p>
<p>​                            sb.append(“\n”);</p>
<p>​                      }</p>
<p>​                 } finally {</p>
<p>​                      in.close();</p>
<p>​                 }</p>
<p>​                  return sb.toString();</p>
<p>​      }</p>
<p>​           public static void write(String fileName, String text) throws IOException {</p>
<p>​                  PrintWriter out = new PrintWriter(</p>
<p>​                      new File(fileName).getAbsoluteFile());</p>
<p>​                 try {</p>
<p>​                      out.print(text);</p>
<p>​                 } finally {</p>
<p>​                      out.close();</p>
<p>​                 }</p>
<p>​           }</p>
<p>​           public TextFile18(String fileName, String splitter) throws IOException {</p>
<p>​                  super(Arrays.asList(read(fileName).split(splitter)));</p>
<p>​                                                    if(get(0).equals(“”)) remove(0);</p>
<p>​      }</p>
<p>​           public TextFile18(String fileName) throws IOException {</p>
<p>​                  this(fileName, “\n”);</p>
<p>​      }</p>
<p>​      public void write(String fileName) throws IOException {</p>
<p>​                  PrintWriter out = new PrintWriter(</p>
<p>​                      new File(fileName).getAbsoluteFile());</p>
<p>​                 try {</p>
<p>​                      for(String item : this)</p>
<p>​                     out.println(item);</p>
<p>​                 } finally {</p>
<p>​                      out.close();</p>
<p>​                 }</p>
<p>​           }</p>
<p>​           public static void main(String[] args) {</p>
<p>​              try {</p>
<p>​                         String file = read(“TextFile18.java”);</p>
<p>​                         write(“test.txt”, file);</p>
<p>​                         TextFile18 text = new TextFile18(“test.txt”);</p>
<p>​                         text.write(“test2.txt”);</p>
<p>​                                                 TreeSet<string> words = new TreeSet<string>(</string></string></p>
<p>​                               new TextFile18(“TextFile18.java”, “\W+”));               </p>
<p>​                                                 System.out.println(words.headSet(“a”));</p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.err.println(“Caught “ + e);</p>
<p>​                     e.printStackTrace();</p>
<p>​              }</p>
<p>​      }</p>
<p>} </p>
<p>public class ByteCounter19 {       </p>
<p>​       public static void main(String[] args) {</p>
<p>​                           String fileName = “ByteCounter19.java”;</p>
<p>​              try {</p>
<p>​                                         byte[] ba = read(fileName);         </p>
<p>​                                         Set<byte> byteSet = new TreeSet<byte>();      </byte></byte></p>
<p>​                     for(Byte b : ba) byteSet.add(b);                                           List<byte> byteList = new ArrayList<byte>();</byte></byte></p>
<p>​                     for(byte b : ba) byteList.add(b);</p>
<p>​                     Map&lt;Byte,Integer&gt; byteMap = new HashMap&lt;Byte,Integer&gt;();</p>
<p>​                     for(Byte b : byteSet) {</p>
<p>​                            int count = 0;</p>
<p>​                            for(Byte d : byteList) {</p>
<p>​                                   if(d.equals(b)) count++;</p>
<p>​                            }</p>
<p>​                     byteMap.put(b, count);</p>
<p>​                     }  </p>
<p>​                     print();</p>
<p>​                     print(byteMap);     </p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.err.print(“Caught “ + e);</p>
<p>​              } </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex20 {</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              for(File file : Directory.walk(“.”, “.*\.class”).files) {</p>
<p>​                     byte[] ba = read(file);</p>
<p>​                     for(int i = 0; i &lt; 4; i++)</p>
<p>​                            print(Integer.toHexString(ba[i] &amp; 0xff).toUpperCase());</p>
<p>​                     println();</p>
<p>​              }             </p>
<p>​       } </p>
<p>}</p>
<p>public class Ex21 {</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              File file = new File(“Ex21.java”);</p>
<p>​              BufferedInputStream inFile = </p>
<p>​                     new BufferedInputStream(new</p>
<p>​                            FileInputStream(file));</p>
<p>​              System.setIn(inFile);             </p>
<p>​              BufferedReader stdin = new BufferedReader(</p>
<p>​                     new InputStreamReader(System.in));</p>
<p>​              String s;</p>
<p>​              while((s = stdin.readLine()) != null)</p>
<p>​                     System.out.println(s.toUpperCase());          </p>
<p>​       }</p>
<p>}</p>
<p>class OSExecute22Exception extends RuntimeException {</p>
<p>​       public OSExecute22Exception(String s) { super(s); }</p>
<p>}</p>
<p>class OSExecute22 {</p>
<p>​       public static List<string> command(String command) {</string></p>
<p>​              boolean err = false;</p>
<p>​              List<string> ls = new ArrayList<string>(); </string></string></p>
<p>​              try {</p>
<p>​                     Process process = new ProcessBuilder(</p>
<p>​                            command.split(“ “)).start();</p>
<p>​                     BufferedReader results = new BufferedReader(</p>
<p>​                            new InputStreamReader(process.getInputStream()));</p>
<p>​                     String s;                </p>
<p>​                     while((s = results.readLine()) != null) {</p>
<p>​                            ls.add(s);</p>
<p>​                     }</p>
<p>​                     BufferedReader errors = new BufferedReader(</p>
<p>​                            new InputStreamReader(process.getErrorStream()));</p>
<p>​                                                             while((s = errors.readLine()) != null) { </p>
<p>​                            System.err.println(s);</p>
<p>​                            err = true;</p>
<p>​                     }</p>
<p>​              } catch(Exception e) {</p>
<p>​                                                             if(!command.startsWith(“CMD                        command(“CMD                       else</p>
<p>​                            throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​              if(err)</p>
<p>​                     throw new OSExecute22Exception(“Errors executing “ + command);</p>
<p>​              return ls;</p>
<p>​       }</p>
<p>} </p>
<p>public class OSExecute22Test {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              for(String s : OSExecute22.command(“javap OSExecute22Test”))</p>
<p>​                     println(s);</p>
<p>​       }</p>
<p>}</p>
<p>public class CharBufferPrinter23 {</p>
<p>​       public static boolean isPrintable(char c) {</p>
<p>​                           return (((c &gt;= ‘!’) &amp;&amp; (c &lt;= ‘~’)) ? true : false);</p>
<p>​       }</p>
<p>​       public static void printCharBuffer(CharBuffer cb) {</p>
<p>​              cb.clear();            while(cb.hasRemaining()) {</p>
<p>​                     char c = cb.get();          </p>
<p>​                     if(isPrintable(c)) System.out.print(c);</p>
<p>​              }</p>
<p>​       } </p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              char[] ca = {‘w’,’x’,’y’,’z’};</p>
<p>​              CharBuffer cb = CharBuffer.wrap(ca);</p>
<p>​              print(“CharBuffer by wrapping char[]: “);</p>
<p>​              printCharBuffer(cb);</p>
<p>​              println();</p>
<p>​              CharBuffer cb2 = CharBuffer.allocate(6);</p>
<p>​              char[] ca2 = {‘s’,’t’,’u’,’v’,’w’};</p>
<p>​              cb2.put(ca2); </p>
<p>​              print(“CharBuffer by allocation: “);</p>
<p>​              printCharBuffer(cb2);</p>
<p>​              println();</p>
<p>​                           char[] ca3 = {(char)0x01, (char)0x07, (char)0x7F,’b’,’y’,’e’};</p>
<p>​              CharBuffer cb3 = CharBuffer.wrap(ca3);</p>
<p>​              print(“CharBuffer including some unprintables: “);</p>
<p>​              printCharBuffer(cb3);           </p>
<p>​       }</p>
<p>}</p>
<p>public class DoubleBufferDemo24 {</p>
<p>​       private static final int BSIZE = 1024;</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ByteBuffer bb = ByteBuffer.allocate(BSIZE);</p>
<p>​              DoubleBuffer db = bb.asDoubleBuffer();</p>
<p>​                           db.put(new </p>
<p>​                     double[]{11.11,42.42,27.37,99.99,143.143,811.811,1016.1026});</p>
<p>​                           System.out.println(db.get(3));</p>
<p>​              db.put(3, 1811.1811);</p>
<p>​                           db.flip();</p>
<p>​              while(db.hasRemaining()) {</p>
<p>​                     double d = db.get();</p>
<p>​                     System.out.println(d);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class AllocateDirectTest25 {     </p>
<p>​                   public static File toDirect(File f) throws IOException {</p>
<p>​              FileChannel fcIn = new FileInputStream(f).getChannel();  </p>
<p>​              ByteBuffer b = ByteBuffer.allocateDirect((int)f.length());</p>
<p>​              fcIn.read(b);</p>
<p>​              b.flip();</p>
<p>​              Charset cs = Charset.defaultCharset();       </p>
<p>​              CharBuffer cb = cs.decode(b);</p>
<p>​              String cbD1 = cb.toString().replace(</p>
<p>​                     “.allocate(“, “.allocateDirect(“);</p>
<p>​              String cbD = cbD1.replace(f.getName().split(“\.”)[0], </p>
<p>​                     f.getName().split(“\.”)[0] + “Direct”);</p>
<p>​              CharBuffer cbNew = CharBuffer.wrap(cbD);</p>
<p>​              String ext = (f.getName().split(“\.”))[1];</p>
<p>​              String outFile = (f.getName().split(“\.”))[0] + </p>
<p>​                     “Direct.” + ext;</p>
<p>​              FileChannel fcOut = </p>
<p>​                     new FileOutputStream(</p>
<p>​                            new File(outFile)).getChannel();</p>
<p>​              fcOut.write(cs.encode(cbNew));          </p>
<p>​                           fcIn.close();</p>
<p>​              fcOut.close();</p>
<p>​              return new File(outFile);</p>
<p>​       }</p>
<p>​             public static void Tester(String s) {</p>
<p>​              try {                     Class c = Class.forName(s);</p>
<p>​                     String name = c.getSimpleName();</p>
<p>​                     print(“Testing: “ + name);</p>
<p>​                     @SuppressWarnings(“unchecked”)</p>
<p>​                     Method m = c.getMethod(“main”, String[].class);</p>
<p>​                                                             String[] sa = new String[]{“ChannelCopy.java”, “Test.txt”};</p>
<p>​                     long startRun = System.nanoTime(); </p>
<p>​                     m.invoke(c.newInstance(), (Object)sa);</p>
<p>​                     long duration = System.nanoTime() - startRun;</p>
<p>​                     print(“\nTime to run “ + name + “ = “ </p>
<p>​                            + duration + “ nanoseconds”);                         </p>
<p>​              } catch(Exception e) {</p>
<p>​                     e.printStackTrace(System.err);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static long allocationTime(int i) { </p>
<p>​              long start = System.nanoTime();</p>
<p>​              ByteBuffer bb = ByteBuffer.allocate(i);</p>
<p>​              return System.nanoTime() - start;</p>
<p>​       }      </p>
<p>​       public static long directAllocationTime(int i) { </p>
<p>​              long start = System.nanoTime();</p>
<p>​              ByteBuffer bb = ByteBuffer.allocateDirect(i);</p>
<p>​              return System.nanoTime() - start;</p>
<p>​       }</p>
<p>​       </p>
<p>​       public static void main(final String[] args) throws IOException {</p>
<p>​                           print(“Time to allocate 1024 bytes = “ </p>
<p>​                     + allocationTime(1024) + “ nanoseconds”);</p>
<p>​              print(“Time to allocateDirect 1024 bytes = “ </p>
<p>​                     + directAllocationTime(1024) + “ nanoseconds”);</p>
<p>​              print(“Time to allocate 48 bytes = “ </p>
<p>​                     + allocationTime(48) + “ nanoseconds”);</p>
<p>​              print(“Time to allocateDirect 48 bytes = “ </p>
<p>​                     + directAllocationTime(48) + “ nanoseconds”);</p>
<p>​              print(“Time to allocate 1 byte = “ </p>
<p>​                     + allocationTime(1) + “ nanoseconds”);</p>
<p>​              print(“Time to allocateDirect 1 byte = “ </p>
<p>​                     + directAllocationTime(1) + “ nanoseconds”);</p>
<p>​              Tester(“GetChannel”);</p>
<p>​              toDirect(new File(“GetChannel.java”));</p>
<p>​                           Tester(“GetChannelDirect”);</p>
<p>​              Tester(“BufferToText”);</p>
<p>​              toDirect(new File(“BufferToText.java”));</p>
<p>​                           Tester(“BufferToTextDirect”);</p>
<p>​              Tester(“ChannelCopy”);</p>
<p>​              toDirect(new File(“ChannelCopy.java”));</p>
<p>​                           Tester(“ChannelCopyDirect”);</p>
<p>​              Tester(“GetData”);</p>
<p>​              toDirect(new File(“GetData.java”));</p>
<p>​                           Tester(“GetDataDirect”);</p>
<p>​              Tester(“IntBufferDemo”);</p>
<p>​              toDirect(new File(“IntBufferDemo.java”));</p>
<p>​                           Tester(“IntBufferDemoDirect”);</p>
<p>​              Tester(“UsingBuffers”);</p>
<p>​              toDirect(new File(“UsingBuffers.java”));</p>
<p>​                           Tester(“UsingBuffersDirect”);</p>
<p>​       }</p>
<p>}</p>
<p>public class JGrep26  {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              if(args.length &lt; 2) {</p>
<p>​                     System.out.println(“Usage: java JGrep26 file regex”);</p>
<p>​                     System.exit(0);</p>
<p>​              }</p>
<p>​              FileChannel fc = new FileInputStream(args[0]).getChannel();          </p>
<p>​              MappedByteBuffer in = </p>
<p>​                     fc.map(FileChannel.MapMode.READ_ONLY, 0, </p>
<p>​                            new File(args[0]).length());</p>
<p>​                           String[] sa = Charset.forName(System.getProperty(“file.encoding”))</p>
<p>​                     .decode(in).toString().split(“\n”);</p>
<p>​              Pattern p = Pattern.compile(args[1]);         </p>
<p>​              Matcher m = p.matcher(“”);              int index = 0;</p>
<p>​              for(String line : sa) {</p>
<p>​                     m.reset(line);</p>
<p>​                     while(m.find())</p>
<p>​                            System.out.println(index++ + “: “ + </p>
<p>​                                   m.group() + “: “ + m.start());</p>
<p>​              }</p>
<p>​              fc.close();</p>
<p>​       }</p>
<p>}</p>
<p>class A implements Serializable { </p>
<p>​       private int i;    </p>
<p>​       A(int i) { this.i = i; }</p>
<p>​       public String toString() { return “A:” + i; }</p>
<p>} </p>
<p>class B implements Serializable {</p>
<p>​       private char c;</p>
<p>​       private A a;</p>
<p>​       B(char c, A a) {</p>
<p>​              this.c = c;</p>
<p>​              this.a = a;</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              return “B:” + c + “ “ + a;</p>
<p>​       }      </p>
<p>}</p>
<p>public class SerializationTest implements Serializable {</p>
<p>​       private static Random rand = new Random();</p>
<p>​       public static void main(String[] args) </p>
<p>​       throws ClassNotFoundException, IOException {</p>
<p>​              B b = new B(‘x’, new A(rand.nextInt(100)));</p>
<p>​              System.out.println(“b: “ + b);</p>
<p>​              ObjectOutputStream out = new ObjectOutputStream(</p>
<p>​                     new FileOutputStream(“STest.out”));</p>
<p>​              out.writeObject(b);</p>
<p>​              out.close();</p>
<p>​              ObjectInputStream in = new ObjectInputStream(</p>
<p>​                     new FileInputStream(“STest.out”));</p>
<p>​              B b2 = (B)in.readObject();</p>
<p>​              System.out.println(“b2: “ + b2);          </p>
<p>​       }</p>
<p>}</p>
<p>class Blip1 implements Externalizable {</p>
<p>​       public Blip1() {</p>
<p>​              print(“Blip1 Constructor”);</p>
<p>​       }</p>
<p>​       public void writeExternal(ObjectOutput out) </p>
<p>​       throws  IOException {</p>
<p>​              print(“Blip1.writeExternal”);</p>
<p>​       }</p>
<p>​       public void readExternal(ObjectInput in) </p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Blip1.readExternal”);</p>
<p>​       }</p>
<p>}</p>
<p>public class BlipCheck implements Externalizable {</p>
<p>​                                     public void writeExternal(ObjectOutput out) </p>
<p>​       throws IOException {</p>
<p>​              print(“BlipCheck writeExternal”);</p>
<p>​       }</p>
<p>​       public void readExternal(ObjectInput in) </p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“BlipCheck readExternal”);</p>
<p>​       }</p>
<p>}</p>
<p>class Blips {</p>
<p>​       public static void main(String[] args) </p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Constructing objects:”);</p>
<p>​              Blip1 b1 = new Blip1();</p>
<p>​              Blip2 b2 = new Blip2();</p>
<p>​              BlipCheck bc = new BlipCheck();</p>
<p>​              ObjectOutputStream o = new ObjectOutputStream(</p>
<p>​                     new FileOutputStream(“Blips.out”));</p>
<p>​              print(“Saving objects:”);</p>
<p>​              o.writeObject(b1);</p>
<p>​              o.writeObject(b2);</p>
<p>​              o.writeObject(bc);</p>
<p>​              o.close();</p>
<p>​                           ObjectInputStream in = new ObjectInputStream(</p>
<p>​                     new FileInputStream(“Blips.out”));</p>
<p>​              print(“Recovering b1:”);</p>
<p>​              b1 = (Blip1)in.readObject();</p>
<p>​              print(“Recovering b2:”);</p>
<p>​              b2 = (Blip2)in.readObject();</p>
<p>​              print(“Recovering bc:”);</p>
<p>​              bc = (BlipCheck)in.readObject();</p>
<p>​       }</p>
<p>}</p>
<p>public class Blip29 implements Externalizable {</p>
<p>​       private int i;</p>
<p>​       private String s;   public Blip29() {</p>
<p>​              print(“Blip29 Contstructor”);</p>
<p>​                    }</p>
<p>​       public Blip29(String x, int a) {</p>
<p>​              print(“Blip29(String x, int a)”);</p>
<p>​              s = x;</p>
<p>​              i = a;</p>
<p>​                    }</p>
<p>​       public String toString() { return s + i; }</p>
<p>​       public void writeExternal(ObjectOutput out) </p>
<p>​       throws IOException {</p>
<p>​              print(“Blip29.writeExternal”);</p>
<p>​                                                                                     }</p>
<p>​       public void readExternal(ObjectInput in)</p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Blip29.readExternal”);</p>
<p>​                                                                                     }</p>
<p>​       public static void main(String[] args)</p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Constructing objects:”);</p>
<p>​              Blip29 b29 = new Blip29(“A String “, 47);</p>
<p>​              print(b29);</p>
<p>​              ObjectOutputStream o = new ObjectOutputStream(</p>
<p>​                     new FileOutputStream(“Blip29.out”));</p>
<p>​              print(“Saving object:”);</p>
<p>​              o.writeObject(b29);</p>
<p>​              o.close();</p>
<p>​                           ObjectInputStream in = new ObjectInputStream(</p>
<p>​                     new FileInputStream(“Blip29.out”));</p>
<p>​              print(“Recovering b29:”);</p>
<p>​              b29 = (Blip29)in.readObject();</p>
<p>​              print(b29);</p>
<p>​       }</p>
<p>}</p>
<p>abstract class Shape implements Serializable {</p>
<p>​       public static final int RED = 1, BLUE = 2, GREEN = 3;</p>
<p>​       private int xPos, yPos, dimension;</p>
<p>​       private static Random rand = new Random(47);</p>
<p>​       private static int counter = 0;</p>
<p>​       public abstract void setColor(int newColor);</p>
<p>​       public abstract int getColor();</p>
<p>​       public Shape(int xVal, int yVal, int dim) {</p>
<p>​              xPos = xVal;</p>
<p>​              yPos = yVal;</p>
<p>​              dimension = dim;</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              return getClass() + </p>
<p>​                     “ color[“ + getColor() + “] xPos[“ + xPos +</p>
<p>​                     “] yPos[“ + yPos + “] dim[“ + dimension + “]\n”; </p>
<p>​       }</p>
<p>​       public static Shape randomFactory() {</p>
<p>​              int xVal = rand.nextInt(100);</p>
<p>​              int yVal = rand.nextInt(100);</p>
<p>​              int dim = rand.nextInt(100);</p>
<p>​              switch(counter++ % 3) {</p>
<p>​                     default:</p>
<p>​                     case 0: return new Circle(xVal, yVal, dim);</p>
<p>​                     case 1: return new Square(xVal, yVal, dim);</p>
<p>​                     case 2: return new Line(xVal, yVal, dim);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Circle extends Shape {</p>
<p>​       private static int color = RED;</p>
<p>​       public static void serializeStaticState(ObjectOutputStream os)</p>
<p>​       throws IOException { os.writeInt(color); }</p>
<p>​       public static void deserializeStaticState(ObjectInputStream os) </p>
<p>​       throws IOException { color = os.readInt(); }</p>
<p>​       public Circle(int xVal, int yVal, int dim) {</p>
<p>​              super(xVal, yVal, dim);</p>
<p>​       }</p>
<p>​       public void setColor(int newColor) { color = newColor; }</p>
<p>​       public int getColor() { return color; }</p>
<p>} </p>
<p>class Square extends Shape {</p>
<p>​       private static int color;</p>
<p>​       public static void serializeStaticState(ObjectOutputStream os)</p>
<p>​       throws IOException { os.writeInt(color); }</p>
<p>​       public static void deserializeStaticState(ObjectInputStream os) </p>
<p>​       throws IOException { color = os.readInt(); }</p>
<p>​       public Square(int xVal, int yVal, int dim) {</p>
<p>​              super(xVal, yVal, dim);</p>
<p>​              color = RED;</p>
<p>​       }</p>
<p>​       public void setColor(int newColor) { color = newColor; }</p>
<p>​       public int getColor() { return color; }</p>
<p>}</p>
<p>class Line extends Shape {</p>
<p>​       private static int color = RED;</p>
<p>​       public static void serializeStaticState(ObjectOutputStream os)</p>
<p>​       throws IOException { os.writeInt(color); }</p>
<p>​       public static void deserializeStaticState(ObjectInputStream os) </p>
<p>​       throws IOException { color = os.readInt(); }</p>
<p>​       public Line(int xVal, int yVal, int dim) {</p>
<p>​              super(xVal, yVal, dim);</p>
<p>​       }</p>
<p>​       public void setColor(int newColor) { color = newColor; }</p>
<p>​       public int getColor() { return color; }</p>
<p>}</p>
<p>public class StoreCADState30 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​       List<shape> shapes = new ArrayList<shape>();</shape></shape></p>
<p>​             for(int i = 0; i &lt; 10; i++)</p>
<p>​              shapes.add(Shape.randomFactory());</p>
<p>​             for(int i = 0; i &lt; 10; i++)</p>
<p>​              ((Shape)shapes.get(i)).setColor(Shape.GREEN);</p>
<p>​             ObjectOutputStream out = new ObjectOutputStream(</p>
<p>​              new FileOutputStream(“CADState.out”));</p>
<p>​       Circle.serializeStaticState(out);</p>
<p>​       Square.serializeStaticState(out);</p>
<p>​       Line.serializeStaticState(out);</p>
<p>​       out.writeObject(shapes);</p>
<p>​             System.out.println(shapes);</p>
<p>​       }</p>
<p>}</p>
<p>public class WordCountXML {</p>
<p>​       public static void format(OutputStream os, Document doc) </p>
<p>​       throws Exception {</p>
<p>​              Serializer serializer = new Serializer(os, “ISO-8859-1”);</p>
<p>​              serializer.setIndent(4);</p>
<p>​              serializer.setMaxLength(64);</p>
<p>​              serializer.write(doc);</p>
<p>​              serializer.flush();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​                           String fileName = “WordCountXML.java”;</p>
<p>​                           Set<string> uniqueWords = </string></p>
<p>​                     new TreeSet<string>(new TextFile(fileName, “\W+”));</string></p>
<p>​                           ArrayList<string> allWords = new TextFile(fileName, “\W+”);</string></p>
<p>​              Map&lt;String,Integer&gt; wordCount = new TreeMap&lt;String,Integer&gt;();    </p>
<p>​                           for(String s : uniqueWords) {</p>
<p>​                     int count = 0;</p>
<p>​                     for(String t : allWords) {</p>
<p>​                            if(t.equals(s)) count++;</p>
<p>​                     }</p>
<p>​                     wordCount.put(s, count);</p>
<p>​              }</p>
<p>​              Element root = new Element(“words”);                        Iterator it = wordCount.entrySet().iterator();</p>
<p>​              while(it.hasNext()) {</p>
<p>​                     @SuppressWarnings(“unchecked”)</p>
<p>​                     Map.Entry&lt;String,Integer&gt; me = </p>
<p>​                            (Map.Entry&lt;String,Integer&gt;)it.next();</p>
<p>​                     Element word = new Element(“word”);</p>
<p>​                     word.appendChild(me.getKey() + “: “);</p>
<p>​                     word.appendChild(Integer.toString(me.getValue()));</p>
<p>​                     root.appendChild(word);</p>
<p>​              }             </p>
<p>​              Document doc = new Document(root);</p>
<p>​                           try {        </p>
<p>​                     format(System.out, doc);</p>
<p>​                     format(new BufferedOutputStream(</p>
<p>​                            new FileOutputStream(“WordCount.xml”)), doc); </p>
<p>​              } catch(Exception e) {</p>
<p>​                     System.err.println(e);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class PreferencesDemo33 {</p>
<p>​       public static void main(String[] args) throws Exception {         </p>
<p>​              Preferences prefs = Preferences</p>
<p>​                     .userNodeForPackage(PreferencesDemo33.class);</p>
<p>​              int value = prefs.getInt(“base directory”, 0);</p>
<p>​              System.out.print(“Base directory value = “ + value +</p>
<p>​                     “\nEnter new base directory value (integer): “);</p>
<p>​              BufferedReader br = new BufferedReader(</p>
<p>​                     new InputStreamReader(System.in));</p>
<p>​              try {</p>
<p>​                     value = Integer.parseInt(br.readLine());</p>
<p>​                 } catch (Exception e) {</p>
<p>​                     System.err.println(e);</p>
<p>​                     System.exit(1);</p>
<p>​                 }</p>
<p>​              prefs.putInt(“base directory”, value);          </p>
<p>​       }</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">190</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
