<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Fey&#39;s blog">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fey&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/">





  <title>Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/07/2019-10-07-Leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/2019-10-07-Leetcode/" itemprop="url">Leetcode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-07T10:00:00+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>算法思想<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener">二分查找</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3" target="_blank" rel="noopener">贪心思想</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%8F%8C%E6%8C%87%E9%92%88" target="_blank" rel="noopener">双指针</a></li>
<li>排序<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">快速选择</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">堆排序</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">桶排序</a></li>
</ul>
</li>
<li>搜索<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#bfs" target="_blank" rel="noopener">BFS</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#dfs" target="_blank" rel="noopener">DFS</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#backtracking" target="_blank" rel="noopener">Backtracking</a></li>
</ul>
</li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%88%86%E6%B2%BB" target="_blank" rel="noopener">分治</a></li>
<li>动态规划<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0" target="_blank" rel="noopener">分割整数</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84" target="_blank" rel="noopener">矩阵路径</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">斐波那契数列</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">最长递增子序列</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E7%B3%BB%E5%88%97" target="_blank" rel="noopener">最长公共子系列</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#0-1-%E8%83%8C%E5%8C%85" target="_blank" rel="noopener">0-1 背包</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4" target="_blank" rel="noopener">数组区间</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91" target="_blank" rel="noopener">字符串编辑</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">其它问题</a></li>
</ul>
</li>
<li>数学<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E7%B4%A0%E6%95%B0" target="_blank" rel="noopener">素数</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" target="_blank" rel="noopener">最大公约数</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">进制转换</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E9%98%B6%E4%B9%98" target="_blank" rel="noopener">阶乘</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95%E5%87%8F%E6%B3%95" target="_blank" rel="noopener">字符串加法减法</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E7%9B%B8%E9%81%87%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">相遇问题</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">多数投票问题</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%85%B6%E5%AE%83" target="_blank" rel="noopener">其它</a></li>
</ul>
</li>
</ul>
</li>
<li>数据结构相关<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97" target="_blank" rel="noopener">栈和队列</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">哈希表</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">字符串</a></li>
<li>数组与矩阵<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#1-n-%E5%88%86%E5%B8%83" target="_blank" rel="noopener">1-n 分布</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">有序矩阵</a></li>
</ul>
</li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">链表</a></li>
<li>树<ul>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E9%80%92%E5%BD%92" target="_blank" rel="noopener">递归</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">层次遍历</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">前中后序遍历</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#bst" target="_blank" rel="noopener">BST</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#trie" target="_blank" rel="noopener">Trie</a></li>
</ul>
</li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%9B%BE" target="_blank" rel="noopener">图</a></li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E4%BD%8D%E8%BF%90%E7%AE%97" target="_blank" rel="noopener">位运算</a></li>
</ul>
</li>
<li><a href="https://github.com/h2pl/leetcode/blob/master/README.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" target="_blank" rel="noopener">参考资料</a></li>
</ul>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code>public int search(int key, int[] array) {
    int l = 0, h = array.length - 1;
    while (l &lt;= h) {
        int mid = l + (h - l) / 2;
        if (key == array[mid]) return mid;
        if (key &lt; array[mid])  h = mid - 1;
        else l = mid + 1;
    }
    return -1;
}</code></pre><p>实现时需要注意以下细节：</p>
<ol>
<li>在计算 mid 时不能使用 mid = (l + h) / 2 这种方式，因为 l + h 可能会导致加法溢出，应该使用 mid = l + (h - l) / 2。</li>
<li>对 h 的赋值和循环条件有关，当循环条件为 l &lt;= h 时，h = mid - 1；当循环条件为 l &lt; h 时，h = mid。解释如下：在循环条件为 l &lt;= h 时，如果 h = mid，会出现循环无法退出的情况，例如 l = 1，h = 1，此时 mid 也等于 1，如果此时继续执行 h = mid，那么就会无限循环；在循环条件为 l &lt; h，如果 h = mid - 1，会错误跳过查找的数，例如对于数组 [1,2,3]，要查找 1，最开始 l = 0，h = 2，mid = 1，判断 key &lt; arr[mid] 执行 h = mid - 1 = 0，此时循环退出，直接把查找的数跳过了。</li>
<li>l 的赋值一般都为 l = mid + 1。</li>
</ol>
<p><strong>求开方</strong></p>
<p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Leetcode : 69. Sqrt(x) (Easy)</a></p>
<pre><code>Input: 4
Output: 2

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</code></pre><p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt 。可以利用二分查找在 0 ~ x 之间查找 sqrt。</p>
<pre><code>public int mySqrt(int x) {
    if(x &lt;= 1) return x;
    int l = 1, h = x;
    while(l &lt;= h){
        int mid = l + (h - l) / 2;
        int sqrt = x / mid;
        if(sqrt == mid) return mid;
        else if(sqrt &lt; mid) h = mid - 1;
        else l = mid + 1;
    }
    return h;
}</code></pre><p><strong>摆硬币</strong></p>
<p><a href="https://leetcode.com/problems/arranging-coins/description/" target="_blank" rel="noopener">Leetcode : 441. Arranging Coins (Easy)</a></p>
<pre><code>n = 8
The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤
Because the 4th row is incomplete, we return 3.</code></pre><p>题目描述：第 i 行摆 i 个，统计能够摆的行数。</p>
<p>返回 h 而不是 l，因为摆的硬币最后一行不能算进去。</p>
<pre><code>public int arrangeCoins(int n) {
    int l = 0, h = n;
    while(l &lt;= h){
        int m = l + (h - l) / 2;
        long x = m * (m + 1L) / 2;
        if(x == n) return m;
        else if(x &lt; n) l = m + 1;
        else h = m - 1;
    }
    return h;
}</code></pre><p>可以不用二分查找，更直观的解法如下：</p>
<pre><code>public int arrangeCoins(int n) {
    int level = 1;
    while (n &gt; 0) {
        n -= level;
        level++;
    }
    return n == 0 ? level - 1 : level - 2;
}</code></pre><p><strong>有序数组的 Single Element</strong></p>
<p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 540. Single Element in a Sorted Array (Medium)</a></p>
<pre><code>Input: [1,1,2,3,3,4,4,8,8]
Output: 2</code></pre><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。</p>
<pre><code>public int singleNonDuplicate(int[] nums) {
    int l = 0, h = nums.length - 1;
    while(l &lt; h) {
        int m = l + (h - l) / 2;
        if(m % 2 == 1) m--; // 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数
        if(nums[m] == nums[m + 1]) l = m + 2;
        else h = m;
    }
    return nums[l];
}</code></pre><h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><p>贪心思想保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<p><strong>分配饼干</strong></p>
<p><a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank" rel="noopener">Leetcode : 455. Assign Cookies (Easy)</a></p>
<pre><code>Input: [1,2], [1,2,3]
Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.</code></pre><p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>
<p>因为最小的孩子最容易得到满足，因此先满足最小孩子。给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。</p>
<p>证明：假设在某次选择中，贪心策略选择给第 i 个孩子分配第 m 个饼干，并且第 i 个孩子满足度最小，第 m 个饼干为可以满足第 i 个孩子的最小饼干，利用贪心策略最终可以满足 k 个孩子。假设最优策略在这次选择中给 i 个孩子分配第 n 个饼干，并且这个饼干大于第 m 个饼干。我们发现使用第 m 个饼干去替代第 n 个饼干完全不影响后续的结果，因此不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p>
<pre><code>public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int i = 0, j = 0;
    while(i &lt; g.length &amp;&amp; j &lt; s.length){
        if(g[i] &lt;= s[j]) i++;
        j++;
    }
    return i;
}</code></pre><p><strong>投飞镖刺破气球</strong></p>
<p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/" target="_blank" rel="noopener">Leetcode : 452. Minimum Number of Arrows to Burst Balloons (Medium)</a></p>
<pre><code>Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2</code></pre><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直射向坐标轴，使得路径上的气球都会刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>
<p>从左往右投飞镖，并且在每次投飞镖时满足以下条件：</p>
<ol>
<li>左边已经没有气球了；</li>
<li>本次投飞镖能够刺破最多的气球。</li>
</ol>
<pre><code>public int findMinArrowShots(int[][] points) {
    if(points.length == 0) return 0;
    Arrays.sort(points,(a,b) -&gt; (a[1] - b[1]));
    int curPos = points[0][1];
    int ret = 1;
    for (int i = 1; i &lt; points.length; i++) {
        if(points[i][0] &lt;= curPos) {
            continue;
        }
        curPos = points[i][1];
        ret++;
    }
    return ret;
 }</code></pre><p><strong>股票的最大收益</strong></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Leetcode : 122. Best Time to Buy and Sell Stock II (Easy)</a></p>
<p>题目描述：一次交易包含买入和卖出，多个交易之间不能交叉进行。</p>
<p>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加加到收益中，从而在局部最优的情况下也保证全局最优。</p>
<pre><code>public int maxProfit(int[] prices) {
    int profit = 0;
    for(int i = 1; i &lt; prices.length; i++){
        if(prices[i] &gt; prices[i-1]) profit += (prices[i] - prices[i-1]);
    }
    return profit;
}</code></pre><p><strong>种植花朵</strong></p>
<p><a href="https://leetcode.com/problems/can-place-flowers/description/" target="_blank" rel="noopener">Leetcode : 605. Can Place Flowers (Easy)</a></p>
<pre><code>Input: flowerbed = [1,0,0,0,1], n = 1
Output: True</code></pre><p>题目描述：花朵之间至少需要一个单位的间隔。</p>
<pre><code>public boolean canPlaceFlowers(int[] flowerbed, int n) {
    int cnt = 0;
    for(int i = 0; i &lt; flowerbed.length; i++){
        if(flowerbed[i] == 1) continue;
        int pre = i == 0 ? 0 : flowerbed[i - 1];
        int next = i == flowerbed.length - 1 ? 0 : flowerbed[i + 1];
        if(pre == 0 &amp;&amp; next == 0) {
            cnt++;
            flowerbed[i] = 1;
        }
    }
    return cnt &gt;= n;
}</code></pre><p><strong>修改一个数成为非递减数组</strong></p>
<p><a href="https://leetcode.com/problems/non-decreasing-array/description/" target="_blank" rel="noopener">Leetcode : 665. Non-decreasing Array (Easy)</a></p>
<pre><code>Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</code></pre><p>题目描述：判断一个数组能不能只修改一个数就成为非递减数组。</p>
<p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，那么就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，只修改 nums[i - 1] = nums[i] 不能令数组成为非递减，只能通过修改 nums[i] = nums[i - 1] 才行。</p>
<pre><code>public boolean checkPossibility(int[] nums) {
    int cnt = 0;
    for(int i = 1; i &lt; nums.length; i++){
        if(nums[i] &lt; nums[i - 1]){
            cnt++;
            if(i - 2 &gt;= 0 &amp;&amp; nums[i - 2] &gt; nums[i]) nums[i] = nums[i-1];
            else nums[i - 1] = nums[i];
        }
    }
    return cnt &lt;= 1;
}</code></pre><p><strong>判断是否为子串</strong></p>
<p><a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener">Leetcode : 392. Is Subsequence (Medium)</a></p>
<pre><code>s = &quot;abc&quot;, t = &quot;ahbgdc&quot;
Return true.</code></pre><pre><code>public boolean isSubsequence(String s, String t) {
    for (int i = 0, pos = 0; i &lt; s.length(); i++, pos++) {
        pos = t.indexOf(s.charAt(i), pos);
        if(pos == -1) return false;
    }
    return true;
}</code></pre><p><strong>分隔字符串使同种字符出现在一起</strong></p>
<p><a href="https://leetcode.com/problems/partition-labels/description/" target="_blank" rel="noopener">Leetcode : 763. Partition Labels (Medium)</a></p>
<pre><code>Input: S = &quot;ababcbacadefegdehijhklij&quot;
Output: [9,7,8]
Explanation:
The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.
This is a partition so that each letter appears in at most one part.
A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</code></pre><pre><code>public List&lt;Integer&gt; partitionLabels(String S) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    int[] lastIdxs = new int[26];
    for(int i = 0; i &lt; S.length(); i++) lastIdxs[S.charAt(i) - &#39;a&#39;] = i;
    int startIdx = 0;
    while(startIdx &lt; S.length()) {
        int endIdx = startIdx;
        for(int i = startIdx; i &lt; S.length() &amp;&amp; i &lt;= endIdx; i++) {
            int lastIdx = lastIdxs[S.charAt(i) - &#39;a&#39;];
            if(lastIdx == i) continue;
            if(lastIdx &gt; endIdx) endIdx = lastIdx;
        }
        ret.add(endIdx - startIdx + 1);
        startIdx = endIdx + 1;
    }
    return ret;
}</code></pre><p><strong>根据身高和序号重组队列</strong></p>
<p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener">Leetcode : 406. Queue Reconstruction by Height(Medium)</a></p>
<pre><code>Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</code></pre><p>题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p>
<p>为了在每次插入操作时不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入第 k 个位置可能会变成第 k+1 个位置。</p>
<p>身高降序、k 值升序，然后按排好序的顺序插入队列的第 k 个位置中。</p>
<pre><code>public int[][] reconstructQueue(int[][] people) {
    if(people == null || people.length == 0 || people[0].length == 0) return new int[0][0];

    Arrays.sort(people, new Comparator&lt;int[]&gt;() {
       public int compare(int[] a, int[] b) {
           if(a[0] == b[0]) return a[1] - b[1];
           return b[0] - a[0];
       }
    });

    int n = people.length;
    List&lt;int[]&gt; tmp = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; n; i++) {
        tmp.add(people[i][1], new int[]{people[i][0], people[i][1]});
    }

    int[][] ret = new int[n][2];
    for(int i = 0; i &lt; n; i++) {
        ret[i][0] = tmp.get(i)[0];
        ret[i][1] = tmp.get(i)[1];
    }
    return ret;
}</code></pre><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p>
<p><strong>从一个已经排序的数组中查找出两个数，使它们的和为 0</strong></p>
<p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">Leetcode ：167. Two Sum II - Input array is sorted (Easy)</a></p>
<pre><code>Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2</code></pre><p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<p>如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum &gt; target，移动较大的元素，使 sum 变小一些；如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</p>
<pre><code>public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    while (i &lt; j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) return new int[]{i + 1, j + 1};
        else if (sum &lt; target) i++;
        else j--;
    }
    return null;
}</code></pre><p><strong>反转字符串中的元音字符</strong></p>
<p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">Leetcode : 345. Reverse Vowels of a String (Easy)</a></p>
<pre><code>Given s = &quot;leetcode&quot;, return &quot;leotcede&quot;.</code></pre><p>使用双指针，指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。</p>
<pre><code>private HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;(Arrays.asList(&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;));

public String reverseVowels(String s) {
    if(s.length() == 0) return s;
    int i = 0, j = s.length() - 1;
    char[] result = new char[s.length()];
    while(i &lt;= j){
        char ci = s.charAt(i);
        char cj = s.charAt(j);
        if(!vowels.contains(ci)){
            result[i] = ci;
            i++;
        } else if(!vowels.contains(cj)){
            result[j] = cj;
            j--;
        } else{
            result[i] = cj;
            result[j] = ci;
            i++;
            j--;
        }
    }
    return new String(result);
}</code></pre><p><strong>两数平方和</strong></p>
<p><a href="https://leetcode.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">Leetcode : 633. Sum of Square Numbers (Easy)</a></p>
<pre><code>Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5</code></pre><p>题目描述：判断一个数是否为两个数的平方和，例如 5 = 12 + 22。</p>
<pre><code>public boolean judgeSquareSum(int c) {
    int left = 0, right = (int) Math.sqrt(c);
    while(left &lt;= right){
        int powSum = left * left + right * right;
        if(powSum == c) return true;
        else if(powSum &gt; c) right--;
        else left++;
    }
    return false;
}</code></pre><p><strong>回文字符串</strong></p>
<p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">Leetcode : 680. Valid Palindrome II (Easy)</a></p>
<pre><code>Input: &quot;abca&quot;
Output: True
Explanation: You could delete the character &#39;c&#39;.</code></pre><p>题目描述：字符串可以删除一个字符，判断是否能构成回文字符串。</p>
<pre><code>public boolean validPalindrome(String s) {
    int i = 0, j = s.length() -1;
    while(i &lt; j){
        if(s.charAt(i) != s.charAt(j)){
            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
        }
        i++;
        j--;
    }
    return true;
}

private boolean isPalindrome(String s, int l, int r){
    while(l &lt; r){
        if(s.charAt(l) != s.charAt(r))
            return false;
        l++;
        r--;
    }
    return true;
}</code></pre><p><strong>归并两个有序数组</strong></p>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 88. Merge Sorted Array (Easy)</a></p>
<p>题目描述：把归并结果存到第一个数组上</p>
<pre><code>public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1; // 需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值
    int idx = m + n - 1;
    while(i &gt;= 0 || j &gt;= 0){
        if(i &lt; 0) nums1[idx] = nums2[j--];
        else if(j &lt; 0) nums1[idx] = nums1[i--];
        else if(nums1[i] &gt; nums2[j]) nums1[idx] = nums1[i--];
        else nums1[idx] = nums2[j--];
        idx--;
    }
}</code></pre><p><strong>判断链表是否存在环</strong></p>
<p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Leetcode : 141. Linked List Cycle (Easy)</a></p>
<p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p>
<pre><code>public boolean hasCycle(ListNode head) {
    if(head == null) return false;
    ListNode l1 = head, l2 = head.next;
    while(l1 != null &amp;&amp; l2 != null){
        if(l1 == l2) return true;
        l1 = l1.next;
        if(l2.next == null) break;
        l2 = l2.next.next;
    }
    return false;
}</code></pre><p><strong>最长子序列</strong></p>
<p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">Leetcode : 524. Longest Word in Dictionary through Deleting (Medium)</a></p>
<pre><code>Input:
s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]

Output:
&quot;apple&quot;</code></pre><p>题目描述：可以删除 s 中的一些字符，使得它成为字符串列表 d 中的一个字符串。要求在 d 中找到满足条件的最长字符串。</p>
<pre><code>public String findLongestWord(String s, List&lt;String&gt; d) {
    String ret = &quot;&quot;;
    for (String str : d) {
        for (int i = 0, j = 0; i &lt; s.length() &amp;&amp; j &lt; str.length(); i++) {
            if (s.charAt(i) == str.charAt(j)) j++;
            if (j == str.length()) {
                if (ret.length() &lt; str.length()
                        || (ret.length() == str.length() &amp;&amp; ret.compareTo(str) &gt; 0)) {
                    ret = str;
                }
            }
        }
    }
    return ret;
}</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>一般用于求解 <strong>Kth Element</strong> 问题，可以在 O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。</p>
<p>与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为 O(n2)。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序用于求解 <strong>TopK Elements</strong> 问题，通过维护一个大小为 K 的堆，堆中的元素就是 TopK Elements。当然它也可以用于求解 Kth Element 问题，因为最后出堆的那个元素就是 Kth Element。快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p>
<p><strong>Kth Element</strong></p>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">Leetocde : 215. Kth Largest Element in an Array (Medium)</a></p>
<p><strong>排序</strong> ：时间复杂度 O(nlgn)，空间复杂度 O(1) 解法</p>
<pre><code>public int findKthLargest(int[] nums, int k) {
        int N = nums.length;
        Arrays.sort(nums);
        return nums[N - k];
}</code></pre><p><strong>堆排序</strong> ：时间复杂度 O(nlgk)，空间复杂度 O(k)</p>
<pre><code>public int findKthLargest(int[] nums, int k) {
    PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
    for(int val : nums) {
        pq.offer(val);
        if(pq.size() &gt; k) {
            pq.poll();
        }
    }
    return pq.peek();
}</code></pre><p><strong>快速选择</strong> ：时间复杂度 O(n)，空间复杂度 O(1)</p>
<pre><code>public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int lo = 0;
        int hi = nums.length - 1;
        while (lo &lt; hi) {
            final int j = partition(nums, lo, hi);
            if(j &lt; k) {
                lo = j + 1;
            } else if (j &gt; k) {
                hi = j - 1;
            } else {
                break;
            }
        }
        return nums[k];
    }

    private int partition(int[] a, int lo, int hi) {
        int i = lo;
        int j = hi + 1;
        while(true) {
            while(i &lt; hi &amp;&amp; less(a[++i], a[lo]));
            while(j &gt; lo &amp;&amp; less(a[lo], a[--j]));
            if(i &gt;= j) {
                break;
            }
            exch(a, i, j);
        }
        exch(a, lo, j);
        return j;
    }

    private void exch(int[] a, int i, int j) {
        final int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    private boolean less(int v, int w) {
        return v &lt; w;
    }
}</code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><strong>找出出现频率最多的 k 个数</strong></p>
<p><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">Leetcode : 347. Top K Frequent Elements (Medium)</a></p>
<pre><code>Given [1,1,1,2,2,3] and k = 2, return [1,2].</code></pre><pre><code>public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    List&lt;Integer&gt;[] bucket = new List[nums.length + 1];
    for(int key : map.keySet()) {
        int frequency = map.get(key);
        if(bucket[frequency] == null) {
            bucket[frequency] = new ArrayList&lt;&gt;();
        }
        bucket[frequency].add(key);
    }

    for(int i = bucket.length - 1; i &gt;= 0 &amp;&amp; ret.size() &lt; k; i--) {
        if(bucket[i] != null) {
            ret.addAll(bucket[i]);
        }
    }
    return ret;
}</code></pre><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。</p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><a href="https://github.com/h2pl/leetcode/blob/pics/4ff355cf-9a7f-4468-af43-e5b02038facc.jpg" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/4ff355cf-9a7f-4468-af43-e5b02038facc.jpg" alt="img"></a></p>
<p>广度优先搜索的搜索过程有点像一层一层地进行遍历：从节点 0 出发，遍历到 6、2、1 和 5 这四个新节点。</p>
<p>继续从 6 开始遍历，得到节点 4 ；从 2 开始遍历，没有下一个节点；从 1 开始遍历，没有下一个节点；从 5 开始遍历，得到 3 和 4 节点。这一轮总共得到两个新节点：4 和 3 。</p>
<p>反复从新节点出发进行上述的遍历操作。</p>
<p>可以看到，每一轮遍历的节点都与根节点路径长度相同。设 di 表示第 i 个节点与根节点的路径长度，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di&lt;=dj。利用这个结论，可以求解最短路径 <strong>最优解</strong> 问题：第一次遍历到目的节点，其所经过的路径为最短路径，如果继续遍历，之后再遍历到目的节点，所经过的路径就不是最短路径。</p>
<p>在程序实现 BFS 时需要考虑以下问题：</p>
<ul>
<li>队列：用来存储每一轮遍历的节点</li>
<li>标记：对于遍历过得节点，应该将它标记，防止重复遍历；</li>
</ul>
<p><strong>计算在网格中从原点到特定点的最短路径长度</strong></p>
<pre><code>[[1,1,0,1],
[1,0,1,0],
[1,1,1,1],
[1,0,1,1]]</code></pre><pre><code>public int minPathLength(int[][] grids, int tr, int tc) {
    int[][] next = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int m = grids.length, n = grids[0].length;
    Queue&lt;Position&gt; queue = new LinkedList&lt;&gt;();
    queue.add(new Position(0, 0, 1));
    while (!queue.isEmpty()) {
        Position pos = queue.poll();
        for (int i = 0; i &lt; 4; i++) {
            Position nextPos = new Position(pos.r + next[i][0], pos.c + next[i][1], pos.length + 1);
            if (nextPos.r &lt; 0 || nextPos.r &gt;= m || nextPos.c &lt; 0 || nextPos.c &gt;= n) continue;
            if (grids[nextPos.r][nextPos.c] != 1) continue;
            grids[nextPos.r][nextPos.c] = 0;
            if (nextPos.r == tr &amp;&amp; nextPos.c == tc) return nextPos.length;
            queue.add(nextPos);
        }
    }
    return -1;
}

private class Position {
    int r, c, length;
    public Position(int r, int c, int length) {
        this.r = r;
        this.c = c;
        this.length = length;
    }
}</code></pre><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><a href="https://github.com/h2pl/leetcode/blob/pics/f7f7e3e5-7dd4-4173-9999-576b9e2ac0a2.png" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/f7f7e3e5-7dd4-4173-9999-576b9e2ac0a2.png" alt="img"></a></p>
<p>广度优先搜索一层一层遍历，每一层遍历到的所有新节点，要用队列先存储起来以备下一层遍历的时候再遍历；而深度优先搜索在遍历到一个新节点时立马对新节点进行遍历：从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。</p>
<p>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong>问题。</p>
<p>在程序实现 DFS 时需要考虑以下问题：</p>
<ul>
<li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以使用递归栈。</li>
<li>标记：和 BFS 一样同样需要对已经遍历过得节点进行标记。</li>
</ul>
<p><strong>查找最大的连通面积</strong></p>
<p><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">Leetcode : 695. Max Area of Island (Easy)</a></p>
<pre><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,1,1,0,1,0,0,0,0,0,0,0,0],
[0,1,0,0,1,1,0,0,1,0,1,0,0],
[0,1,0,0,1,1,0,0,1,1,1,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,0,0,0,0,0,0,1,1,0,0,0,0]]</code></pre><pre><code>public int maxAreaOfIsland(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    int max = 0;
    for(int i = 0; i &lt; m; i++){
        for(int j = 0; j &lt; n; j++){
            if(grid[i][j] == 1) max = Math.max(max, dfs(grid, i, j));
        }
    }
    return max;
}

private int dfs(int[][] grid, int i, int j){
    int m = grid.length, n = grid[0].length;
    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n) return 0;
    if(grid[i][j] == 0) return 0;
    grid[i][j] = 0;
    return dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) + 1;
}</code></pre><p><strong>图的连通分量</strong></p>
<p><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">Leetcode : 547. Friend Circles (Medium)</a></p>
<pre><code>Input:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.
The 2nd student himself is in a friend circle. So return 2.</code></pre><pre><code>public int findCircleNum(int[][] M) {
    int n = M.length;
    int ret = 0;
    boolean[] hasFind = new boolean[n];
    for(int i = 0; i &lt; n; i++) {
        if(!hasFind[i]) {
            dfs(M, i, hasFind);
            ret++;
        }
    }
    return ret;
}

private void dfs(int[][] M, int i, boolean[] hasFind) {
    hasFind[i] = true;
    int n = M.length;
    for(int k = 0; k &lt; n; k++) {
        if(M[i][k] == 1 &amp;&amp; !hasFind[k]) {
            dfs(M, k, hasFind);
        }
    }
}</code></pre><p><strong>矩阵中的连通区域数量</strong></p>
<p><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Leetcode : 200. Number of Islands (Medium)</a></p>
<pre><code>11110
11010
11000
00000
Answer: 1</code></pre><pre><code>private int m, n;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;
    m = grid.length;
    n = grid[0].length;
    int ret = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] == &#39;1&#39;) {
                dfs(grid, i, j);
                ret++;
            }
        }
    }
    return ret;
}

private void dfs(char[][] grid, int i, int j) {
    if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == &#39;0&#39;) return;
    grid[i][j] = &#39;0&#39;;
    for (int k = 0; k &lt; direction.length; k++) {
        dfs(grid, i + direction[k][0], j + direction[k][1]);
    }
}</code></pre><p><strong>输出二叉树中所有从根到叶子的路径</strong></p>
<p><a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">Leetcode : 257. Binary Tree Paths (Easy)</a></p>
<pre><code>  1
/  \
2    3
\
  5</code></pre><pre><code>[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</code></pre><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) {
    List&lt;String&gt; ret = new ArrayList();
    if(root == null) return ret;
    dfs(root, &quot;&quot;, ret);
    return ret;
}

private void dfs(TreeNode root, String prefix, List&lt;String&gt; ret){
    if(root == null) return;
    if(root.left == null &amp;&amp; root.right == null){
        ret.add(prefix + root.val);
        return;
    }
    prefix += (root.val + &quot;-&gt;&quot;);
    dfs(root.left, prefix, ret);
    dfs(root.right, prefix, ret);
}</code></pre><p><strong>填充封闭区域</strong></p>
<p><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="noopener">Leetcode : 130. Surrounded Regions (Medium)</a></p>
<pre><code>For example,
X X X X
X O O X
X X O X
X O X X

After running your function, the board should be:
X X X X
X X X X
X X X X
X O X X</code></pre><p>题目描述：使得被 ‘X’ 的 ‘O’ 转换为 ‘X’。</p>
<p>先填充最外侧，剩下的就是里侧了。</p>
<pre><code>private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
private int m, n;

public void solve(char[][] board) {
    if (board == null || board.length == 0) return;
    m = board.length;
    n = board[0].length;
    for (int i = 0; i &lt; m; i++) {
        dfs(board, i, 0);
        dfs(board, i, n - 1);
    }
    for (int i = 0; i &lt; n; i++) {
        dfs(board, 0, i);
        dfs(board, m - 1, i);
    }
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (board[i][j] == &#39;T&#39;) board[i][j] = &#39;O&#39;;
            else if (board[i][j] == &#39;O&#39;) board[i][j] = &#39;X&#39;;
        }
    }
}

private void dfs(char[][] board, int r, int c) {
    if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != &#39;O&#39;) return;
    board[r][c] = &#39;T&#39;;
    for (int i = 0; i &lt; direction.length; i++) {
        dfs(board, r + direction[i][0], c + direction[i][1]);
    }
}</code></pre><p><strong>从两个方向都能到达的区域</strong></p>
<p><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/description/" target="_blank" rel="noopener">Leetcode : 417. Pacific Atlantic Water Flow (Medium)</a></p>
<pre><code>Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</code></pre><p>题目描述：左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</p>
<pre><code>private int m, n;
private int[][] matrix;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public List&lt;int[]&gt; pacificAtlantic(int[][] matrix) {
    List&lt;int[]&gt; ret = new ArrayList&lt;&gt;();
    if (matrix == null || matrix.length == 0) return ret;
    this.m = matrix.length;
    this.n = matrix[0].length;
    this.matrix = matrix;
    boolean[][] canReachP = new boolean[m][n];
    boolean[][] canReachA = new boolean[m][n];
    for (int i = 0; i &lt; m; i++) {
        dfs(i, 0, canReachP);
        dfs(i, n - 1, canReachA);
    }
    for (int i = 0; i &lt; n; i++) {
        dfs(0, i, canReachP);
        dfs(m - 1, i, canReachA);
    }
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (canReachP[i][j] &amp;&amp; canReachA[i][j]) {
                ret.add(new int[]{i, j});
            }
        }
    }
    return ret;
}

private void dfs(int r, int c, boolean[][] canReach) {
    if(canReach[r][c]) return;
    canReach[r][c] = true;
    for (int i = 0; i &lt; direction.length; i++) {
        int nextR = direction[i][0] + r;
        int nextC = direction[i][1] + c;
        if (nextR &lt; 0 || nextR &gt;= m || nextC &lt; 0 || nextC &gt;= n
                || matrix[r][c] &gt; matrix[nextR][nextC]) continue;
        dfs(nextR, nextC, canReach);
    }
}</code></pre><p><strong>N 皇后</strong></p>
<p><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">Leetcode : 51. N-Queens (Hard)</a></p>
<p><a href="https://github.com/h2pl/leetcode/blob/pics/1f080e53-4758-406c-bb5f-dbedf89b63ce.jpg" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/1f080e53-4758-406c-bb5f-dbedf89b63ce.jpg" alt="img"></a></p>
<p>题目描述：在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，要求解所有的 n 皇后解。</p>
<p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。</p>
<p>45 度对角线标记数组的维度为 2*n - 1，通过下图可以明确 (r,c) 的位置所在的数组下标为 r + c。</p>
<p><a href="https://github.com/h2pl/leetcode/blob/pics/85583359-1b45-45f2-9811-4f7bb9a64db7.jpg" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/85583359-1b45-45f2-9811-4f7bb9a64db7.jpg" alt="img"></a></p>
<p>135 度对角线标记数组的维度也是 2*n - 1，(r,c) 的位置所在的数组下标为 n - 1 - (r - c)。</p>
<p><a href="https://github.com/h2pl/leetcode/blob/pics/9e80f75a-b12b-4344-80c8-1f9ccc2d5246.jpg" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/9e80f75a-b12b-4344-80c8-1f9ccc2d5246.jpg" alt="img"></a></p>
<pre><code>private List&lt;List&lt;String&gt;&gt; ret;
private char[][] nQueens;
private boolean[] colUsed;
private boolean[] diagonals45Used;
private boolean[] diagonals135Used;
private int n;

public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
    ret = new ArrayList&lt;&gt;();
    nQueens = new char[n][n];
    Arrays.fill(nQueens, &#39;.&#39;);
    colUsed = new boolean[n];
    diagonals45Used = new boolean[2 * n - 1];
    diagonals135Used = new boolean[2 * n - 1];
    this.n = n;
    backstracking(0);
    return ret;
}

private void backstracking(int row) {
    if (row == n) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (char[] chars : nQueens) {
            list.add(new String(chars));
        }
        ret.add(list);
        return;
    }

    for (int col = 0; col &lt; n; col++) {
        int diagonals45Idx = row + col;
        int diagonals135Idx = n - 1 - (row - col);
        if (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) {
            continue;
        }
        nQueens[row][col] = &#39;Q&#39;;
        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = true;
        backstracking(row + 1);
        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = false;
        nQueens[row][col] = &#39;.&#39;;
    }
}</code></pre><h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><p>回溯是 DFS 的一种，它不是用在遍历图的节点上，而是用于求解 <strong>排列组合</strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串。</p>
<p>在程序实现时，回溯需要注意对元素进行标记的问题。使用递归实现的回溯，在访问一个新元素进入新的递归调用，此时需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；但是在递归返回时，需要将该元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，而在不同的递归链是可以访问已经访问过但是不在当前递归链中的元素。</p>
<p><strong>数字键盘组合</strong></p>
<p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">Leetcode : 17. Letter Combinations of a Phone Number (Medium)</a></p>
<p><a href="https://github.com/h2pl/leetcode/blob/pics/a3f34241-bb80-4879-8ec9-dff2d81b514e.jpg" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/a3f34241-bb80-4879-8ec9-dff2d81b514e.jpg" alt="img"></a></p>
<pre><code>Input:Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></pre><pre><code>private static final String[] KEYS = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};

public List&lt;String&gt; letterCombinations(String digits) {
    List&lt;String&gt; ret = new ArrayList&lt;&gt;();
    if (digits != null &amp;&amp; digits.length() != 0) {
        combination(&quot;&quot;, digits, 0, ret);
    }
    return ret;
}

private void combination(String prefix, String digits, int offset, List&lt;String&gt; ret) {
    if (offset == digits.length()) {
        ret.add(prefix);
        return;
    }
    String letters = KEYS[digits.charAt(offset) - &#39;0&#39;];
    for (char c : letters.toCharArray()) {
        combination(prefix + c, digits, offset + 1, ret);
    }
}</code></pre><p><strong>在矩阵中寻找字符串</strong></p>
<p><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">Leetcode : 79. Word Search (Medium)</a></p>
<pre><code>For example,
Given board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]
word = &quot;ABCCED&quot;, -&gt; returns true,
word = &quot;SEE&quot;, -&gt; returns true,
word = &quot;ABCB&quot;, -&gt; returns false.</code></pre><pre><code>private static int[][] shift = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
private static boolean[][] visited;
private int m;
private int n;

public boolean exist(char[][] board, String word) {
    if (word == null || word.length() == 0) return true;
    if (board == null || board.length == 0 || board[0].length == 0) return false;
    m = board.length;
    n = board[0].length;
    visited = new boolean[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (dfs(board, word, 0, i, j)) return true;
        }
    }
    return false;
}

private boolean dfs(char[][] board, String word, int start, int r, int c) {
    if (start == word.length()) {
        return true;
    }
    if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != word.charAt(start) ||  visited[r][c] ) {
        return false;
    }
    visited[r][c] = true;
    for (int i = 0; i &lt; shift.length; i++) {
        int nextR = r + shift[i][0];
        int nextC = c + shift[i][1];
        if (dfs(board, word, start + 1, nextR, nextC)) return true;
    }
    visited[r][c] = false;
    return false;
}</code></pre><p><strong>IP 地址划分</strong></p>
<p><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">Leetcode : 93. Restore IP Addresses(Medium)</a></p>
<pre><code>Given &quot;25525511135&quot;,
return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;].</code></pre><pre><code>private List&lt;String&gt; ret;

public List&lt;String&gt; restoreIpAddresses(String s) {
    ret = new ArrayList&lt;&gt;();
    doRestore(0, &quot;&quot;, s);
    return ret;
}

private void doRestore(int k, String path, String s) {
    if (k == 4 || s.length() == 0) {
        if (k == 4 &amp;&amp; s.length() == 0) {
            ret.add(path);
        }
        return;
    }
    for (int i = 0; i &lt; s.length() &amp;&amp; i &lt;= 2; i++) {
        if (i != 0 &amp;&amp; s.charAt(0) == &#39;0&#39;) break;
        String part = s.substring(0, i + 1);
        if (Integer.valueOf(part) &lt;= 255) {
            doRestore(k + 1, path.length() != 0 ? path + &quot;.&quot; + part : part, s.substring(i + 1));
        }
    }
}</code></pre><p><strong>排列</strong></p>
<p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">Leetcode : 46. Permutations (Medium)</a></p>
<pre><code>[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]</code></pre><pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; permuteList = new ArrayList&lt;&gt;();
    boolean[] visited = new boolean[nums.length];
    backtracking(permuteList, visited, nums, ret);
    return ret;
}

private void backtracking(List&lt;Integer&gt; permuteList, boolean[] visited, int[] nums, List&lt;List&lt;Integer&gt;&gt; ret){
    if(permuteList.size() == nums.length){
        ret.add(new ArrayList(permuteList));
        return;
    }

    for(int i = 0; i &lt; visited.length; i++){
        if(visited[i]) continue;
        visited[i] = true;
        permuteList.add(nums[i]);
        backtracking(permuteList, visited, nums, ret);
        permuteList.remove(permuteList.size() - 1);
        visited[i] = false;
    }
}</code></pre><p><strong>含有相同元素求排列</strong></p>
<p><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">Leetcode : 47. Permutations II (Medium)</a></p>
<pre><code>[1,1,2] have the following unique permutations:
[[1,1,2], [1,2,1], [2,1,1]]</code></pre><p>题目描述：数组元素可能含有相同的元素，进行排列时就有可能出先重复的排列，要求重复的排列只返回一个。</p>
<p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; permuteList = new ArrayList&lt;&gt;();
    Arrays.sort(nums);
    boolean[] visited = new boolean[nums.length];
    backtracking(permuteList, visited, nums, ret);
    return ret;
}

private void backtracking(List&lt;Integer&gt; permuteList, boolean[] visited, int[] nums, List&lt;List&lt;Integer&gt;&gt; ret) {
    if (permuteList.size() == nums.length) {
        ret.add(new ArrayList(permuteList));
        return;
    }

    for (int i = 0; i &lt; visited.length; i++) {
        if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) continue;
        if (visited[i]) continue;
        visited[i] = true;
        permuteList.add(nums[i]);
        backtracking(permuteList, visited, nums, ret);
        permuteList.remove(permuteList.size() - 1);
        visited[i] = false;
    }
}</code></pre><p><strong>组合</strong></p>
<p><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">Leetcode : 77. Combinations (Medium)</a></p>
<pre><code>If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</code></pre><pre><code>public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {
    List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; combineList = new ArrayList&lt;&gt;();
    backtracking(1, n, k, combineList, ret);
    return ret;
}

private void backtracking(int start, int n, int k, List&lt;Integer&gt; combineList, List&lt;List&lt;Integer&gt;&gt; ret){
    if(k == 0){
        ret.add(new ArrayList(combineList)); // 这里要重新构造一个 List
        return;
    }

    for(int i = start; i &lt;= n - k + 1; i++){ // 剪枝

        combineList.add(i);                        // 把 i 标记为已访问
        backtracking(i + 1, n, k - 1, combineList, ret);
        combineList.remove(combineList.size() - 1); // 把 i 标记为未访问
    }
}</code></pre><p><strong>组合求和</strong></p>
<p><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener">Leetcode : 39. Combination Sum (Medium)</a></p>
<pre><code>given candidate set [2, 3, 6, 7] and target 7,
A solution set is:
[[7],[2, 2, 3]]</code></pre><pre><code> private List&lt;List&lt;Integer&gt;&gt; ret;

 public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
     ret = new ArrayList&lt;&gt;();
     doCombination(candidates, target, 0, new ArrayList&lt;&gt;());
     return ret;
 }

 private void doCombination(int[] candidates, int target, int start, List&lt;Integer&gt; list) {
     if (target == 0) {
         ret.add(new ArrayList&lt;&gt;(list));
         return;
     }
     for (int i = start; i &lt; candidates.length; i++) {
         if (candidates[i] &lt;= target) {
             list.add(candidates[i]);
             doCombination(candidates, target - candidates[i], i, list);
             list.remove(list.size() - 1);
         }
     }
 }</code></pre><p><strong>含有相同元素的求组合求和</strong></p>
<p><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">Leetcode : 40. Combination Sum II (Medium)</a></p>
<pre><code>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]</code></pre><pre><code>private List&lt;List&lt;Integer&gt;&gt; ret;

public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    ret = new ArrayList&lt;&gt;();
    Arrays.sort(candidates);
    doCombination(candidates, target, 0, new ArrayList&lt;&gt;(), new boolean[candidates.length]);
    return ret;
}

private void doCombination(int[] candidates, int target, int start, List&lt;Integer&gt; list, boolean[] visited) {
    if (target == 0) {
        ret.add(new ArrayList&lt;&gt;(list));
        return;
    }
    for (int i = start; i &lt; candidates.length; i++) {
        if (i != 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !visited[i - 1]) continue;
        if (candidates[i] &lt;= target) {
            list.add(candidates[i]);
            visited[i] = true;
            doCombination(candidates, target - candidates[i], i + 1, list, visited);
            visited[i] = false;
            list.remove(list.size() - 1);
        }
    }
}</code></pre><p><strong>子集</strong></p>
<p><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Leetcode : 78. Subsets (Medium)</a></p>
<p>题目描述：找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复</p>
<pre><code>private List&lt;List&lt;Integer&gt;&gt; ret;
private List&lt;Integer&gt; subsetList;

public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
    ret = new ArrayList&lt;&gt;();
    subsetList = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt;= nums.length; i++) {
        backtracking(0, i, nums);
    }
    return ret;
}

private void backtracking(int startIdx, int size, int[] nums) {
    if (subsetList.size() == size) {
        ret.add(new ArrayList(subsetList));
        return;
    }

    for (int i = startIdx; i &lt; nums.length; i++) {
        subsetList.add(nums[i]);
        backtracking(i + 1, size, nums); // startIdx 设为下一个元素，使 subset 中的元素都递增排序
        subsetList.remove(subsetList.size() - 1);
    }
}</code></pre><p><strong>含有相同元素求子集</strong></p>
<p><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener">Leetcode : 90. Subsets II (Medium)</a></p>
<pre><code>For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</code></pre><pre><code>private List&lt;List&lt;Integer&gt;&gt; ret;
private List&lt;Integer&gt; subsetList;
private boolean[] visited;

public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
    ret = new ArrayList&lt;&gt;();
    subsetList = new ArrayList&lt;&gt;();
    visited = new boolean[nums.length];
    Arrays.sort(nums);
    for (int i = 0; i &lt;= nums.length; i++) {
        backtracking(0, i, nums);
    }
    return ret;
}

private void backtracking(int startIdx, int size, int[] nums) {
    if (subsetList.size() == size) {
        ret.add(new ArrayList(subsetList));
        return;
    }

    for (int i = startIdx; i &lt; nums.length; i++) {
        if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) continue;
        subsetList.add(nums[i]);
        visited[i] = true;
        backtracking(i + 1, size, nums);
        visited[i] = false;
        subsetList.remove(subsetList.size() - 1);
    }
}</code></pre><p><strong>分割字符串使得每部分都是回文数</strong></p>
<p><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">Leetcode : 131. Palindrome Partitioning (Medium)</a></p>
<pre><code>private List&lt;List&lt;String&gt;&gt; ret;

public List&lt;List&lt;String&gt;&gt; partition(String s) {
    ret = new ArrayList&lt;&gt;();
    doPartion(new ArrayList&lt;&gt;(), s);
    return ret;
}

private void doPartion(List&lt;String&gt; list, String s) {
    if (s.length() == 0) {
        ret.add(new ArrayList&lt;&gt;(list));
        return;
    }
    for (int i = 0; i &lt; s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            list.add(s.substring(0, i + 1));
            doPartion(list, s.substring(i + 1));
            list.remove(list.size() - 1);
        }
    }
}

private boolean isPalindrome(String s, int begin, int end) {
    while (begin &lt; end) {
        if (s.charAt(begin++) != s.charAt(end--)) return false;
    }
    return true;
}</code></pre><p><strong>数独</strong></p>
<p><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="noopener">Leetcode : 37. Sudoku Solver (Hard)</a></p>
<p><a href="https://github.com/h2pl/leetcode/blob/pics/1ca52246-c443-48ae-b1f8-1cafc09ec75c.png" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/1ca52246-c443-48ae-b1f8-1cafc09ec75c.png" alt="img"></a></p>
<pre><code>private boolean[][] rowsUsed = new boolean[9][10];
private boolean[][] colsUsed = new boolean[9][10];
private boolean[][] cubesUsed = new boolean[9][10];
private char[][] board;

public void solveSudoku(char[][] board) {
    this.board = board;
    for (int i = 0; i &lt; 9; i++) {
        for (int j = 0; j &lt; 9; j++) {
            if (board[i][j] == &#39;.&#39;) continue;
            int num = board[i][j] - &#39;0&#39;;
            rowsUsed[i][num] = true;
            colsUsed[j][num] = true;
            cubesUsed[cubeNum(i, j)][num] = true;
        }
    }
    for (int i = 0; i &lt; 9; i++) {
        for (int j = 0; j &lt; 9; j++) {
            backtracking(i, j);
        }
    }
}

private boolean backtracking(int row, int col) {
    while (row &lt; 9 &amp;&amp; board[row][col] != &#39;.&#39;) {
        row = col == 8 ? row + 1 : row;
        col = col == 8 ? 0 : col + 1;
    }
    if (row == 9) {
        return true;
    }
    for (int num = 1; num &lt;= 9; num++) {
        if (rowsUsed[row][num] || colsUsed[col][num] || cubesUsed[cubeNum(row, col)][num]) continue;
        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = true;
        board[row][col] = (char) (num + &#39;0&#39;);
        if (backtracking(row, col)) return true;
        board[row][col] = &#39;.&#39;;
        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = false;
    }
    return false;
}

private int cubeNum(int i, int j) {
    int r = i / 3;
    int c = j / 3;
    return r * 3 + c;
}</code></pre><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><strong>给表达式加括号</strong></p>
<p><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/description/" target="_blank" rel="noopener">Leetcode : 241. Different Ways to Add Parentheses (Medium)</a></p>
<pre><code>Input: &quot;2-1-1&quot;.

((2-1)-1) = 0
(2-(1-1)) = 2

Output : [0, 2]</code></pre><pre><code>public List&lt;Integer&gt; diffWaysToCompute(String input) {
    int n = input.length();
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; n; i++) {
        char c = input.charAt(i);
        if (c == &#39;+&#39; || c == &#39;-&#39; || c == &#39;*&#39;) {
            List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i));
            List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + 1));
            for (int l : left) {
                for (int r : right) {
                    switch (c) {
                        case &#39;+&#39;: ret.add(l + r); break;
                        case &#39;-&#39;: ret.add(l - r); break;
                        case &#39;*&#39;: ret.add(l * r); break;
                    }
                }
            }
        }
    }
    if (ret.size() == 0) ret.add(Integer.valueOf(input));
    return ret;
}</code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解。</p>
<h3 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h3><p><strong>分割整数的最大乘积</strong></p>
<p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">Leetcode : 343. Integer Break (Medim)</a></p>
<p>题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<pre><code>public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for(int i = 2; i &lt;= n; i++) {
        for(int j = 1; j &lt;= i - 1; j++) {
            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));
        }
    }
    return dp[n];
}</code></pre><p><strong>按平方数来分割整数</strong></p>
<p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">Leetcode : 279. Perfect Squares(Medium)</a></p>
<p>题目描述：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<pre><code>public int numSquares(int n) {
    List&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); // 存储小于 n 的平方数
    int diff = 3;
    while(square &lt;= n) {
        squares.add(square);
        square += diff;
        diff += 2;
    }
    int[] dp = new int[n + 1];
    for(int i = 1; i &lt;= n; i++) {
        int max = Integer.MAX_VALUE;
        for(int s : squares) {
            if(s &gt; i) break;
            max = Math.min(max, dp[i - s] + 1);
        }
        dp[i] = max;
    }
    return dp[n];
}</code></pre><p><strong>分割整数构成字母字符串</strong></p>
<p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Leetcode : 91. Decode Ways (Medium)</a></p>
<p>题目描述：Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<pre><code>public int numDecodings(String s) {
    if(s == null || s.length() == 0) return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == &#39;0&#39; ? 0 : 1;
    for(int i = 2; i &lt;= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if(one != 0) dp[i] += dp[i - 1];
        if(s.charAt(i - 2) == &#39;0&#39;) continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if(two &lt;= 26) dp[i] += dp[i - 2];
    }
    return dp[n];
}</code></pre><h3 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h3><p><strong>矩阵的总路径数</strong></p>
<p><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">Leetcode : 62. Unique Paths (Medium)</a></p>
<p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向左和向下移动。</p>
<pre><code>public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if(i == 0) dp[j] = 1;
            else if(j != 0) dp[j] = dp[j] + dp[j - 1];
        }
    }
    return dp[n - 1];
}</code></pre><p><strong>矩阵的最小路径和</strong></p>
<p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">Leetcode : 64. Minimum Path Sum (Medium)</a></p>
<p>题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向左和向下移动。</p>
<pre><code>public int minPathSum(int[][] grid) {
    if(grid.length == 0 || grid[0].length == 0) return 0;
    int m = grid.length, n = grid[0].length;
    int[] dp = new int[n];
    for(int i = 0; i &lt; m; i++) {
        for(int j = 0; j &lt; n; j++) {
            if(j == 0) dp[0] = dp[0] + grid[i][0];
            else if(i == 0) dp[j] = dp[j - 1] + grid[0][j];
            else dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }
    return dp[n - 1];
}</code></pre><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><strong>爬楼梯</strong></p>
<p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Leetcode : 70. Climbing Stairs (Easy)</a></p>
<p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>
<p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>
<p><a href="https://camo.githubusercontent.com/f314299a13ed7210bf23210c9e8f3cc69234287a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d64705b692d315d2b64705b692d325d" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f314299a13ed7210bf23210c9e8f3cc69234287a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d64705b692d315d2b64705b692d325d" alt="img"></a></p>
<p>dp[N] 即为所求。</p>
<p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2] 即可，使得原来的 O(n) 空间复杂度优化为 O(1) 复杂度。</p>
<pre><code>public int climbStairs(int n) {
    if(n == 1) return 1;
    if(n == 2) return 2;
    // 前一个楼梯、后一个楼梯
    int pre1 = 2, pre2 = 1;
    for(int i = 2; i &lt; n; i++){
        int cur = pre1 + pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}</code></pre><p><strong>母牛生产</strong></p>
<p><a href="https://github.com/h2pl/leetcode/blob/master/README.md#" target="_blank" rel="noopener">程序员代码面试指南-P181</a></p>
<p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p>
<p>第 i 年成熟的牛的数量为：</p>
<p><a href="https://camo.githubusercontent.com/56b447a65a3a577658f92552662805ec4875edb7/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d64705b692d315d2b64705b692d335d" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/56b447a65a3a577658f92552662805ec4875edb7/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d64705b692d315d2b64705b692d335d" alt="img"></a></p>
<p><strong>强盗抢劫</strong></p>
<p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">Leetcode : 198. House Robber (Easy)</a></p>
<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。</p>
<p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫邻近住户，因此如果抢劫了第 i 个住户那么只能抢劫 i - 2 和 i - 3 的住户，所以</p>
<p><a href="https://camo.githubusercontent.com/ed44bd0c9e18596a8406467a720341373f14bf93/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d6d61782864705b692d325d2c64705b692d335d292b6e756d735b695d" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ed44bd0c9e18596a8406467a720341373f14bf93/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d6d61782864705b692d325d2c64705b692d335d292b6e756d735b695d" alt="img"></a></p>
<p>O(n) 空间复杂度实现方法：</p>
<pre><code>public int rob(int[] nums) {
    int n = nums.length;
    if(n == 0) return 0;
    if(n == 1) return nums[0];
    if(n == 2) return Math.max(nums[0], nums[1]);
    int[] dp = new int[n];
    dp[0] = nums[0];
    dp[1] = nums[1];
    dp[2] = nums[0] + nums[2];
    for(int i = 3; i &lt; n; i++){
        dp[i] = Math.max(dp[i -2], dp[i - 3]) + nums[i];
    }
    return Math.max(dp[n - 1], dp[n - 2]);
}</code></pre><p>O(1) 空间复杂度实现方法：</p>
<pre><code>public int rob(int[] nums) {
    int n = nums.length;
    if(n == 0) return 0;
    if(n == 1) return nums[0];
    if(n == 2) return Math.max(nums[0], nums[1]);
    int pre3 = nums[0], pre2 = nums[1], pre1 = nums[2] + nums[0];
    for(int i = 3; i &lt; n; i++){
        int cur = Math.max(pre2, pre3) + nums[i];
        pre3 = pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return Math.max(pre1, pre2);
}</code></pre><p><strong>强盗在环形街区抢劫</strong></p>
<p><a href="https://leetcode.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">Leetcode : 213. House Robber II (Medium)</a></p>
<pre><code>public int rob(int[] nums) {
    if(nums == null || nums.length == 0) return 0;
    int n = nums.length;
    if(n == 1) return nums[0];
    return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
}

private int rob(int[] nums, int s, int e) {
    int n = nums.length;
    if(e - s == 0) return nums[s];
    if(e - s == 1) return Math.max(nums[s], nums[s + 1]);
    int[] dp = new int[n];
    dp[s] = nums[s];
    dp[s + 1] = nums[s + 1];
    dp[s + 2] = nums[s] + nums[s + 2];
    for (int i = s + 3; i &lt;= e; i++) {
        dp[i] = Math.max(dp[i - 2], dp[i - 3]) + nums[i];
    }
    return Math.max(dp[e], dp[e - 1]);
}</code></pre><p><strong>信件错排</strong></p>
<p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信的方式数量。</p>
<p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>
<p>① i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</p>
<p>② i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (n-1)*dp[i-1] 种错误装信方式。</p>
<p>综上所述，错误装信数量方式数量为：</p>
<p><a href="https://camo.githubusercontent.com/74f485453c589a9aacd3b086be74f9c17fea4565/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d28692d31292a64705b692d325d2b28692d31292a64705b692d315d" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/74f485453c589a9aacd3b086be74f9c17fea4565/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d3d28692d31292a64705b692d325d2b28692d31292a64705b692d315d" alt="img"></a></p>
<p>dp[N] 即为所求。</p>
<p>和上楼梯问题一样，dp[i] 只与 dp[i-1] 和 dp[i-2] 有关，因此也可以只用两个变量来存储 dp[i-1] 和 dp[i-2]。</p>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>已知一个序列 {S1, S2,…,Sn} ，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p>
<p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p>
<p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn ，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。</p>
<p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，因此需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>
<p><a href="https://camo.githubusercontent.com/a0ffe3935e051666fe098f302c15a46a5c3f7fb3/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b6e5d3d6d61785c7b312c64705b695d2b317c535f693c535f6e5c265c26693c6e5c7d" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a0ffe3935e051666fe098f302c15a46a5c3f7fb3/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b6e5d3d6d61785c7b312c64705b695d2b317c535f693c535f6e5c265c26693c6e5c7d" alt="img"></a></p>
<p>对于一个长度为 N 的序列，最长子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，即 max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p>
<p><strong>最长递增子序列</strong></p>
<p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">Leetcode : 300. Longest Increasing Subsequence (Medium)</a></p>
<pre><code>public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    for(int i = 0; i &lt; n; i++){
        int max = 1;
        for(int j = 0; j &lt; i; j++){
            if(nums[i] &gt; nums[j]) max = Math.max(max, dp[j] + 1);
        }
        dp[i] = max;
    }
    int ret = 0;
    for(int i = 0; i &lt; n; i++){
        ret = Math.max(ret, dp[i]);
    }
    return ret;
}</code></pre><p>以上解法的时间复杂度为 O(n2) ，可以使用二分查找使得时间复杂度降低为 O(nlogn)。定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素，例如对于数组 [4,5,6,3]，有</p>
<pre><code>len = 1  :      [4], [5], [6], [3]  =&gt; tails[0] = 3
len = 2  :      [4, 5], [5, 6]      =&gt; tails[1] = 5
len = 3  :      [4, 5, 6]            =&gt; tails[2] = 6</code></pre><p>对于一个元素 x，如果它大于 tails 数组所有的值，那么把它添加到 tails 后面；如果 tails[i-1] &lt; x &lt;= tails[i]，那么更新 tails[i] = x 。</p>
<p>可以看出 tails 数组保持有序，因此在查找 Si 位于 tails 数组的位置时就可以使用二分查找。</p>
<pre><code>public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] tails = new int[n];
    int size = 0;
    for(int i = 0; i &lt; n; i++){
        int idx = binarySearch(tails, 0, size, nums[i]);
        tails[idx] = nums[i];
        if(idx == size) size++;
    }
    return size;
}

private int binarySearch(int[] nums, int sIdx, int eIdx, int key){
    while(sIdx &lt; eIdx){
        int mIdx = sIdx + (eIdx - sIdx) / 2;
        if(nums[mIdx] == key) return mIdx;
        else if(nums[mIdx] &gt; key) eIdx = mIdx;
        else sIdx = mIdx + 1;
    }
    return sIdx;
}</code></pre><p><strong>最长摆动子序列</strong></p>
<p><a href="https://leetcode.com/problems/wiggle-subsequence/description/" target="_blank" rel="noopener">Leetcode : 376. Wiggle Subsequence (Medium)</a></p>
<p>要求：使用 O(n) 时间复杂度求解。</p>
<p>使用两个状态 up 和 down。</p>
<pre><code>public int wiggleMaxLength(int[] nums) {
    int len = nums.length;
    if (len == 0) return 0;
    int up = 1, down = 1;
    for (int i = 1; i &lt; len; i++) {
        if (nums[i] &gt; nums[i - 1]) up = down + 1;
        else if (nums[i] &lt; nums[i - 1]) down = up + 1;
    }
    return Math.max(up, down);
}</code></pre><h3 id="最长公共子系列"><a href="#最长公共子系列" class="headerlink" title="最长公共子系列"></a>最长公共子系列</h3><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>
<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p>
<p>① 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1 ，即 dp[i][j] = dp[i-1][j-1] + 1。</p>
<p>② 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，与 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</p>
<p>综上，最长公共子系列的状态转移方程为：</p>
<p><a href="https://camo.githubusercontent.com/eb4c4bf9d6fa7b09ffaae7007c57476424d397b7/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d5b6a5d3d5c6c6566745c7b5c626567696e7b61727261797d7b72636c7d64705b692d315d5b6a2d315d26267b53315f693d3d53325f6a7d5c5c6d61782864705b692d315d5b6a5d2c64705b695d5b6a2d315d2926267b53315f693c3e53325f6a7d5c656e647b61727261797d5c72696768742e" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/eb4c4bf9d6fa7b09ffaae7007c57476424d397b7/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d5b6a5d3d5c6c6566745c7b5c626567696e7b61727261797d7b72636c7d64705b692d315d5b6a2d315d26267b53315f693d3d53325f6a7d5c5c6d61782864705b692d315d5b6a5d2c64705b695d5b6a2d315d2926267b53315f693c3e53325f6a7d5c656e647b61727261797d5c72696768742e" alt="img"></a></p>
<p>对于长度为 N 的序列 S1 和 长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p>
<p>与最长递增子序列相比，最长公共子序列有以下不同点：</p>
<p>① 针对的是两个序列，求它们的最长公共子序列。 ② 在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j 。 ③ 由于 2 ，在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</p>
<pre><code>public int lengthOfLCS(int[] nums1, int[] nums2) {
    int n1 = nums1.length, n2 = nums2.length;
    int[][] dp = new int[n1 + 1][n2 + 1];
    for (int i = 1; i &lt;= n1; i++) {
        for (int j = 1; j &lt;= n2; j++) {
            if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return dp[n1][n2];
}</code></pre><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示体积不超过 j 的情况下，前 i 件物品能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<p>① 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。 ② 第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</p>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。</p>
<p>综上，0-1 背包的状态转移方程为：</p>
<p><a href="https://camo.githubusercontent.com/00df29727a33906f588337c972831c35988a152b/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d5b6a5d3d6d61782864705b692d315d5b6a5d2c64705b692d315d5b6a2d775d2b7629" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/00df29727a33906f588337c972831c35988a152b/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d5b6a5d3d6d61782864705b692d315d5b6a5d2c64705b692d315d5b6a2d775d2b7629" alt="img"></a></p>
<pre><code>public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N][W];
    for (int i = W - 1; i &gt;= 0; i--) {
        dp[0][i] = i &gt; weights[0] ? values[0] : 0;
    }
    for (int i = 1; i &lt; N; i++) {
        for (int j = W - 1; j &gt;= weights[i]; j--) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]);
        }
        for (int j = weights[i - 1] - 1; j &gt;= 0; j--) {
            dp[i][j] = dp[i - 1][j];
        }
    }
    return dp[N - 1][W - 1];
}</code></pre><p><strong>空间优化</strong></p>
<p>在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅由前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，</p>
<p><a href="https://camo.githubusercontent.com/854f645dd2443eeaabf715e590cdebc928944626/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b6a5d3d6d61782864705b6a5d2c64705b6a2d775d2b7629" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/854f645dd2443eeaabf715e590cdebc928944626/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b6a5d3d6d61782864705b6a5d2c64705b6a2d775d2b7629" alt="img"></a></p>
<p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w] 防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p>
<p><strong>无法使用贪心算法的解释</strong></p>
<p>0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.</p>
<table>
<thead>
<tr>
<th>id</th>
<th>w</th>
<th>v</th>
<th>v/w</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>12</td>
<td>4</td>
</tr>
</tbody></table>
<p><strong>变种</strong></p>
<p>完全背包：物品可以无限个，可以转换为 0-1 背包，令每种物品的体积和价值变为 1/2/4… 倍数，把它们都当成一个新物品，然后一种物品只能添加一次。</p>
<p>多重背包：物品数量有限制，同样可以转换为 0-1 背包。</p>
<p>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制。</p>
<p>其它：物品之间相互约束或者依赖。</p>
<p><strong>划分数组为和相等的两部分</strong></p>
<p><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">Leetcode : 416. Partition Equal Subset Sum (Medium)</a></p>
<p>可以看成一个背包大小为 sum/2 的 0-1 背包问题，但是也有不同的地方，这里没有价值属性，并且背包必须被填满。</p>
<p>以下实现使用了空间优化。</p>
<pre><code>public boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    if (sum % 2 != 0) {
        return false;
    }
    int W = sum / 2;
    boolean[] dp = new boolean[W + 1];
    int n = nums.length;
    for(int i = 0; i &lt;= W; i++) {
        if(nums[0] == i) dp[i] = true;
    }
    for(int i = 1; i &lt; n; i++) {
        for(int j = W; j &gt;= nums[i]; j--) {
            dp[j] = dp[j] || dp[j - nums[i]];
        }
    }

    return dp[W];
}</code></pre><p><strong>字符串按单词列表分割</strong></p>
<p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">Leetcode : 139. Word Break (Medium)</a></p>
<pre><code>s = &quot;leetcode&quot;,
dict = [&quot;leet&quot;, &quot;code&quot;].
Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre><pre><code>public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i &lt;= n; i++) {
        for (String word : wordDict) {
            if (word.length() &lt;= i
                    &amp;&amp; word.equals(s.substring(i - word.length(), i))) {
                dp[i] = dp[i] || dp[i - word.length()];
            }
        }
    }
    return dp[n];
}</code></pre><p><strong>改变一组数的正负号使得它们的和为一给定数</strong></p>
<p><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="noopener">Leetcode : 494. Target Sum (Medium)</a></p>
<pre><code>Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.</code></pre><p>该问题可以转换为 subset sum 问题，从而使用 0-1 背包的方法来求解。可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<pre><code>                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)</code></pre><p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p>
<pre><code>public int findTargetSumWays(int[] nums, int S) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    if (sum &lt; S || (sum + S) % 2 == 1) {
        return 0;
    }
    return subsetSum(nums, (sum + S) &gt;&gt;&gt; 1);
}

private int subsetSum(int[] nums, int targetSum) {
    Arrays.sort(nums);
    int[] dp = new int[targetSum + 1];
    dp[0] = 1;
    for (int i = 0; i &lt; nums.length; i++) {
        int num = nums[i];
        for (int j = targetSum; j &gt;= num; j--) {
            dp[j] = dp[j] + dp[j - num];
        }
    }
    return dp[targetSum];
}</code></pre><p><strong>01 字符构成最多的字符串</strong></p>
<p><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">Leetcode : 474. Ones and Zeroes (Medium)</a></p>
<pre><code>Input: Array = {&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</code></pre><p>这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</p>
<pre><code>public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0) return 0;
    int l = strs.length;
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt; l; i++) {
        String s = strs[i];
        int ones = 0, zeros = 0;
        for (char c : s.toCharArray()) {
            if (c == &#39;0&#39;) zeros++;
            else if (c == &#39;1&#39;) ones++;
        }
        for (int j = m; j &gt;= zeros; j--) {
            for (int k = n; k &gt;= ones; k--) {
                if (zeros &lt;= j &amp;&amp; ones &lt;= k) {
                    dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1);
                }
            }
        }
    }
    return dp[m][n];
}</code></pre><p><strong>找零钱</strong></p>
<p><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">Leetcode : 322. Coin Change (Medium)</a></p>
<p>题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。</p>
<p>这是一个完全背包问题，完全背包问题和 0-1 背包问题在实现上唯一的不同是，第二层循环是从 0 开始的，而不是从尾部开始。</p>
<pre><code>public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    for (int i = 1; i &lt;= amount; i++) {
        for (int j = 0; j &lt; coins.length; j++) {
            if (coins[j] &lt;= i) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }
    return dp[amount] &gt; amount ? -1 : dp[amount];
}</code></pre><p><strong>组合总和</strong></p>
<p><a href="https://leetcode.com/problems/combination-sum-iv/description/" target="_blank" rel="noopener">Leetcode : 377. Combination Sum IV (Medium)</a></p>
<pre><code>nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.</code></pre><pre><code>public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i &lt;= target; i++) {
        for (int j = 0; j &lt; nums.length; j++) {
            if(nums[j] &lt;= i) {
                dp[i] += dp[i - nums[j]];
            }
        }
    }
    return dp[target];
}</code></pre><p><strong>只能进行两次的股票交易</strong></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Leetcode : 123. Best Time to Buy and Sell Stock III (Hard)</a></p>
<pre><code>public int maxProfit(int[] prices) {
    int firstBuy = Integer.MIN_VALUE, firstSell = 0;
    int secondBuy = Integer.MIN_VALUE, secondSell = 0;
    for (int curPrice : prices) {
        if (firstBuy &lt; -curPrice) firstBuy = -curPrice;
        if (firstSell &lt; firstBuy + curPrice) firstSell = firstBuy + curPrice;
        if (secondBuy &lt; firstSell - curPrice) secondBuy = firstSell - curPrice;
        if (secondSell &lt; secondBuy + curPrice) secondSell = secondBuy + curPrice;
    }
    return secondSell;
}</code></pre><p><strong>只能进行 k 次的股票交易</strong></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Leetcode : 188. Best Time to Buy and Sell Stock IV (Hard)</a></p>
<pre><code>dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) { jj in range of [0, j-1] } = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))</code></pre><pre><code>public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    if (k &gt;= n/2) {
        int maxPro = 0;
        for (int i = 1; i &lt; n; i++) {
            if (prices[i] &gt; prices[i-1])
                maxPro += prices[i] - prices[i-1];
        }
        return maxPro;
    }
    int[][] dp = new int[k + 1][n];
    for (int i = 1; i &lt;= k; i++) {
        int localMax = dp[i - 1][0] - prices[0];
        for (int j = 1; j &lt; n; j++) {
            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + localMax);
            localMax = Math.max(localMax, dp[i - 1][j] - prices[j]);
        }
    }
    return dp[k][n - 1];
}</code></pre><h3 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h3><p><strong>数组区间和</strong></p>
<p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">Leetcode : 303. Range Sum Query - Immutable (Easy)</a></p>
<p>求区间 i ~ j 的和，可以转换为 sum[j] - sum[i-1]，其中 sum[i] 为 0 ~ j 的和。</p>
<pre><code>class NumArray {

    int[] nums;

    public NumArray(int[] nums) {
        for(int i = 1; i &lt; nums.length; i++)
            nums[i] += nums[i - 1];
        this.nums = nums;
    }

    public int sumRange(int i, int j) {
        return i == 0 ? nums[j] : nums[j] - nums[i - 1];
    }
}</code></pre><p><strong>子数组最大的和</strong></p>
<p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Leetcode : 53. Maximum Subarray (Easy)</a></p>
<p>令 sum[i] 为以 num[i] 为结尾的子数组最大的和，可以由 sum[i-1] 得到 sum[i] 的值，如果 sum[i-1] 小于 0，那么以 num[i] 为结尾的子数组不能包含前面的内容，因为加上前面的部分，那么和一定会比 num[i] 还小。</p>
<pre><code>public int maxSubArray(int[] nums) {
    int n = nums.length;
    int[] sum = new int[n];
    sum[0] = nums[0];
    int max = sum[0];
    for(int i = 1; i &lt; n; i++){
        sum[i] = (sum[i-1] &gt; 0 ? sum[i-1] : 0) + nums[i];
        max = Math.max(max, sum[i]);
    }
    return max;
}</code></pre><p>空间复杂度可以优化成 O(1) 空间复杂度</p>
<pre><code>public int maxSubArray(int[] nums) {
    int max = nums[0];
    int oldsum = nums[0];
    for (int i = 1; i &lt; nums.length; i++) {
        oldsum = (oldsum &gt; 0 ? oldsum: 0) + nums[i];
        max = Math.max(max, oldsum);
    }
    return max;
}</code></pre><p><strong>数组中等差递增子区间的个数</strong></p>
<p><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">Leetcode : 413. Arithmetic Slices (Medium)</a></p>
<pre><code>A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</code></pre><p>对于 (1,2,3,4)，它有三种组成递增子区间的方式，而对于 (1,2,3,4,5)，它组成递增子区间的方式除了 (1,2,3,4) 的三种外还多了一种，即 (1,2,3,4,5)，因此 dp[i] = dp[i - 1] + 1。</p>
<pre><code>public int numberOfArithmeticSlices(int[] A) {
    int n = A.length;
    int[] dp = new int[n];
    for(int i = 2; i &lt; n; i++) {
        if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
            dp[i] = dp[i - 1] + 1;
        }
    }
    int ret = 0;
    for(int cnt : dp) {
        ret += cnt;
    }
    return ret;
}</code></pre><h3 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h3><p><strong>删除两个字符串的字符使它们相等</strong></p>
<p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/description/" target="_blank" rel="noopener">Leetcode : 583. Delete Operation for Two Strings (Medium)</a></p>
<p>可以转换为求两个字符串的最长公共子序列问题。</p>
<pre><code>public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0 || j == 0) continue;
            dp[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? dp[i - 1][j - 1] + 1
                    : Math.max(dp[i][j - 1], dp[i - 1][j]);
        }
    }
    return m + n - 2 * dp[m][n];
}</code></pre><p><strong>修改一个字符串称为另一个字符串</strong> // TODO</p>
<p><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">Leetcode : 72. Edit Distance (Hard)</a></p>
<h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p><strong>需要冷却期的股票交易</strong></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" target="_blank" rel="noopener">Leetcode : 309. Best Time to Buy and Sell Stock with Cooldown(Medium)</a></p>
<p>题目描述：交易之后需要有一天的冷却时间。</p>
<p><a href="https://github.com/h2pl/leetcode/blob/pics/ac9b31ec-cef1-4880-a875-fc4571ca10e1.png" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/ac9b31ec-cef1-4880-a875-fc4571ca10e1.png" alt="img"></a></p>
<pre><code>s0[i] = max(s0[i - 1], s2[i - 1]); // Stay at s0, or rest from s2
s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]); // Stay at s1, or buy from s0
s2[i] = s1[i - 1] + prices[i]; // Only one way from s1</code></pre><pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) return 0;
    int n = prices.length;
    int[] s0 = new int[n];
    int[] s1 = new int[n];
    int[] s2 = new int[n];
    s0[0] = 0;
    s1[0] = -prices[0];
    s2[0] = Integer.MIN_VALUE;
    for (int i = 1; i &lt; n; i++) {
        s0[i] = Math.max(s0[i - 1], s2[i - 1]);
        s1[i] = Math.max(s1[i - 1], s0[i - 1] - prices[i]);
        s2[i] = Math.max(s2[i - 1], s1[i - 1] + prices[i]);
    }
    return Math.max(s0[n - 1], s2[n - 1]);
}</code></pre><p><strong>统计从 0 ~ n 每个数的二进制表示中 1 的个数</strong></p>
<p><a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener">Leetcode : 338. Counting Bits (Medium)</a></p>
<p>对于数字 6(110)，它可以看成是数字 2(10) 前面加上一个 1 ，因此 dp[i] = dp[i&amp;(i-1)] + 1;</p>
<pre><code>    public int[] countBits(int num) {
        int[] ret = new int[num + 1];
        for(int i = 1; i &lt;= num; i++){
            ret[i] = ret[i&amp;(i-1)] + 1;
        }
        return ret;
    }</code></pre><p><strong>一组整数对能够构成的最长链</strong></p>
<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">Leetcode : 646. Maximum Length of Pair Chain (Medium)</a></p>
<p>对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p>
<pre><code>public int findLongestChain(int[][] pairs) {
    if(pairs == null || pairs.length == 0) {
        return 0;
    }
    Arrays.sort(pairs, (a, b) -&gt; (a[0] - b[0]));
    int n = pairs.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for(int i = 0; i &lt; n; i++) {
        for(int j = 0; j &lt; i; j++) {
            if(pairs[i][0] &gt; pairs[j][1]){
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }

    int ret = 0;
    for(int num : dp) {
        ret = Math.max(ret, num);
    }
    return ret;
}</code></pre><p><strong>买入和售出股票最大的收益</strong></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Leetcode : 121. Best Time to Buy and Sell Stock (Easy)</a></p>
<p>只进行一次交易。</p>
<p>只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看这个价格是否是当前的最大价格。</p>
<pre><code>public int maxProfit(int[] prices) {
    int n = prices.length;
    if(n == 0) return 0;
    int soFarMin = prices[0];
    int max = 0;
    for(int i = 1; i &lt; n; i++){
        if(soFarMin &gt; prices[i]) soFarMin = prices[i];
        else max = Math.max(max, prices[i] - soFarMin);
    }
    return max;
}</code></pre><p><strong>复制粘贴字符</strong></p>
<p><a href="https://leetcode.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener">Leetcode : 650. 2 Keys Keyboard (Medium)</a></p>
<pre><code>public int minSteps(int n) {
    int[] dp = new int[n + 1];
    for (int i = 2; i &lt;= n; i++) {
        dp[i] = i;
        for (int j = i - 1; j &gt;= 0; j--) {
            if (i % j == 0) {
                dp[i] = dp[j] + dp[i / j];
                break;
            }
        }
    }
    return dp[n];
}</code></pre><pre><code>public int minSteps(int n) {
    if (n == 1) return 0;
    for (int i = 2; i &lt;= Math.sqrt(n); i++) {
        if (n % i == 0) return i + minSteps(n / i);
    }
    return n;
}</code></pre><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p><strong>素数分解</strong></p>
<p>每一个数都可以分解成素数的乘积，例如 84 = 22 * 31 * 50 * 71 * 110 * 130 * 170 * …</p>
<p><strong>整除</strong></p>
<p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * … 令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p>
<p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p>
<p>x 和 y 的 <strong>最大公约数</strong> 为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p>
<p>x 和 y 的 <strong>最小公倍数</strong> 为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p>
<p><strong>生成素数序列</strong></p>
<p><a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">Leetcode : 204. Count Primes (Easy)</a></p>
<p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p>
<pre><code>public int countPrimes(int n) {
    boolean[] notPrimes = new boolean[n + 1];
    int cnt = 0;
    for(int i = 2; i &lt; n; i++){
        if(notPrimes[i]) continue;
        cnt++;
        // 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了
        for(long j = (long) i * i; j &lt; n; j += i){
            notPrimes[(int) j] = true;
        }
    }
    return cnt;
}</code></pre><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><pre><code>int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}</code></pre><p>最大公倍数为两数的乘积除以最大公约数。</p>
<pre><code>int lcm(int a, int b){
    return a * b / gcd(a, b);
}</code></pre><p>对于最大公约数问题，因为需要计算 a % b ，而这个操作是比较耗时的，可以使用 <a href="https://github.com/h2pl/leetcode/blob/master" target="_blank" rel="noopener">编程之美：2.7</a> 的方法，利用减法和移位操作来替换它。</p>
<p>对于 a 和 b 的最大公约数 f(a, b)，有：</p>
<p>\1. 如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2); 2. 如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b); 3. 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2); 4. 如果 a 和 b 均为奇数，f(a, b) = f(a, a-b);</p>
<p>乘 2 和除 2 都可以转换为移位操作。</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>Java 中 static String toString(int num, int radix) 可以将一个整数装换为 redix 进制表示的字符串。</p>
<p><strong>7 进制</strong></p>
<p><a href="https://leetcode.com/problems/base-7/description/" target="_blank" rel="noopener">Leetcode : 504. Base 7 (Easy)</a></p>
<pre><code>public String convertToBase7(int num) {
    if (num &lt; 0) {
        return &#39;-&#39; + convertToBase7(-num);
    }
    if (num &lt; 7) {
        return num + &quot;&quot;;
    }
    return convertToBase7(num / 7) + num % 7;
}</code></pre><p><strong>16 进制</strong></p>
<p><a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="noopener">Leetcode : 405. Convert a Number to Hexadecimal (Easy)</a></p>
<pre><code>public String toHex(int num) {
    char[] map = {&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;};
    if(num == 0) return &quot;0&quot;;
    String ret = &quot;&quot;;
    while(num != 0){
        ret = map[(num &amp; 0b1111)] + ret;
        num &gt;&gt;&gt;= 4;
    }
    return ret;
}</code></pre><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p><strong>统计阶乘尾部有多少个 0</strong></p>
<p><a href="https://leetcode.com/problems/factorial-trailing-zeroes/description/" target="_blank" rel="noopener">Leetcode : 172. Factorial Trailing Zeroes (Easy)</a></p>
<p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52表示不大于 N 的数中 52 的倍数再贡献一个 5 …。</p>
<pre><code>public int trailingZeroes(int n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
}</code></pre><p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 <a href="https://github.com/h2pl/leetcode/blob/master/README.md#" target="_blank" rel="noopener">编程之美：2.2</a> 。和求解有多少个 5 一样，2 的个数为 N/2 + N/22 + N/23 + …</p>
<h3 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h3><p><strong>二进制加法</strong></p>
<p><a href="https://leetcode.com/problems/add-binary/description/" target="_blank" rel="noopener">Leetcode : 67. Add Binary (Easy)</a></p>
<pre><code>a = &quot;11&quot;
b = &quot;1&quot;
Return &quot;100&quot;.</code></pre><pre><code>public String addBinary(String a, String b) {
    int i = a.length() - 1, j = b.length() - 1, carry = 0;
    String str = &quot;&quot;;
    while(i &gt;= 0 || j &gt;= 0){
        if(i &gt;= 0 &amp;&amp; a.charAt(i--) == &#39;1&#39;) carry++;
        if(j &gt;= 0 &amp;&amp; b.charAt(j--) == &#39;1&#39;) carry++;
        str = (carry % 2) + str;
        carry /= 2;
    }
    if(carry == 1) str = &quot;1&quot; + str;
    return str;
}</code></pre><p><strong>字符串加法</strong></p>
<p><a href="https://leetcode.com/problems/add-strings/description/" target="_blank" rel="noopener">Leetcode : 415. Add Strings (Easy)</a></p>
<p>字符串的值为非负整数</p>
<pre><code>public String addStrings(String num1, String num2) {
    StringBuilder sb = new StringBuilder();
    int carry = 0;
    for(int i = num1.length() - 1, j = num2.length() - 1; i &gt;= 0 || j &gt;= 0 || carry == 1; i--, j--){
        int x = i &lt; 0 ? 0 : num1.charAt(i) - &#39;0&#39;;
        int y = j &lt; 0 ? 0 : num2.charAt(j) - &#39;0&#39;;
        sb.append((x + y + carry) % 10);
        carry = (x + y + carry) / 10;
    }
    return sb.reverse().toString();
}</code></pre><h3 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h3><p><strong>改变数组元素使所有的数组元素都相等</strong></p>
<p><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/" target="_blank" rel="noopener">Leetcode : 462. Minimum Moves to Equal Array Elements II (Medium)</a></p>
<pre><code>Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</code></pre><p>每次可以对一个数组元素加一或者减一，求最小的改变次数。</p>
<p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：</p>
<p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。</p>
<p>设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。</p>
<p><strong>解法 1</strong></p>
<p>先排序，时间复杂度：O(NlgN)</p>
<pre><code>public int minMoves2(int[] nums) {
    Arrays.sort(nums);
    int ret = 0;
    int l = 0, h = nums.length - 1;
    while(l &lt;= h) {
        ret += nums[h] - nums[l];
        l++;
        h--;
    }
    return ret;
}</code></pre><p><strong>解法 2</strong></p>
<p>使用快速排序找到中位数，时间复杂度 O(N)</p>
<pre><code>public int minMoves2(int[] nums) {
    int ret = 0;
    int n = nums.length;
    int median = quickSelect(nums, 0, n - 1, n / 2 + 1);
    for(int num : nums) ret += Math.abs(num - median);
    return ret;
}

private int quickSelect(int[] nums, int start, int end, int k) {
    int l = start, r = end, privot = nums[(l + r) / 2];
    while(l &lt;= r) {
        while(nums[l] &lt; privot) l++;
        while(nums[r] &gt; privot) r--;
        if(l &gt;= r) break;
        swap(nums, l, r);
        l++; r--;
    }
    int left = l - start + 1;
    if(left &gt; k) return quickSelect(nums, start, l - 1, k);
    if(left == k &amp;&amp; l == r) return nums[l];
    int right = r - start + 1;
    return quickSelect(nums, r + 1, end, k - right);
}

private void swap(int[] nums, int i, int j) {
    int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
}</code></pre><h3 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h3><p><strong>数组中出现次数多于 n / 2 的元素</strong></p>
<p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Leetcode : 169. Majority Element (Easy)</a></p>
<p>先对数组排序，最中间那个数出现次数一定多于 n / 2</p>
<pre><code>public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length / 2];
}</code></pre><p>可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(n)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不想等时，令 cnt–。如果前面查找了 i 个元素，且 cnt == 0 ，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<pre><code>public int majorityElement(int[] nums) {
    int cnt = 0, majority = 0;
    for(int i = 0; i &lt; nums.length; i++){
        if(cnt == 0) {
            majority = nums[i];
            cnt++;
        }
        else if(majority == nums[i]) cnt++;
        else cnt--;
    }
    return majority;
}</code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><strong>平方数</strong></p>
<p><a href="https://leetcode.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener">Leetcode : 367. Valid Perfect Square (Easy)</a></p>
<pre><code>Input: 16
Returns: True</code></pre><p>平方序列：1,4,9,16,.. 间隔：3,5,7,…</p>
<p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。</p>
<pre><code>public boolean isPerfectSquare(int num) {
    int subNum = 1;
    while (num &gt; 0) {
        num -= subNum;
        subNum += 2;
    }
    return num == 0;
}</code></pre><p><strong>3 的 n 次方</strong></p>
<p><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="noopener">Leetcode : 326. Power of Three (Easy)</a></p>
<pre><code>public boolean isPowerOfThree(int n) {
    return n &gt; 0 &amp;&amp; (1162261467 % n == 0);
}</code></pre><p><strong>找出数组中的乘积最大的三个数</strong></p>
<p><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener">Leetcode : 628. Maximum Product of Three Numbers (Easy)</a></p>
<pre><code>Input: [1,2,3,4]
Output: 24</code></pre><pre><code>public int maximumProduct(int[] nums) {
    int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
    for (int n : nums) {
        if (n &gt; max1) {
            max3 = max2;
            max2 = max1;
            max1 = n;
        } else if (n &gt; max2) {
            max3 = max2;
            max2 = n;
        } else if (n &gt; max3) {
            max3 = n;
        }

        if (n &lt; min1) {
            min2 = min1;
            min1 = n;
        } else if (n &lt; min2) {
            min2 = n;
        }
    }
    return Math.max(max1*max2*max3, max1*min1*min2);
}</code></pre><p><strong>乘积数组</strong></p>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">Leetcode : 238. Product of Array Except Self (Medium)</a></p>
<pre><code>For example, given [1,2,3,4], return [24,12,8,6].</code></pre><p>题目描述：给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p>
<p>题目要求：时间复杂度为 O(n)，并且不能使用除法。</p>
<pre><code>public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] ret = new int[n];
    ret[0] = 1;
    for(int i = 1; i &lt; n; i++) {
        ret[i] = ret[i - 1] * nums[i - 1];
    }
    int right = 1;
    for(int i = n - 1; i &gt;= 0; i--) {
        ret[i] *= right;
        right *= nums[i];
    }
    return ret;
}</code></pre><h1 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h1><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><strong>用栈实现队列</strong></p>
<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">Leetcode : 232. Implement Queue using Stacks (Easy)</a></p>
<p>一个栈实现：</p>
<pre><code>class  MyQueue {
    private Stack&lt;Integer&gt; st = new Stack();

    public void push(int x) {
        Stack&lt;Integer&gt; temp = new Stack();
        while(!st.isEmpty()){
            temp.push(st.pop());
        }
        st.push(x);
        while(!temp.isEmpty()){
            st.push(temp.pop());
        }
    }

    public int pop() {
        return st.pop();
    }

    public int peek() {
        return st.peek();
    }

    public boolean empty() {
        return st.isEmpty();
    }
}</code></pre><p>两个栈实现：</p>
<pre><code>class  MyQueue {
    private Stack&lt;Integer&gt; in = new Stack();
    private Stack&lt;Integer&gt; out = new Stack();

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        in2out();
        return out.pop();
    }

    public int peek() {
        in2out();
        return out.peek();
    }

    private void in2out(){
        if(out.isEmpty()){
            while(!in.isEmpty()){
                out.push(in.pop());
            }
        }
    }

    public boolean empty() {
        return in.isEmpty() &amp;&amp; out.isEmpty();
    }
}</code></pre><p><strong>用队列实现栈</strong></p>
<p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">Leetcode : 225. Implement Stack using Queues (Easy)</a></p>
<pre><code>class MyStack {

    private Queue&lt;Integer&gt; queue;

    public MyStack() {
        queue = new LinkedList&lt;&gt;();
    }

    public void push(int x) {
        queue.add(x);
        for(int i = 1; i &lt; queue.size(); i++){ // 翻转
            queue.add(queue.remove());
        }
    }

    public int pop() {
        return queue.remove();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}</code></pre><p><strong>最小值栈</strong></p>
<p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">Leetcode : 155. Min Stack (Easy)</a></p>
<p>用两个栈实现，一个存储数据，一个存储最小值。</p>
<pre><code>class MinStack {

    private Stack&lt;Integer&gt; dataStack;
    private Stack&lt;Integer&gt; minStack;
    private int min;

    public MinStack() {
        dataStack = new Stack&lt;&gt;();
        minStack = new Stack&lt;&gt;();
        min = Integer.MAX_VALUE;
    }

    public void push(int x) {
        dataStack.add(x);
        if(x &lt; min) {
            min = x;
        }
        minStack.add(min);
    }

    public void pop() {
        dataStack.pop();
        minStack.pop();
        if(!minStack.isEmpty()) {
            min = minStack.peek();
        } else{
            min = Integer.MAX_VALUE;
        }
    }

    public int top() {
        return dataStack.peek();
    }

    public int getMin() {
        return min;
    }
}</code></pre><p>对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。</p>
<p><strong>用栈实现括号匹配</strong></p>
<p><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">Leetcode : 20. Valid Parentheses (Easy)</a></p>
<pre><code>&quot;()[]{}&quot;

Output : true</code></pre><pre><code>public boolean isValid(String s) {
    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
    for(int i = 0; i &lt; s.length(); i++){
        char c = s.charAt(i);
        if(c == &#39;(&#39; || c == &#39;{&#39; || c == &#39;[&#39;) stack.push(c);
        else{
            if(stack.isEmpty()) return false;
            char cStack = stack.pop();
            if(c == &#39;)&#39; &amp;&amp; cStack != &#39;(&#39; ||
              c == &#39;]&#39; &amp;&amp; cStack != &#39;[&#39; ||
              c == &#39;}&#39; &amp;&amp; cStack != &#39;{&#39; ) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}</code></pre><p><strong>数组中元素与下一个比它大的元素之间的距离</strong></p>
<pre><code>Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]</code></pre><p><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="noopener">Leetcode : 739. Daily Temperatures (Medium)</a></p>
<p>在遍历数组时用 Stack 把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。</p>
<pre><code>public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] ret = new int[n];
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for(int i = 0; i &lt; n; i++) {
        while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) {
            int idx = stack.pop();
            ret[idx] = i - idx;
        }
        stack.add(i);
    }
    return ret;
}</code></pre><p><strong>在另一个数组中比当前元素大的下一个元素</strong></p>
<p><a href="https://leetcode.com/problems/next-greater-element-i/description/" target="_blank" rel="noopener">Leetcode : 496. Next Greater Element I (Easy)</a></p>
<pre><code>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]</code></pre><pre><code>public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for(int num : nums2){
        while(!stack.isEmpty() &amp;&amp; num &gt; stack.peek()){
            map.put(stack.pop(), num);
        }
        stack.add(num);
    }
    int[] ret = new int[nums1.length];
    for(int i = 0; i &lt; nums1.length; i++){
        if(map.containsKey(nums1[i])) ret[i] = map.get(nums1[i]);
        else ret[i] = -1;
    }
    return ret;
}</code></pre><p><strong>循环数组中比当前元素大的下一个元素</strong></p>
<p><a href="https://leetcode.com/problems/next-greater-element-ii/description/" target="_blank" rel="noopener">Leetcode : 503. Next Greater Element II (Medium)</a></p>
<pre><code>public int[] nextGreaterElements(int[] nums) {
    int n = nums.length, next[] = new int[n];
    Arrays.fill(next, -1);
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for (int i = 0; i &lt; n * 2; i++) {
        int num = nums[i % n];
        while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)
            next[stack.pop()] = num;
        if (i &lt; n) stack.push(i);
    }
    return next;
}</code></pre><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>利用 Hash Table 可以快速查找一个元素是否存在等问题，但是需要一定的空间来存储。在优先考虑时间复杂度的情况下，可以利用 Hash Table 这种空间换取时间的做法。</p>
<p>Java 中的 <strong>HashSet</strong> 用于存储一个集合，并以 O(1) 的时间复杂度查找元素是否在集合中。</p>
<p>如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在，例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。</p>
<p>Java 中的 <strong>HashMap</strong> 主要用于映射关系，从而把两个元素联系起来。</p>
<p>在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中（<a href="https://leetcode.com/problems/encode-and-decode-tinyurl/description/" target="_blank" rel="noopener">Leetcdoe : 535. Encode and Decode TinyURL (Medium)</a>），利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源。</p>
<p>HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。</p>
<p><strong>数组中的两个数和为给定值</strong></p>
<p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">Leetcode : 1. Two Sum (Easy)</a></p>
<p>可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(nlgn)，空间复杂度为 O(1)。</p>
<p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i] ，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(n)，空间复杂度为 O(n)，使用空间来换取时间。</p>
<pre><code>public int[] twoSum(int[] nums, int target) {
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int i = 0; i &lt; nums.length; i++){
        if(map.containsKey(target - nums[i])) return new int[]{map.get(target - nums[i]), i};
        else map.put(nums[i], i);
    }
    return null;
}</code></pre><p><strong>最长和谐序列</strong></p>
<p><a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener">Leetcode : 594. Longest Harmonious Subsequence (Easy)</a></p>
<pre><code>Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].</code></pre><p>和谐序列中最大数和最小数只差正好为 1。</p>
<pre><code>public int findLHS(int[] nums) {
    Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;();
    for (long num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    int result = 0;
    for (long key : map.keySet()) {
        if (map.containsKey(key + 1)) {
            result = Math.max(result, map.get(key + 1) + map.get(key));
        }
    }
    return result;
}</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>两个字符串包含的字符是否完全相同</strong></p>
<p><a href="https://leetcode.com/problems/valid-anagram/description/" target="_blank" rel="noopener">Leetcode : 242. Valid Anagram (Easy)</a></p>
<pre><code>s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.
s = &quot;rat&quot;, t = &quot;car&quot;, return false.</code></pre><p>字符串只包含小写字符，总共有 26 个小写字符。可以用 Hash Table 来映射字符与出现次数，因为键值范围很小，因此可以使用长度为 26 的整型数组对字符串出现的字符进行统计，比较两个字符串出现的字符数量是否相同。</p>
<pre><code>public boolean isAnagram(String s, String t) {
    int[] cnts = new int[26];
    for(int i  = 0; i &lt; s.length(); i++) cnts[s.charAt(i) - &#39;a&#39;] ++;
    for(int i  = 0; i &lt; t.length(); i++) cnts[t.charAt(i) - &#39;a&#39;] --;
    for(int i  = 0; i &lt; 26; i++) if(cnts[i] != 0) return false;
    return true;
}</code></pre><p><strong>字符串同构</strong></p>
<p><a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">Leetcode : 205. Isomorphic Strings (Easy)</a></p>
<pre><code>Given &quot;egg&quot;, &quot;add&quot;, return true.
Given &quot;foo&quot;, &quot;bar&quot;, return false.
Given &quot;paper&quot;, &quot;title&quot;, return true.</code></pre><p>记录一个字符上次出现的位置，如果两个字符串中某个字符上次出现的位置一样，那么就属于同构。</p>
<pre><code>public boolean isIsomorphic(String s, String t) {
    int[] m1 = new int[256];
    int[] m2 = new int[256];
    for(int i = 0; i &lt; s.length(); i++){
        if(m1[s.charAt(i)] != m2[t.charAt(i)]) {
            return false;
        }
        m1[s.charAt(i)] = i + 1;
        m2[t.charAt(i)] = i + 1;
    }
    return true;
}</code></pre><p><strong>计算一组字符集合可以组成的回文字符串的最大长度</strong></p>
<p><a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">Leetcode : 409. Longest Palindrome (Easy)</a></p>
<pre><code>Input : &quot;abccccdd&quot;
Output : 7
Explanation : One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</code></pre><p>使用长度为 128 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。</p>
<pre><code>public int longestPalindrome(String s) {
    int[] cnts = new int[128]; // ascii 码总共 128 个
    for(char c : s.toCharArray()) cnts[c]++;
    int ret = 0;
    for(int cnt : cnts)  ret += (cnt / 2) * 2;
    if(ret &lt; s.length()) ret++; // 这个条件下 s 中一定有单个未使用的字符存在，可以把这个字符放到回文的最中间
    return ret;
}</code></pre><p><strong>判断一个整数是否是回文数</strong></p>
<p><a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener">Leetcode : 9. Palindrome Number (Easy)</a></p>
<p>要求不能使用额外空间，也就不能将整数转换为字符串进行判断。</p>
<p>将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。</p>
<pre><code>public boolean isPalindrome(int x) {
    if(x == 0) return true;
    if(x &lt; 0) return false;
    if(x % 10 == 0) return false;
    int right = 0;
    while(x &gt; right){
        right = right * 10 + x % 10;
        x /= 10;
    }
    return x == right || x == right / 10;
}</code></pre><p><strong>回文子字符串</strong></p>
<p><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">Leetcode : 647. Palindromic Substrings (Medium)</a></p>
<pre><code>Input: &quot;aaa&quot;
Output: 6
Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</code></pre><p>解决方案是从字符串的某一位开始，尝试着去扩展子字符串。</p>
<pre><code>private int cnt = 0;
public int countSubstrings(String s) {
    for(int i = 0; i &lt; s.length(); i++) {
        extendSubstrings(s, i, i);    // 奇数长度
        extendSubstrings(s, i, i + 1); // 偶数长度
    }
    return cnt;
}

private void extendSubstrings(String s, int start, int end) {
    while(start &gt;= 0 &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end)) {
        start--;
        end++;
        cnt++;
    }
}</code></pre><p><strong>统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</strong></p>
<p><a href="https://leetcode.com/problems/count-binary-substrings/description/" target="_blank" rel="noopener">Leetcode : 696. Count Binary Substrings (Easy)</a></p>
<pre><code>Input: &quot;00110011&quot;
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.</code></pre><pre><code>public int countBinarySubstrings(String s) {
    int preLen = 0, curLen = 1, ret = 0;
    for(int i = 1; i &lt; s.length(); i++){
        if(s.charAt(i) == s.charAt(i-1)) curLen++;
        else{
            preLen = curLen;
            curLen = 1;
        }

        if(preLen &gt;= curLen) ret++;
    }
    return ret;
}</code></pre><p><strong>字符串循环移位包含</strong></p>
<p><a href="https://github.com/h2pl/leetcode/blob/master/README.md#" target="_blank" rel="noopener">编程之美：3.1</a></p>
<pre><code>s1 = AABCD, s2 = CDAA
Return : true</code></pre><p>给定两个字符串 s1 和 s2 ，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。</p>
<p>s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。</p>
<p><strong>字符串循环移位</strong></p>
<p><a href="https://github.com/h2pl/leetcode/blob/master/README.md#" target="_blank" rel="noopener">编程之美：2.17</a></p>
<p>将字符串向右循环移动 k 位。</p>
<p>例如 abcd123 向右移动 3 位 得到 123abcd</p>
<p>将 abcd123 中的 abcd 和 123 单独逆序，得到 dcba321，然后对整个字符串进行逆序，得到 123abcd。</p>
<p><strong>字符串中单词的翻转</strong></p>
<p><a href="https://github.com/h2pl/leetcode/blob/master/README.md#" target="_blank" rel="noopener">程序员代码面试指南</a></p>
<p>例如将 “I am a student” 翻转成 “student a am I”</p>
<p>将每个单词逆序，然后将整个字符串逆序。</p>
<h2 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h2><p><strong>把数组中的 0 移到末尾</strong></p>
<p><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">Leetcode : 283. Move Zeroes (Easy)</a></p>
<pre><code>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</code></pre><pre><code>public void moveZeroes(int[] nums) {
    int n = nums.length;
    int idx = 0;
    for(int i = 0; i &lt; n; i++){
        if(nums[i] != 0) nums[idx++] = nums[i];
    }
    while(idx &lt; n){
        nums[idx++] = 0;
    }
}</code></pre><h3 id="1-n-分布"><a href="#1-n-分布" class="headerlink" title="1-n 分布"></a>1-n 分布</h3><p><strong>一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出丢失的数和重复的数</strong></p>
<p><a href="https://leetcode.com/problems/set-mismatch/description/" target="_blank" rel="noopener">Leetcode : 645. Set Mismatch (Easy)</a></p>
<pre><code>Input: nums = [1,2,2,4]
Output: [2,3]</code></pre><p>最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(nlogn).本题可以以 O(n) 的时间复杂度、O(1) 空间复杂度来求解。</p>
<p>主要思想是让通过交换数组元素，使得数组上的元素在正确的位置上</p>
<p>遍历数组，如果第 i 位上的元素不是 i + 1 ，那么就交换第 i 位 和 nums[i] - 1 位上的元素，使得 num[i] - 1 的元素为 nums[i] ，也就是该位的元素是正确的。交换操作需要循环进行，因为一次交换没办法使得第 i 位上的元素是正确的。但是要交换的两个元素可能就是重复元素，那么循环就可能永远进行下去，终止循环的方法是加上 nums[i] != nums[nums[i] - 1 条件。</p>
<p>类似题目：</p>
<ul>
<li><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/" target="_blank" rel="noopener">Leetcode :448. Find All Numbers Disappeared in an Array (Easy)</a>，寻找所有丢失的元素</li>
<li><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/description/" target="_blank" rel="noopener">Leetcode : 442. Find All Duplicates in an Array (Medium)</a>，寻找所有重复的元素。</li>
</ul>
<pre><code>public int[] findErrorNums(int[] nums) {
    for(int i = 0; i &lt; nums.length; i++){
        while(nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1]) {
            swap(nums, i, nums[i] - 1);
        }
    }

    for(int i = 0; i &lt; nums.length; i++){
        if(i + 1 != nums[i]) {
            return new int[]{nums[i], i + 1};
        }
    }

    return null;
}

private void swap(int[] nums, int i, int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}</code></pre><p><strong>找出数组中重复的数，数组值在 [0, n-1] 之间</strong></p>
<p><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">Leetcode : 287. Find the Duplicate Number (Medium)</a></p>
<p>二分查找解法：</p>
<pre><code>public int findDuplicate(int[] nums) {
     int l = 1, h = nums.length - 1;
     while (l &lt;= h) {
         int mid = l + (h - l) / 2;
         int cnt = 0;
         for (int i = 0; i &lt; nums.length; i++) {
             if (nums[i] &lt;= mid) cnt++;
         }
         if (cnt &gt; mid) h = mid - 1;
         else l = mid + 1;
     }
     return l;
}</code></pre><p>双指针解法，类似于有环链表中找出环的入口：</p>
<pre><code>public int findDuplicate(int[] nums) {
      int slow = nums[0], fast = nums[nums[0]];
      while (slow != fast) {
          slow = nums[slow];
          fast = nums[nums[fast]];
      }

      fast = 0;
      while (slow != fast) {
          slow = nums[slow];
          fast = nums[fast];
      }
      return slow;
}</code></pre><h3 id="有序矩阵"><a href="#有序矩阵" class="headerlink" title="有序矩阵"></a>有序矩阵</h3><p>有序矩阵指的是行和列分别有序的矩阵。一般可以利用有序性使用二分查找方法。</p>
<pre><code>[
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
]</code></pre><p><strong>有序矩阵查找</strong></p>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">Leetocde : 240. Search a 2D Matrix II (Medium)</a></p>
<pre><code>public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
    int m = matrix.length, n = matrix[0].length;
    int row = 0, col = n - 1;
    while (row &lt; m &amp;&amp; col &gt;= 0) {
        if (target == matrix[row][col]) return true;
        else if (target &lt; matrix[row][col]) col--;
        else row++;
    }
    return false;
}</code></pre><p><strong>有序矩阵的 Kth Element</strong></p>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="noopener">Leetcode : 378. Kth Smallest Element in a Sorted Matrix ((Medium))</a></p>
<pre><code>matrix = [
  [ 1,  5,  9],
  [10, 11, 13],
  [12, 13, 15]
],
k = 8,

return 13.</code></pre><p>解题参考：<a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173" target="_blank" rel="noopener">Share my thoughts and Clean Java Code</a></p>
<p>二分查找解法：</p>
<pre><code>public int kthSmallest(int[][] matrix, int k) {
    int m = matrix.length, n = matrix[0].length;
    int lo = matrix[0][0], hi = matrix[m - 1][n - 1];
    while(lo &lt;= hi) {
        int mid = lo + (hi - lo) / 2;
        int cnt = 0;
        for(int i = 0; i &lt; m; i++) {
            for(int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) {
                cnt++;
            }
        }
        if(cnt &lt; k) lo = mid + 1;
        else hi = mid - 1;
    }
    return lo;
}</code></pre><p>堆解法：</p>
<pre><code>public int kthSmallest(int[][] matrix, int k) {
    int m = matrix.length, n = matrix[0].length;
    PriorityQueue&lt;Tuple&gt; pq = new PriorityQueue&lt;Tuple&gt;();
    for(int j = 0; j &lt; n; j++) pq.offer(new Tuple(0, j, matrix[0][j]));
    for(int i = 0; i &lt; k - 1; i++) { // 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数
        Tuple t = pq.poll();
        if(t.x == m - 1) continue;
        pq.offer(new Tuple(t.x + 1, t.y, matrix[t.x + 1][t.y]));
    }
    return pq.poll().val;
}

class Tuple implements Comparable&lt;Tuple&gt; {
    int x, y, val;
    public Tuple(int x, int y, int val) {
        this.x = x; this.y = y; this.val = val;
    }

    @Override
    public int compareTo(Tuple that) {
        return this.val - that.val;
    }
}</code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>判断两个链表的交点</strong></p>
<p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Leetcode : 160. Intersection of Two Linked Lists (Easy)</a></p>
<pre><code>A:          a1 → a2
                  ↘
                    c1 → c2 → c3
                  ↗
B:    b1 → b2 → b3</code></pre><p>要求：时间复杂度为 O(n) 空间复杂度为 O(1)</p>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<pre><code>public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if(headA == null || headB == null) return null;
    ListNode l1 = headA, l2 = headB;
    while(l1 != l2){
        l1 = (l1 == null) ? headB : l1.next;
        l2 = (l2 == null) ? headA : l2.next;
    }
    return l1;
}</code></pre><p>如果只是判断是否存在交点，那么就是另一个问题，即 <a href="https://github.com/h2pl/leetcode/blob/master" target="_blank" rel="noopener">编程之美：3.6</a> 的问题。有两种解法：把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；或者直接比较第一个链表最后一个节点和第二个链表最后一个节点是否相同。</p>
<p><strong>链表反转</strong></p>
<p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">Leetcode : 206. Reverse Linked List (Easy)</a></p>
<p>头插法能够按逆序构建链表。</p>
<pre><code>public ListNode reverseList(ListNode head) {
    ListNode newHead = null; // 设为 null，作为新链表的结尾
    while(head != null){
        ListNode nextNode = head.next;
        head.next = newHead;
        newHead = head;
        head = nextNode;
    }
    return newHead;
}</code></pre><p><strong>归并两个有序的链表</strong></p>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">Leetcode : 21. Merge Two Sorted Lists (Easy)</a></p>
<p>链表和树一样，可以用递归方式来定义：链表是空节点，或者有一个值和一个指向下一个链表的指针。因此很多链表问题可以用递归来处理。</p>
<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if(l1 == null) return l2;
    if(l2 == null) return l1;
    ListNode newHead = null;
    if(l1.val &lt; l2.val){
        newHead = l1;
        newHead.next = mergeTwoLists(l1.next, l2);
    } else{
        newHead = l2;
        newHead.next = mergeTwoLists(l1, l2.next);
    }
    return newHead;
}</code></pre><p><strong>从有序链表中删除重复节点</strong></p>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">Leetcode : 83. Remove Duplicates from Sorted List (Easy)</a></p>
<pre><code>public ListNode deleteDuplicates(ListNode head) {
    if(head == null || head.next == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.next != null &amp;&amp; head.val == head.next.val ? head.next : head;
}</code></pre><p><strong>回文链表</strong></p>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Leetcode : 234. Palindrome Linked List (Easy)</a></p>
<p>切成两半，把后半段反转，然后比较两半是否相等。</p>
<pre><code>public boolean isPalindrome(ListNode head) {
    if(head == null || head.next == null) return true;
    ListNode slow = head, fast = head.next;
    while(fast != null &amp;&amp; fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }

    if(fast != null){  // 偶数节点，让 slow 指向下一个节点
        slow = slow.next;
    }

    cut(head, slow); // 切成两个链表
    ListNode l1 = head, l2 = slow;
    l2 = reverse(l2);
    return isEqual(l1, l2);
}

private void cut(ListNode head, ListNode cutNode){
    while( head.next != cutNode ) head = head.next;
    head.next = null;
}

private ListNode reverse(ListNode head){
    ListNode newHead = null;
    while(head != null){
        ListNode nextNode = head.next;
        head.next = newHead;
        newHead = head;
        head = nextNode;
    }
    return newHead;
}

private boolean isEqual(ListNode l1, ListNode l2){
    while(l1 != null &amp;&amp; l2 != null){
        if(l1.val != l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    }
    return true;
}</code></pre><p><strong>链表元素按奇偶聚集</strong></p>
<p><a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">Leetcode : 328. Odd Even Linked List (Medium)</a></p>
<pre><code>Example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,
return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</code></pre><pre><code>public ListNode oddEvenList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode odd = head, even = head.next, evenHead = even;
    while (even != null &amp;&amp; even.next != null) {
        odd.next = odd.next.next;
        odd = odd.next;
        even.next = even.next.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
}</code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。</p>
<p><strong>树的高度</strong></p>
<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 104. Maximum Depth of Binary Tree (Easy)</a></p>
<pre><code>public int maxDepth(TreeNode root) {
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}</code></pre><p><strong>翻转树</strong></p>
<p><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 226. Invert Binary Tree (Easy)</a></p>
<pre><code>public TreeNode invertTree(TreeNode root) {
    if(root == null) return null;
    TreeNode left = root.left; // 后面的操作会改变 left 指针，因此先保存下来
    root.left = invertTree(root.right);
    root.right = invertTree(left);
    return root;
}</code></pre><p><strong>归并两棵树</strong></p>
<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">Leetcode : 617. Merge Two Binary Trees (Easy)</a></p>
<pre><code>Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7
Output:
Merged tree:
         3
        / \
       4   5
      / \   \
     5   4   7</code></pre><pre><code>public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if(t1 == null &amp;&amp; t2 == null) return null;
    if(t1 == null) return t2;
    if(t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
}</code></pre><p><strong>判断路径和是否等于一个数</strong></p>
<p><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">Leetcdoe : 112. Path Sum (Easy)</a></p>
<pre><code>Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</code></pre><p>路径和定义为从 root 到 leaf 的所有节点的和</p>
<pre><code>public boolean hasPathSum(TreeNode root, int sum) {
    if(root == null) return false;
    if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}</code></pre><p><strong>统计路径和等于一个数的路径数量</strong></p>
<p><a href="https://leetcode.com/problems/path-sum-iii/description/" target="_blank" rel="noopener">Leetcode : 437. Path Sum III (Easy)</a></p>
<pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11</code></pre><p>路径不一定以 root 开头并以 leaf 结尾，但是必须连续</p>
<pre><code>public int pathSum(TreeNode root, int sum) {
    if(root == null) return 0;
    int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return ret;
}

private int pathSumStartWithRoot(TreeNode root, int sum){
    if(root == null) return 0;
    int ret = 0;
    if(root.val == sum) ret++;
    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
    return ret;
}</code></pre><p><strong>树的对称</strong></p>
<p><a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Leetcode : 101. Symmetric Tree (Easy)</a></p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><pre><code>public boolean isSymmetric(TreeNode root) {
    if(root == null) return true;
    return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode t1, TreeNode t2){
    if(t1 == null &amp;&amp; t2 == null) return true;
    if(t1 == null || t2 == null) return false;
    if(t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);
}</code></pre><p><strong>平衡树</strong></p>
<p><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 110. Balanced Binary Tree (Easy)</a></p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>平衡树左右子树高度差都小于等于 1</p>
<pre><code>private boolean result = true;

public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) &gt; 1) result = false;
    return 1 + Math.max(l, r);
}</code></pre><p><strong>最小路径</strong></p>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 111. Minimum Depth of Binary Tree (Easy)</a></p>
<p>树的根节点到叶子节点的最小路径长度</p>
<pre><code>public int minDepth(TreeNode root) {
    if(root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if(left == 0 || right == 0) return left + right + 1;
    return Math.min(left, right) + 1;
}</code></pre><p><strong>统计左叶子节点的和</strong></p>
<p><a href="https://leetcode.com/problems/sum-of-left-leaves/description/" target="_blank" rel="noopener">Leetcode : 404. Sum of Left Leaves (Easy)</a></p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</code></pre><pre><code>public int sumOfLeftLeaves(TreeNode root) {
    if(root == null) {
        return 0;
    }
    if(isLeaf(root.left)) {
        return root.left.val +  sumOfLeftLeaves(root.right);
    }
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}

private boolean isLeaf(TreeNode node){
    if(node == null) {
        return false;
    }
    return node.left == null &amp;&amp; node.right == null;
}</code></pre><p><strong>修剪二叉查找树</strong></p>
<p><a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 669. Trim a Binary Search Tree (Easy)</a></p>
<pre><code>Input: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output: 
      3
     / 
   2   
  /
 1</code></pre><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p>
<p>只保留值在 L ~ R 之间的节点</p>
<pre><code>public TreeNode trimBST(TreeNode root, int L, int R) {
    if(root == null) return null;
    if(root.val &gt; R) return trimBST(root.left, L, R);
    if(root.val &lt; L) return trimBST(root.right, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
}</code></pre><p><strong>子树</strong></p>
<p><a href="https://leetcode.com/problems/subtree-of-another-tree/description/" target="_blank" rel="noopener">Leetcode : 572. Subtree of Another Tree (Easy)</a></p>
<pre><code>Given tree s:
     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4 
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.</code></pre><pre><code>public boolean isSubtree(TreeNode s, TreeNode t) {
    if(s == null &amp;&amp; t == null) return true;
    if(s == null || t == null) return false;
    if(s.val == t.val &amp;&amp; isSame(s, t)) return true;
    return isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSame(TreeNode s, TreeNode t){
    if(s == null &amp;&amp; t == null) return true;
    if(s == null || t == null) return false;
    if(s.val != t.val) return false;
    return isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right);
}</code></pre><p><strong>从有序数组中构造二叉查找树</strong></p>
<p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 108. Convert Sorted Array to Binary Search Tree (Easy)</a></p>
<pre><code>public TreeNode sortedArrayToBST(int[] nums) {
    return toBST(nums, 0, nums.length - 1);
}

private TreeNode toBST(int[] nums, int sIdx, int eIdx){
    if(sIdx &gt; eIdx) return null;
    int mIdx = (sIdx + eIdx) / 2;
    TreeNode root = new TreeNode(nums[mIdx]);
    root.left =  toBST(nums, sIdx, mIdx - 1);
    root.right = toBST(nums, mIdx + 1, eIdx);
    return root;
}</code></pre><p><strong>两节点的最长路径</strong></p>
<pre><code>Input:

         1
        / \
       2  3
      / \
      4  5

Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</code></pre><p><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 543. Diameter of Binary Tree (Easy)</a></p>
<pre><code>private int max = 0;

public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return max;
}

private int depth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
}</code></pre><p><strong>找出二叉树中第二小的节点</strong></p>
<p><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 671. Second Minimum Node In a Binary Tree (Easy)</a></p>
<pre><code>Input:
   2
  / \
 2   5
    / \
    5  7

Output: 5</code></pre><p>一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。</p>
<pre><code>public int findSecondMinimumValue(TreeNode root) {
    if(root == null) return -1;
    if(root.left == null &amp;&amp; root.right == null) return -1;
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if(leftVal == root.val) leftVal = findSecondMinimumValue(root.left);
    if(rightVal == root.val) rightVal = findSecondMinimumValue(root.right);
    if(leftVal != -1 &amp;&amp; rightVal != -1) return Math.min(leftVal, rightVal);
    if(leftVal != -1) return leftVal;
    return rightVal;
}</code></pre><p><strong>二叉查找树的最近公共祖先</strong></p>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></p>
<pre><code>        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</code></pre><pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q);
    if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}</code></pre><p><strong>二叉树的最近公共祖先</strong></p>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 236. Lowest Common Ancestor of a Binary Tree (Medium)</a></p>
<pre><code>       _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</code></pre><pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}</code></pre><p><strong>相同节点值的最大路径长度</strong></p>
<p><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">Leetcode : 687. Longest Univalue Path (Easy)</a></p>
<pre><code>             1
            / \
           4   5
          / \   \
         4  4    5

Output : 2</code></pre><pre><code>private int path = 0;
public int longestUnivaluePath(TreeNode root) {
    dfs(root);
    return path;
}

private int dfs(TreeNode root){
    if(root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int leftPath = root.left != null &amp;&amp; root.left.val == root.val ? left + 1 : 0;
    int rightPath = root.right != null &amp;&amp; root.right.val == root.val ? right + 1 : 0;
    path = Math.max(path, leftPath + rightPath);
    return Math.max(leftPath, rightPath);
}</code></pre><p><strong>间隔遍历</strong></p>
<p><a href="https://leetcode.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">Leetcode : 337. House Robber III (Medium)</a></p>
<pre><code>     3
    / \
   2   3
    \   \ 
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</code></pre><pre><code>public int rob(TreeNode root) {
    if (root == null) return 0;
    int val1 = root.val;
    if (root.left != null) {
        val1 += rob(root.left.left) + rob(root.left.right);
    }
    if (root.right != null) {
        val1 += rob(root.right.left) + rob(root.right.right);
    }
    int val2 = rob(root.left) + rob(root.right);
    return Math.max(val1, val2);
}</code></pre><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<p><strong>一棵树每层节点的平均数</strong></p>
<p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="noopener">637. Average of Levels in Binary Tree (Easy)</a></p>
<pre><code>public List&lt;Double&gt; averageOfLevels(TreeNode root) {
    List&lt;Double&gt; ret = new ArrayList&lt;&gt;();
    if(root == null) return ret;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()){
        int cnt = queue.size();
        double sum = 0;
        for(int i = 0; i &lt; cnt; i++){
            TreeNode node = queue.poll();
            sum += node.val;
            if(node.left != null) queue.add(node.left);
            if(node.right != null) queue.add(node.right);
        }
        ret.add(sum / cnt);
    }
    return ret;
}</code></pre><p><strong>得到左下角的节点</strong></p>
<p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Leetcode : 513. Find Bottom Left Tree Value (Easy)</a></p>
<pre><code>Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7</code></pre><pre><code>public int findBottomLeftValue(TreeNode root) {
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()){
        root = queue.poll();
        if(root.right != null) queue.add(root.right);
        if(root.left != null) queue.add(root.left);
    }
    return root.val;
}</code></pre><h3 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h3><pre><code>   1
  / \
  2  3
 / \  \
4  5  6</code></pre><p>层次遍历顺序：[1 2 3 4 5 6] 前序遍历顺序：[1 2 4 5 3 6] 中序遍历顺序：[4 2 5 1 3 6] 后序遍历顺序：[4 5 2 6 3 1]</p>
<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。</p>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
<p>① 前序</p>
<pre><code>void dfs(TreeNode root){
    visit(root);
    dfs(root.left);
    dfs(root.right);
}</code></pre><p>② 中序</p>
<pre><code>void dfs(TreeNode root){
    dfs(root.left);
    visit(root);
    dfs(root.right);
}</code></pre><p>③ 后序</p>
<pre><code>void dfs(TreeNode root){
    dfs(root.left);
    dfs(root.right);
    visit(root);
}</code></pre><p><strong>非递归实现二叉树的前序遍历</strong></p>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 144. Binary Tree Preorder Traversal (Medium)</a></p>
<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        ret.add(node.val);
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left); // 先添加右子树再添加左子树，这样是为了让左子树在栈顶
    }
    return ret;
}</code></pre><p><strong>非递归实现二叉树的后序遍历</strong></p>
<p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 145. Binary Tree Postorder Traversal (Medium)</a></p>
<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root，可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        ret.add(node.val);
        if (node.left != null) stack.push(node.left);
        if (node.right != null) stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}</code></pre><p><strong>非递归实现二叉树的中序遍历</strong></p>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 94. Binary Tree Inorder Traversal (Medium)</a></p>
<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode cur = root;
    while(cur != null || !stack.isEmpty()) {
        while(cur != null) { // 模拟递归栈的不断深入
            stack.add(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}</code></pre><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><p>主要利用 BST 中序遍历有序的特点。</p>
<p><strong>在 BST 中寻找两个节点，使它们的和为一个给定值</strong></p>
<p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST (Easy)</a></p>
<pre><code>Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True</code></pre><p>使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。</p>
<p>应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。</p>
<pre><code>public boolean findTarget(TreeNode root, int k) {
    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    inOrder(root, nums);
    int i = 0, j = nums.size() - 1;
    while(i &lt; j){
        int sum = nums.get(i) + nums.get(j);
        if(sum == k) return true;
        if(sum &lt; k) i++;
        else j--;
    }
    return false;
}

private void inOrder(TreeNode root, List&lt;Integer&gt; nums){
    if(root == null) return;
    inOrder(root.left, nums);
    nums.add(root.val);
    inOrder(root.right, nums);
}</code></pre><p><strong>在 BST 中查找两个节点之差的最小绝对值</strong></p>
<p><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/" target="_blank" rel="noopener">Leetcode : 530. Minimum Absolute Difference in BST (Easy)</a></p>
<pre><code>Input:
   1
    \
     3
    /
   2

Output:
1</code></pre><p>利用 BST 的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</p>
<pre><code>private int minDiff = Integer.MAX_VALUE;
private int preVal = -1;

public int getMinimumDifference(TreeNode root) {
    inorder(root);
    return minDiff;
}

private void inorder(TreeNode node){
    if(node == null) return;
    inorder(node.left);
    if(preVal != -1) minDiff = Math.min(minDiff, Math.abs(node.val - preVal));
    preVal = node.val;
    inorder(node.right);
}</code></pre><p><strong>把 BST 每个节点的值都加上比它大的节点的值</strong></p>
<p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/" target="_blank" rel="noopener">Leetcode : Convert BST to Greater Tree (Easy)</a></p>
<pre><code>Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13

Output: The root of a Greater Tree like this:
             18
            /   \
          20     13</code></pre><p>先遍历右子树。</p>
<pre><code>private int sum = 0;

public TreeNode convertBST(TreeNode root) {
    traver(root);
    return root;
}

private void traver(TreeNode root) {
    if (root == null) {
        return;
    }
    if (root.right != null) {
        traver(root.right);
    }
    sum += root.val;
    root.val = sum;
    if (root.left != null) {
        traver(root.left);
    }
}</code></pre><p><strong>寻找 BST 中出现次数最多的节点</strong></p>
<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 501. Find Mode in Binary Search Tree (Easy)</a></p>
<pre><code>   1
    \
     2
    /
   2
return [2].</code></pre><pre><code>private int cnt = 1;
private int maxCnt = 1;
private TreeNode preNode = null;
private List&lt;Integer&gt; list;

public int[] findMode(TreeNode root) {
    list = new ArrayList&lt;&gt;();
    inorder(root);
    int[] ret = new int[list.size()];
    int idx = 0;
    for(int num : list){
        ret[idx++] = num;
    }
    return ret;
}

private void inorder(TreeNode node){
    if(node == null) return;
    inorder(node.left);
    if(preNode != null){
        if(preNode.val == node.val) cnt++;
        else cnt = 1;
    }
    if(cnt &gt; maxCnt){
        maxCnt = cnt;
        list.clear();
        list.add(node.val);
    } else if(cnt == maxCnt){
        list.add(node.val);
    }
    preNode = node;
    inorder(node.right);
}</code></pre><p><strong>寻找 BST 的第 k 个元素</strong></p>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">Leetcode : 230. Kth Smallest Element in a BST (Medium)</a></p>
<p>递归解法：</p>
<pre><code>public int kthSmallest(TreeNode root, int k) {
    int leftCnt = count(root.left);
    if(leftCnt == k - 1) return root.val;
    if(leftCnt &gt; k - 1) return kthSmallest(root.left, k);
    return kthSmallest(root.right, k - leftCnt - 1);
}

private int count(TreeNode node) {
    if(node == null) return 0;
    return 1 + count(node.left) + count(node.right);
}</code></pre><p>中序遍历解法：</p>
<pre><code>private int cnt = 0;
private int val;

public int kthSmallest(TreeNode root, int k) {
    inorder(root, k);
    return val;
}

private void inorder(TreeNode node, int k) {
    if(node == null) return;
    inorder(node.left, k);
    cnt++;
    if(cnt == k) {
        val = node.val;
        return;
    }
    inorder(node.right, k);
}</code></pre><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p><a href="https://github.com/h2pl/leetcode/blob/pics/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg" target="_blank" rel="noopener"><img src="https://github.com/h2pl/leetcode/raw/pics/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg" alt="img"></a></p>
<p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>
<p><strong>实现一个 Trie</strong></p>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Leetcode : 208. Implement Trie (Prefix Tree) (Medium)</a></p>
<pre><code>class Trie {

    private class Node{
        Node[] childs = new Node[26];
        boolean isLeaf;
    }

    private Node root = new Node();

    /** Initialize your data structure here. */
    public Trie() {
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        int idx = word.charAt(0) - &#39;a&#39;;
        insert(word, root);
    }

    private void insert(String word, Node node){
        int idx = word.charAt(0) - &#39;a&#39;;
        if(node.childs[idx] == null){
            node.childs[idx] = new Node();
        }
        if(word.length() == 1) node.childs[idx].isLeaf = true;
        else insert(word.substring(1), node.childs[idx]);
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, Node node){
        if(node == null) return false;
        int idx = word.charAt(0) - &#39;a&#39;;
        if(node.childs[idx] == null) return false;
        if(word.length() == 1) return node.childs[idx].isLeaf;
        return search(word.substring(1), node.childs[idx]);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return startWith(prefix, root);
    }

    private boolean startWith(String prefix, Node node){
        if(node == null) return false;
        if(prefix.length() == 0) return true;
        int idx = prefix.charAt(0) - &#39;a&#39;;
        return startWith(prefix.substring(1), node.childs[idx]);
    }
}</code></pre><p><strong>实现一个 Trie，用来求前缀和</strong></p>
<p><a href="https://leetcode.com/problems/map-sum-pairs/description/" target="_blank" rel="noopener">Leetcode : 677. Map Sum Pairs (Medium)</a></p>
<pre><code>Input: insert(&quot;apple&quot;, 3), Output: Null
Input: sum(&quot;ap&quot;), Output: 3
Input: insert(&quot;app&quot;, 2), Output: Null
Input: sum(&quot;ap&quot;), Output: 5</code></pre><pre><code>class MapSum {
    private class Trie {
        int val;
        Map&lt;Character, Trie&gt; childs;
        boolean isWord;

        Trie() {
            childs = new HashMap&lt;&gt;();
        }
    }

    private Trie root;

    public MapSum() {
        root = new Trie();
    }

    public void insert(String key, int val) {
        Trie cur = root;
        for(char c : key.toCharArray()) {
            if(!cur.childs.containsKey(c)) {
                Trie next = new Trie();
                cur.childs.put(c, next);
            }
            cur = cur.childs.get(c);
        }
        cur.val = val;
        cur.isWord = true;
    }

    public int sum(String prefix) {
        Trie cur = root;
        for(char c : prefix.toCharArray()) {
            if(!cur.childs.containsKey(c)) return 0;
            cur = cur.childs.get(c);
        }
        return dfs(cur);
    }

    private int dfs(Trie cur) {
        int sum = 0;
        if(cur.isWord) {
            sum += cur.val;
        }
        for(Trie next : cur.childs.values()) {
            sum += dfs(next);
        }
        return sum;
    }
}</code></pre><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><strong>1. 基本原理</strong></p>
<p>0s 表示 一串 0 ，1s 表示一串 1。</p>
<pre><code>x ^ 0s = x      x &amp; 0s = 0      x | 0s = x
x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s
x ^ x = 0       x &amp; x = x       x | x = x</code></pre><p>① 利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数； ② 利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask ：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位； ③ 利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设置操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1 。</p>
<p>&gt;&gt; n 为算术右移，相当于除以 2n； &gt;&gt;&gt; n 为无符号右移，左边会补上 0。 &lt;&lt; n 为算术左移，相当于乘以 2n。</p>
<p>n&amp;(n-1) 该位运算是去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110 <strong>100</strong> ，减去 1 得到 10110<strong>011</strong>，这两个数相与得到 10110<strong>000</strong>。</p>
<p>n-n&amp;(~n+1) 概运算是去除 n 的位级表示中最高的那一位。</p>
<p>n&amp;(-n) 该运算得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110 <strong>100</strong> ，-n 得到 01001<strong>100</strong>，相与得到 00000<strong>100</strong></p>
<p><strong>2. mask 计算</strong></p>
<p>要获取 111111111，将 0 取反即可，~0。</p>
<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i 位即可，1&lt;&lt;i 。例如 1&lt;&lt;5 得到只有第 5 位为 1 的 mask ：00010000。</p>
<p>要得到 1 到 i 位为 1 的 mask，1&lt;&lt;(i+1)-1 即可，例如将 1&lt;&lt;(4+1)-1 = 00010000-1 = 00001111。</p>
<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。</p>
<p><strong>3. 位操作举例</strong></p>
<p>① 获取第 i 位</p>
<p>num &amp; 00010000 != 0</p>
<pre><code>(num &amp; (1 &lt;&lt; i)) != 0;</code></pre><p>② 将第 i 位设置为 1</p>
<p>num | 00010000</p>
<pre><code>num | (1 &lt;&lt; i);</code></pre><p>③ 将第 i 位清除为 0</p>
<p>num &amp; 11101111</p>
<pre><code>num &amp; (~(1 &lt;&lt; i))</code></pre><p>④ 将最高位到第 i 位清除为 0</p>
<p>num &amp; 00001111</p>
<pre><code>num &amp; ((1 &lt;&lt; i) - 1);</code></pre><p>⑤ 将第 0 位到第 i 位清除为 0</p>
<p>num &amp; 11110000</p>
<pre><code>num &amp; (~((1 &lt;&lt; (i+1)) - 1));</code></pre><p>⑥ 将第 i 位设置为 0 或者 1</p>
<p>先将第 i 位清零，然后将 v 左移 i 位，执行“位或”运算。</p>
<pre><code>(num &amp; (1 &lt;&lt; i)) | (v &lt;&lt; i);</code></pre><p><strong>4. Java 中的位操作</strong></p>
<pre><code>static int Integer.bitCount()            // 统计 1 的数量
static int Integer.highestOneBit()       // 获得最高位
static String toBinaryString(int i)      // 转换位二进制表示的字符串</code></pre><p><strong>统计两个数的二进制表示有多少位不同</strong></p>
<p><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">Leetcode : 461. Hamming Distance (Easy)</a></p>
<p>对两个数进行异或操作，不同的那一位结果为 1 ，统计有多少个 1 即可。</p>
<pre><code>public int hammingDistance(int x, int y) {
    int z = x ^ y;
    int cnt = 0;
    while(z != 0){
        if((z &amp; 1) == 1) cnt++;
        z = z &gt;&gt; 1;
    }
    return cnt;
}</code></pre><p>可以使用 Integer.bitcount() 来统计 1 个的个数。</p>
<pre><code>public int hammingDistance(int x, int y) {
    return Integer.bitCount(x ^ y);
}</code></pre><p><strong>翻转一个数的比特位</strong></p>
<p><a href="https://leetcode.com/problems/reverse-bits/description/" target="_blank" rel="noopener">Leetcode : 190. Reverse Bits (Easy)</a></p>
<pre><code>public int reverseBits(int n) {
    int ret = 0;
    for(int i = 0; i &lt; 32; i++){
        ret &lt;&lt;= 1;
        ret |= (n &amp; 1);
        n &gt;&gt;&gt;= 1;
    }
    return ret;
}</code></pre><p><strong>不用额外变量交换两个整数</strong></p>
<p><a href="https://github.com/h2pl/leetcode/blob/master/README.md#" target="_blank" rel="noopener">程序员代码面试指南 ：P317</a></p>
<pre><code>a = a ^ b;
b = a ^ b;
a = a ^ b;</code></pre><p>将 c = a ^ b，那么 b ^ c = b ^ b ^ a = a，a ^ c = a ^ a ^ b = b。</p>
<p><strong>判断一个数是不是 4 的 n 次方</strong></p>
<p><a href="https://leetcode.com/problems/power-of-four/" target="_blank" rel="noopener">Leetcode : 342. Power of Four (Easy)</a></p>
<p>该数二进制表示有且只有一个奇数位为 1 ，其余的都为 0 ，例如 16 ： 10000。可以每次把 1 向左移动 2 位，就能构造出这种数字，然后比较构造出来的数与要判断的数是否相同。</p>
<pre><code>public boolean isPowerOfFour(int num) {
    int i = 1;
    while(i &gt; 0){
        if(i == num) return true;
        i = i &lt;&lt; 2;
    }
    return false;
}</code></pre><p>也可以用 Java 的 Integer.toString() 方法将该数转换为 4 进制形式的字符串，然后判断字符串是否以 1 开头。</p>
<pre><code>public boolean isPowerOfFour(int num) {
    return Integer.toString(num, 4).matches(&quot;10*&quot;);
}</code></pre><p><strong>判断一个数是不是 2 的 n 次方</strong></p>
<p><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener">Leetcode : 231. Power of Two (Easy)</a></p>
<p>同样可以用 Power of Four 的方法，但是 2 的 n 次方更特殊，它的二进制表示只有一个 1 存在。</p>
<pre><code>public boolean isPowerOfTwo(int n) {
    return n &gt; 0 &amp;&amp; Integer.bitCount(n) == 1;
}</code></pre><p>利用 1000 &amp; 0111 == 0 这种性质，得到以下解法：</p>
<pre><code>public boolean isPowerOfTwo(int n) {
    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
}</code></pre><p><strong>数组中唯一一个不重复的元素</strong></p>
<p><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">Leetcode : 136. Single Number (Easy)</a></p>
<p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p>
<p>类似的有：<a href="https://leetcode.com/problems/find-the-difference/description/" target="_blank" rel="noopener">Leetcode : 389. Find the Difference (Easy)</a>，两个字符串仅有一个字符不相同，使用异或操作可以以 O(1) 的空间复杂度来求解，而不需要使用 HashSet。</p>
<pre><code>public int singleNumber(int[] nums) {
    int ret = 0;
    for(int n : nums) ret = ret ^ n;
    return ret;
}</code></pre><p><strong>数组中不重复的两个元素</strong></p>
<p><a href="https://leetcode.com/problems/single-number-iii/description/" target="_blank" rel="noopener">Leetcode : 260. Single Number III (Medium)</a></p>
<p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<pre><code>public int[] singleNumber(int[] nums) {
    int diff = 0;
    for(int num : nums) diff ^= num;
    // 得到最右一位
    diff &amp;= -diff;
    int[] ret = new int[2];
    for(int num : nums) {
        if((num &amp; diff) == 0) ret[0] ^= num;
        else ret[1] ^= num;
    }
    return ret;
}</code></pre><p><strong>判断一个数的位级表示是否不会出现连续的 0 和 1</strong></p>
<p><a href="https://leetcode.com/problems/binary-number-with-alternating-bits/description/" target="_blank" rel="noopener">Leetcode : 693. Binary Number with Alternating Bits (Easy)</a></p>
<p>对于 10101 这种位级表示的数，把它向右移动 1 位得到 1010 ，这两个数每个位都不同，因此异或得到的结果为 11111。</p>
<pre><code>public boolean hasAlternatingBits(int n) {
    int a = (n ^ (n &gt;&gt; 1));
    return (a &amp; (a + 1)) == 0;
}</code></pre><p><strong>求一个数的补码</strong></p>
<p><a href="https://leetcode.com/problems/number-complement/description/" target="_blank" rel="noopener">Leetcode : 476. Number Complement (Easy)</a></p>
<p>不考虑二进制表示中的首 0 部分</p>
<p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p>
<pre><code>public int findComplement(int num) {
    if(num == 0) return 1;
    int mask = 1 &lt;&lt; 30;
    while((num &amp; mask) == 0) mask &gt;&gt;= 1;
    mask = (mask &lt;&lt; 1) - 1;
    return num ^ mask;
}</code></pre><p>可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p>
<pre><code>public int findComplement(int num) {
    if(num == 0) return 1;
    int mask = Integer.highestOneBit(num);
    mask = (mask &lt;&lt; 1) - 1;
    return num ^ mask;
}</code></pre><p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p>
<pre><code>mask |= mask &gt;&gt; 1    11000000
mask |= mask &gt;&gt; 2    11110000
mask |= mask &gt;&gt; 4    11111111</code></pre><pre><code>public int findComplement(int num) {
    int mask = num;
    mask |= mask &gt;&gt; 1;
    mask |= mask &gt;&gt; 2;
    mask |= mask &gt;&gt; 4;
    mask |= mask &gt;&gt; 8;
    mask |= mask &gt;&gt; 16;
    return (mask ^ num);
}</code></pre><p><strong>实现整数的加法</strong></p>
<p><a href="https://leetcode.com/problems/sum-of-two-integers/description/" target="_blank" rel="noopener">Leetcode : 371. Sum of Two Integers (Easy)</a></p>
<p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<pre><code>public int getSum(int a, int b) {
    return b == 0 ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; 1);
}</code></pre><p><strong>字符串数组最大乘积</strong></p>
<p><a href="https://leetcode.com/problems/maximum-product-of-word-lengths/description/" target="_blank" rel="noopener">Leetcode : 318. Maximum Product of Word Lengths (Medium)</a></p>
<p>题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。</p>
<p>解题思路：本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。</p>
<pre><code>public int maxProduct(String[] words) {
    int n = words.length;
    if (n == 0) return 0;
    int[] val = new int[n];
    for (int i = 0; i &lt; n; i++) {
        for (char c : words[i].toCharArray()) {
            val[i] |= 1 &lt;&lt; (c - &#39;a&#39;);
        }
    }
    int ret = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if ((val[i] &amp; val[j]) == 0) {
                ret = Math.max(ret, words[i].length() * words[j].length());
            }
        }
    }
    return ret;
}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://leetcode.com/problemset/algorithms/?status=Todo" target="_blank" rel="noopener">Leetcode</a></li>
<li>Weiss M A, 冯舜玺. 数据结构与算法分析——C 语言描述[J]. 2004.</li>
<li>Sedgewick R. Algorithms[M]. Pearson Education India, 1988.</li>
<li>何海涛, 软件工程师. 剑指 Offer: 名企面试官精讲典型编程题[M]. 电子工业出版社, 2014.</li>
<li>《编程之美》小组. 编程之美[M]. 电子工业出版社, 2008.</li>
<li>左程云. 程序员代码面试指南[M]. 电子工业出版社, 2015.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/07/2019-10-07-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/2019-10-07-ES6/" itemprop="url">ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-07T10:00:00+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>个人es6总结，大多是看阮老师的博客，总结了自己认为重要的部分</p>
</blockquote>
<h2 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h2><p>let和const注意：只有在<code>{}</code>中才有作用域（if单语句不加{}  不能用let）</p>
<pre><code class="javascript">if(1) let i = 1
Uncaught SyntaxError: Unexpected identifier</code></pre>
<p>const表示常量必须在<strong>定义的时候赋值</strong>，且<strong>不能修改</strong>，否则报错</p>
<h3 id="重复定义会报错"><a href="#重复定义会报错" class="headerlink" title="重复定义会报错"></a>重复定义会报错</h3><pre><code class="javascript">// 报错
function () {
  let a = 10;
  var a = 1;
}

function () {
  var a = 10;
  let a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}

function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}</code></pre>
<h3 id="for的特殊性"><a href="#for的特殊性" class="headerlink" title="for的特殊性"></a>for的特殊性</h3><pre><code class="javascript">for (var i = 0; i &lt; 3; i++) {
  setTimeout(function(){console.log(i)},0)
}
//3 3 3 

for (let i = 0; i &lt; 3; i++) {
  setTimeout(function(){console.log(i)},0)
}
//0 1 2 </code></pre>
<p><code>for</code>循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = &#39;abc&#39;;
  console.log(i);
}</code></pre><h3 id="无变量提升"><a href="#无变量提升" class="headerlink" title="无变量提升"></a>无变量提升</h3><p><code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code class="javascript">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;</code></pre>
<h3 id="暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="暂时性死区（temporal dead zone，简称 TDZ）"></a>暂时性死区（temporal dead zone，简称 TDZ）</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre><code class="javascript">var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}

if (true) {
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}</code></pre>
<h3 id="typeof不再绝对安全"><a href="#typeof不再绝对安全" class="headerlink" title="typeof不再绝对安全"></a>typeof不再绝对安全</h3><p>在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。如果一个变量用let申明，但是在typeof之后，typeof<code>运行时就会抛出一个</code>ReferenceError`。</p>
<h3 id="立即执行函数不必要"><a href="#立即执行函数不必要" class="headerlink" title="立即执行函数不必要"></a>立即执行函数不必要</h3><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<pre><code class="javascript">// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}</code></pre>
<h3 id="不属于顶层对象"><a href="#不属于顶层对象" class="headerlink" title="不属于顶层对象"></a>不属于顶层对象</h3><p><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code class="javascript">var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined</code></pre>
<h3 id="const本质"><a href="#const本质" class="headerlink" title="const本质"></a>const本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，<strong>而是变量指向的那个内存地址不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，<strong>至于它指向的数据结构是不是可变的，就完全不能控制了</strong>。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="javascript">const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: &quot;foo&quot; is read-only</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错</code></pre>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="javascript">const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;</code></pre>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="javascript">var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};</code></pre>
<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h2><h2 id="数组型"><a href="#数组型" class="headerlink" title="[]数组型"></a>[]数组型</h2><p>只要<strong>形式一样就能结构成功</strong>，右边多没事，右边少就会有<code>undefined</code></p>
<pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []</code></pre>
<p><code>...</code>表示rest元素数组。</p>
<h3 id="右边可以是字符串"><a href="#右边可以是字符串" class="headerlink" title="右边可以是字符串"></a>右边可以是字符串</h3><p>因为字符串是一个类数组，有length</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;</code></pre>
<h3 id="右边不可遍历，出错"><a href="#右边不可遍历，出错" class="headerlink" title="右边不可遍历，出错"></a>右边不可遍历，出错</h3><p>如果等号的右边不是数组（或者严格地说，<strong>不是可遍历的结构</strong>，参见《Iterator》一章），那么将会报错。</p>
<pre><code class="javascript">// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};</code></pre>
<p>事实上，只要某种数<strong>据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong>Generator是原生具有iterator接口的</p>
<pre><code class="javascript">function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5</code></pre>
<h3 id="解构允许默认值"><a href="#解构允许默认值" class="headerlink" title="解构允许默认值"></a>解构允许默认值</h3><p>ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员<strong>不严格</strong>等于<code>undefined</code>，默认值是不会生效的。(<strong>比如null</strong>)</p>
<pre><code class="javascript">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;

let [x = 1] = [null];
x // null</code></pre>
<h2 id="对象型"><a href="#对象型" class="headerlink" title="{}对象型"></a>{}对象型</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="javascript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined</code></pre>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code class="javascript">var { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;</code></pre>
<p>这实际上说明，对象的解构赋值是下面形式的简写（<strong>前面是模式，后面是真实变量</strong>）</p>
<pre><code class="javascript">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };</code></pre>
<h3 id="不在声明使用需要加括号"><a href="#不在声明使用需要加括号" class="headerlink" title="不在声明使用需要加括号"></a>不在声明使用需要加括号</h3><p>由于<code>{}</code>的二义性，所以在<code>{}</code>开头的特殊语句，需要加上<code>()</code></p>
<pre><code class="javascript">let foo;
({foo} = {foo: 1}); // 成功


let baz;
{bar: baz} = {bar: 1}; //报错</code></pre>
<h3 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h3><p>和数组一样，解构也可以用于嵌套结构的对象。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;</code></pre><p>注意，这时<code>p</code>是<strong>模式</strong>，不是变量，因此不会被赋值。</p>
<h3 id="允许默认值"><a href="#允许默认值" class="headerlink" title="允许默认值"></a>允许默认值</h3><pre><code class="javascript">var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5</code></pre>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<pre><code class="javascript">let {length : len} = &#39;hello&#39;;
len // 5

let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3</code></pre>
<h3 id="数字字符串"><a href="#数字字符串" class="headerlink" title="数字字符串"></a>数字字符串</h3><p>解构赋值时，如果等号右边是数值和布尔值，<strong>则会先转为对象。</strong></p>
<pre><code class="javascript">let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true</code></pre>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code class="javascript">let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError</code></pre>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><p>写法不仅简洁，而且易读，语义非常清晰。</p>
<pre><code class="javascript">let x = 1;
let y = 2;
[x, y] = [y, x];</code></pre>
<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><pre><code class="javascript">// 返回一个数组
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象
function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();</code></pre>
<h3 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h3><p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code class="javascript">// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});</code></pre>
<h3 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h3><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<pre><code class="javascript">let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]</code></pre>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><pre><code class="javascript">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h3 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h3><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="javascript">var map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="javascript">// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...</code></pre>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="unicode字符问题"><a href="#unicode字符问题" class="headerlink" title="unicode字符问题"></a>unicode字符问题</h2><h3 id="增加了四字节unicode表示"><a href="#增加了四字节unicode表示" class="headerlink" title="增加了四字节unicode表示"></a>增加了四字节unicode表示</h3><p>es5有<code>\uxxxx</code>表示unicode，但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。es6加入了<strong>大括号表示</strong></p>
<pre><code class="javascript">&#39;\u{1F680}&#39; === &#39;\uD83D\uDE80&#39;</code></pre>
<h3 id="码点表示"><a href="#码点表示" class="headerlink" title="码点表示"></a>码点表示</h3><p>charPointAt();</p>
<p>String.fromCodePoint();</p>
<p>这些都是基于码点的，可以完整返回四字节Unicode。</p>
<h3 id="for-of遍历"><a href="#for-of遍历" class="headerlink" title="for of遍历"></a>for of遍历</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p>
<pre><code class="javascript">for (let codePoint of &#39;foo&#39;) {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;</code></pre>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<pre><code>var s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true

</code></pre><p>这三个方法都<strong>支持第二个参数，表示开始搜索的位置。</strong></p>
<pre><code>var s = &#39;Hello world!&#39;;

s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false

</code></pre><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<pre><code>&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre><p>参数如果是小数，会被取整。</p>
<pre><code>&#39;na&#39;.repeat(2.9) // &quot;nana&quot;

</code></pre><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<pre><code>&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError

</code></pre><p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。</p>
<pre><code>&#39;na&#39;.repeat(-0.9) // &quot;&quot;

</code></pre><p>参数<code>NaN</code>等同于0。</p>
<pre><code>&#39;na&#39;.repeat(NaN) // &quot;&quot;

</code></pre><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<pre><code>&#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot;
&#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot;
</code></pre><h3 id="padStart和padEnd（ES2017）"><a href="#padStart和padEnd（ES2017）" class="headerlink" title="padStart和padEnd（ES2017）"></a>padStart和padEnd（ES2017）</h3><p>ES2017 引入了字符串补全长度的功能（chrome可以使用了，node v6.3.1没实现该api）</p>
<p>如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre><p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>如果补串超长，自动截去超过部分  </li>
<li>如果原字符串长度&gt;=最小长度，则返回原字符串</li>
<li>如果忽略第二参数，默认用空格补</li>
</ol>
<pre><code class="javascript">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)  // &#39;0123456abc&#39;
&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;
&#39;x&#39;.padStart(4) // &#39;   x&#39;</code></pre>
<p><code>padStart</code>的常见用途是为数值补全指定位数。另一个用途是提示字符串格式。</p>
<pre><code class="javascript">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;</code></pre>
<h2 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h2><p>我觉得es6在字符串里引入的最大的变化就是模板字符串，通过`` 表示，模板字符串有几大特性：</p>
<h3 id="可以换行"><a href="#可以换行" class="headerlink" title="可以换行"></a>可以换行</h3><pre><code class="javascript">$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());</code></pre>
<h3 id="可以嵌入js变量"><a href="#可以嵌入js变量" class="headerlink" title="可以嵌入js变量"></a>可以嵌入js变量</h3><p>通过<code>${}</code>可以嵌入js对象，允许使用运算符，可以使用函数（返回值）</p>
<pre><code class="javascript">  //传统写法
&#39;User &#39;
      + user.name
      + &#39; is not authorized to do &#39;
      + action
      + &#39;.&#39;

//ES6写法
`User ${user.name} is not authorized to do ${action}.`);


function fn() {
  return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar

function fn2() {}
`test ${fn2()}`
// test undefined
`${fn2}`
// function fn2() {}


var x = 1;
var y = 2;

`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;

`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;</code></pre>
<p>如果变量没申明，则会报错</p>
<pre><code class="javascript">// 变量place没有声明
var msg = `Hello, ${place}`;
// 报错</code></pre>
<h3 id="需要转义"><a href="#需要转义" class="headerlink" title="需要转义"></a>需要转义</h3><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code class="javascript">var greeting = `\`Yo\` World!`;</code></pre>
<h3 id="【高级】模板嵌套"><a href="#【高级】模板嵌套" class="headerlink" title="【高级】模板嵌套"></a>【高级】模板嵌套</h3><p>模板字符串甚至还能嵌套。</p>
<pre><code class="javascript">const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join(&#39;&#39;)}
  &lt;/table&gt;
`;

const data = [
    { first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; },
    { first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; },
];

console.log(tmpl(data));
// &lt;table&gt;
//
//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
//
//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
//
// &lt;/table&gt;</code></pre>
<h3 id="【高级】标签模板"><a href="#【高级】标签模板" class="headerlink" title="【高级】标签模板"></a>【高级】标签模板</h3><p>实际就是将模板跟在函数名后，将会调用函数来执行这个模板</p>
<pre><code class="javascript">var a = 5;
var b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);</code></pre>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中<strong>那些没有变量替换的部分</strong>，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>
<p><code>tag</code>函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p><a href="http://es6.ruanyifeng.com/#docs/string#标签模板" target="_blank" rel="noopener">具体看这里</a></p>
<p>利用标签模板，<strong>理论上可以在javascript里面加载别的语言代码：</strong></p>
<pre><code class="javascript">function java(...){

}

java`
class HelloWorldApp {
  public static void main(String[] args) {
    System.out.println(“Hello World!”); // Display the string.
  }
}
`
HelloWorldApp.main();</code></pre>
<h3 id="String-raw调用标签模板"><a href="#String-raw调用标签模板" class="headerlink" title="String.raw调用标签模板"></a>String.raw调用标签模板</h3><p>单独使用标签模板无法自动把里面的参数转换成字符串，所以ES6原生提供了一个<code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回<strong>一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串</strong>，对应于替换变量后的模板字符串。</p>
<pre><code class="javascript">String.raw`Hi\n${2+3}!`;
// &quot;Hi\\n5!&quot;

String.raw`Hi\u000A!`;
// &#39;Hi\\u000A!&#39;</code></pre>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。</p>
<pre><code class="javascript">String.raw`Hi\\n`
// Hi\\n
//也就是&quot;Hi\n&quot;     //这里\n已经是转义过的，否则会换行，比如看下面的例子

`Hi\n${2+3}!`;
&quot;Hi
5!&quot;</code></pre>
<p>由于它会自动转换斜杠，所以利于用来方便下一步做字符串。</p>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>加入了大量特性都是跟unicode有关的，增加了一个<code>flags</code>属性返回正则的修饰符比如<code>gi</code>，加入了新的粘连（sticky）修饰符<code>y</code>,<code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code class="javascript">var s = &#39;aaa_aa_a&#39;;
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null

var s = &#39;aaa_aa_a&#39;;
var r = /a+_/y;

r.exec(s) // [&quot;aaa_&quot;]
r.exec(s) // [&quot;aa_&quot;]</code></pre>
<p>进一步说，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<pre><code>/b/y.exec(&#39;aba&#39;)
// null

</code></pre><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<pre><code>var r = /hello\d/y;
r.sticky // true
</code></pre><h3 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h3><p>在ES5中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<pre><code class="javascript">var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;);
// 等价于
var regex = /xyz/i;</code></pre>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<pre><code class="javascript">var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;</code></pre>
<p>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。</p>
<pre><code class="javascript">var regex = new RegExp(/xyz/, &#39;i&#39;);
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</code></pre>
<p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<pre><code class="javascript">new RegExp(/abc/ig, &#39;i&#39;).flags
// &quot;i&quot;</code></pre>
<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="八进制和二进制"><a href="#八进制和二进制" class="headerlink" title="八进制和二进制"></a>八进制和二进制</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>
<pre><code class="javascript">0b111110111 === 503 // true
0o767 === 503 // true</code></pre>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<pre><code class="javascript">Number(&#39;0b111&#39;)  // 7
Number(&#39;0o10&#39;)  // 8</code></pre>
<h3 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h3><p>ES6在Number对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法<strong>只对数值有效</strong>，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code></p>
<pre><code class="javascript">isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false</code></pre>
<p>可以这样部署isFinite()，isNaN类似</p>
<pre><code class="javascript">(function (global) {
  var global_isFinite = global.isFinite;

  Object.defineProperty(Number, &#39;isFinite&#39;, {
    value: function isFinite(value) {
      return typeof value === &#39;number&#39; &amp;&amp; global_isFinite(value);
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
})(this);</code></pre>
<h3 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h3><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。这样做的目的，<strong>是逐步减少全局性方法，使得语言逐步模块化。</strong></p>
<pre><code class="javascript">// ES5的写法
parseInt(&#39;12.34&#39;) // 12
parseFloat(&#39;123.45#&#39;) // 123.45

// ES6的写法
Number.parseInt(&#39;12.34&#39;) // 12
Number.parseFloat(&#39;123.45#&#39;) // 123.45

Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true</code></pre>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以<strong>3和3.0被视为同一个值。</strong></p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.0) // true
Number.isInteger(25.1) // false
Number.isInteger(&quot;15&quot;) // false
Number.isInteger(true) // false
</code></pre><p>ES5可以通过下面的代码，部署<code>Number.isInteger()</code>。</p>
<pre><code class="javascript">(function (global) {
   ……
  Object.defineProperty(Number, &#39;isInteger&#39;, {
    value: function isInteger(value) {
      return typeof value === &#39;number&#39; &amp;&amp; isFinite(value) &amp;&amp;
        value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp;
        floor(value) === value;
    },
    ……
  });
})(this);</code></pre>
<h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>
<pre><code class="javascript">Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &#39;0.00000000000000022204&#39;</code></pre>
<p>引入一个这么小的量的目的，<strong>在于为浮点数计算，设置一个误差范围</strong>。我们知道浮点数计算是不精确的。但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>
<h3 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h3><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。上面代码中，超出2的53次方之后，一个数就不精确了。ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<pre><code class="javascript">Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true</code></pre>
<p>上面代码中，可以看到JavaScript能够精确表示的极限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<h2 id="Math扩展"><a href="#Math扩展" class="headerlink" title="Math扩展"></a>Math扩展</h2><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分（原理就是根据正负调用floor和ceil），对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。</p>
<pre><code class="javascript">Math.trunc(4.1) // 4
Math.trunc(-4.1) // -4
Math.trunc(-0.1234) // -0
Math.trunc(&#39;123.456&#39;)// 123
Math.trunc(NaN);      // NaN
Math.trunc(&#39;foo&#39;);    // NaN
Math.trunc();         // NaN</code></pre>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p><code>Math.sign</code>方法用来判断一个数到底是<strong>正数、负数、还是零</strong>。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<h3 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h3><p><code>Math.cbrt</code>方法用于计算一个数的<strong>立方根</strong> Math.pow(Math.abs(x), 1/3)</p>
<h3 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式<strong>有多少个前导0</strong>。<code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representations of a number“（计算32位整数的前导0）的缩写。左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>
<pre><code class="javascript">Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 &lt;&lt; 1) // 30
Math.clz32(1 &lt;&lt; 2) // 29
Math.clz32(1 &lt;&lt; 29) // 2</code></pre>
<h3 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h3><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<pre><code class="javascript">Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755
Math.hypot();            // 0
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, &#39;foo&#39;); // NaN
Math.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755
Math.hypot(-3);          // 3</code></pre>
<h3 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h3><p><strong>（1） Math.expm1()</strong>   == Math.exp(x) - 1;</p>
<p><code>Math.expm1(x)</code>返回ex - 1，即<code>Math.exp(x) - 1</code>。</p>
<p><strong>（2）Math.log1p()</strong>  ==  Math.log(1 + x);</p>
<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>
<p><strong>（3）Math.log10()</strong> == Math.log(x) / Math.LN10;</p>
<p><code>Math.log10(x)</code>返回以10为底的<code>x</code>的对数。如果<code>x</code>小于0，则返回NaN。</p>
<p><strong>（4）Math.log2()</strong> == Math.log(x) / Math.LN2;</p>
<p><code>Math.log2(x)</code>返回以2为底的<code>x</code>的对数。如果<code>x</code>小于0，则返回NaN。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>ES6新增了6个三角函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="！指数运算符"><a href="#！指数运算符" class="headerlink" title="！指数运算符"></a>！指数运算符</h3><p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>
<pre><code class="javascript">2 ** 3 // 8

let a = 1.5;
a **= 2;
// 等同于 a = a * a;</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="! Array.from()"></a>! Array.from()</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>
<pre><code class="javascript">let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。再使用<code>forEach</code>方法。</p>
<pre><code class="javascript">// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).forEach(function (p) {
  console.log(p);
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}</code></pre>
<p>只要是部署了Iterator接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>
<pre><code class="javascript">Array.from(&#39;hello&#39;)
// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]

let namesSet = new Set([&#39;a&#39;, &#39;b&#39;])
Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]</code></pre>
<p>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被<code>Array.from</code>转为真正的数组。</p>
<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。</p>
<pre><code class="javascript">// arguments对象
function foo() {
  var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]</code></pre>
<p><code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<pre><code class="javascript">Array.from({ length: 3 });
// [ undefined, undefined, undefined ]</code></pre>
<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。<code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);
// 等同于
Array.prototype.map.call(arrayLike),x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]

let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)</code></pre>
<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<pre><code class="javascript">Array.from({ length: 2 }, () =&gt; &#39;jack&#39;)
// [&#39;jack&#39;, &#39;jack&#39;]</code></pre>
<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于<code>\uFFFF</code>的Unicode字符，算作两个字符的bug。</p>
<pre><code class="javascript">function countSymbols(string) {
  return Array.from(string).length;
}</code></pre>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1</code></pre>
<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]</code></pre>
<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<pre><code class="javascript">Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]</code></pre>
<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>
<pre><code class="javascript">function ArrayOf(){
  return [].slice.call(arguments);
}</code></pre>
<h3 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h3><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，<strong>使用这个方法，会修改当前数组。</strong></p>
<pre><code class="javascript">Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。<strong>如果为负值，表示倒数。</strong></li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。<strong>如果为负值，表示倒数。</strong></li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]</code></pre>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p>下面是更多例子。</p>
<pre><code class="javascript">// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);</code></pre>
<h3 id="Array-fill"><a href="#Array-fill" class="headerlink" title="Array.fill"></a>Array.fill</h3><p>方法使用给定值，填充一个数组(<strong>初始化数组</strong>)</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]</code></pre>
<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。<code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]</code></pre>
<p>上面代码表示，<code>fill</code>方法从1号位开始，向原数组填充7，到2号位之前结束。</p>
<h3 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h3><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个<strong>遍历器对象</strong>，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<p>注：values在chrome中暂时不可用</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);
}
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;</code></pre>
<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<pre><code class="javascript">let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let entries = letter.entries();
console.log(entries.next().value); // [0, &#39;a&#39;]
console.log(entries.next().value); // [1, &#39;b&#39;]
console.log(entries.next().value); // [2, &#39;c&#39;]</code></pre>
<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于<strong>ES7</strong>，但Babel转码器已经支持。用来替换indexof，它有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对<code>NaN</code>的误判。</p>
<pre><code class="javascript">[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, NaN].includes(NaN); // true

[NaN].indexOf(NaN)// -1</code></pre>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true</code></pre>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<pre><code class="javascript">const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)   //这样还是没办法避免NaN问题，如果需要判断这个还需加强
)();
contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</code></pre>
<p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h3 id="空位置（坑）"><a href="#空位置（坑）" class="headerlink" title="空位置（坑）"></a>空位置（坑）</h3><p>数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<pre><code>Array(3) // [, , ,]

</code></pre><p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<pre><code class="javascript">0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false</code></pre>
<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<pre><code class="javascript">// forEach方法
[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]

// every方法
[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true

// some方法
[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false

// map方法
[,&#39;a&#39;].map(x =&gt; 1) // [,1]

// join方法
[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;

// toString方法
[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;</code></pre>
<p>ES6则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<pre><code class="javascript">Array.from([&#39;a&#39;,,&#39;b&#39;])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre>
<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<pre><code class="javascript">[...[&#39;a&#39;,,&#39;b&#39;]]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre>
<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<pre><code class="javascript">[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]</code></pre>
<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<pre><code class="javascript">new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</code></pre>
<p><code>for...of</code>循环也会遍历空位。</p>
<pre><code class="javascript">let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1</code></pre>
<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<pre><code class="javascript">// entries()
[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,&#39;a&#39;].keys()] // [0,1]

// values()
[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]

// find()
[,&#39;a&#39;].find(x =&gt; true) // undefined

// findIndex()
[,&#39;a&#39;].findIndex(x =&gt; true) // 0</code></pre>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。这种写法的缺点在于，<strong>如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。</strong>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<pre><code class="javascript">function log(x, y) {
  y = y || &#39;World&#39;;
  console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello World           //这里不符合预计

//改成
function log(x, y) {
  if (typeof y === &#39;undefined&#39;) {
     y = &#39;World&#39;;
  }
  console.log(x, y);
}</code></pre>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello</code></pre>
<p>ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>另外，一个容易忽略的地方是，<strong>如果参数默认值是变量，那么参数就不是传值的</strong>，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code class="javascript">let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101</code></pre>
<p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p>
<h3 id="与解构结合用"><a href="#与解构结合用" class="headerlink" title="与解构结合用"></a>与解构结合用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="javascript">function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined, 5
foo(1,2) // undefined, 5    //只要第一个参数不是一个对象就不会赋值
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined</code></pre>
<p>上面的写法不能省略参数，如果结合函数参数的默认值，就可以省略第二个参数。<strong>这时，就出现了双重默认值。</strong></p>
<pre><code class="javascript">function foo({x, y = 5} = {}) {
  console.log(x, y);
}
foo() // undefined, 5</code></pre>
<p><strong>注意：</strong></p>
<p>再请问下面两种写法有什么差别？</p>
<pre><code class="javascript">// 写法一  使用这种
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二  缺点是如果传入了参数，哪怕是空{},初始化就失效
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code class="javascript">// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x有值，y无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]</code></pre>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，<strong>应该是函数的尾参数</strong>。因为这样比较容易看出来，到底省略了哪些参数。<strong>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</strong>除非显式输入<code>undefined</code>。如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<pre><code class="javascript">// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]</code></pre>
<p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。这是因为<code>length</code>属性的含义是，<strong>该函数预期传入的参数个数</strong>。</p>
<pre><code class="javascript">(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<pre><code class="javascript">(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1</code></pre>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，<strong>参数会形成一个单独的作用域（context）</strong>。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="javascript">var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2</code></pre>
<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">let x = 1;
function f(y = x) {   //如果不定义x会报错
  let x = 2;
  console.log(y);
}
f() // 1</code></pre>
<p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p>
<p>面是一个更复杂的例子。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;   //和第一个参数x不一样
  y();   //改变的是第一个参数x
  console.log(x); 
}

foo() // 3
x // 1</code></pre>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;    //和第一个参数x一致
  y();      //改变了第一个参数x
  console.log(x);  //2
}

foo() // 2
x // 1</code></pre>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，<strong>可以指定某一个参数不得省略，如果省略就抛出一个错误。</strong></p>
<pre><code class="javascript">function throwIfMissing() {
  throw new Error(&#39;Missing parameter&#39;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter</code></pre>
<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<pre><code class="javascript">function foo(optional = undefined) { ··· }</code></pre>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入<strong>数组</strong>中。</p>
<pre><code>function add(...values) {
    values //[2,5,3]
}

add(2, 5, 3) // 10
</code></pre><p><strong>由于rest参数本来就是数组，所以它不需要做数组转换就可以用数组的方法</strong>(sort，forEach……)</p>
<pre><code class="javascript">// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code class="javascript">// 报错
function f(a, ...b, c) {
  // ...
}</code></pre>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<pre><code class="javascript">(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1</code></pre>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 <strong>rest 参数的逆运算</strong>，将<strong>一个数组转为用逗号分隔的参数序列</strong>。</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</code></pre>
<p>该运算符主要用于函数调用。</p>
<pre><code class="javascript">function push(array, ...items) {
  array.push(...items);   //把items转换成序列
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers) // 42</code></pre>
<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code class="javascript">function f(v, w, x, y, z) { }
var args = [0, 1];
f(-1, ...args, 2, ...[3]);</code></pre>
<h3 id="！扩展运算符作用"><a href="#！扩展运算符作用" class="headerlink" title="！扩展运算符作用"></a>！扩展运算符作用</h3><ol>
<li><p><strong>替代apply</strong></p>
<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>
</li>
</ol>
<pre><code class="javascript">// 1. 求数组最大值

// ES5的写法
Math.max.apply(null, [14, 3, 77])

// ES6的写法
Math.max(...[14, 3, 77])

// 2. 给Date传参

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);


// 3. 添加数组到尾部

// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);
// ES6的写法
arr1.push(...arr2);

// 4. 合并数组

// ES5
arr1.concat(arr2, arr3);

// ES6
[...arr1, ...arr2, ...arr3]</code></pre>
<ol>
<li>扩展运算符可以与<strong>解构赋值</strong>结合起来，<strong>用于生成数组。</strong>如果将扩展运算符用于数组赋值，<strong>只能放在参数的最后一位</strong>，否则会报错。</li>
</ol>
<pre><code class="javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list

const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错</code></pre>
<ol>
<li><strong>字符串</strong></li>
</ol>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</code></pre>
<p>上面的写法，有一个重要的好处，<strong>那就是能够正确识别32位的Unicode字符。</strong></p>
<pre><code class="javascript">&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3</code></pre>
<p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code class="javascript">function length(str) {
  return [...str].length;
}

length(&#39;x\uD83D\uDE80y&#39;) // 3</code></pre>
<p>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre><code class="javascript">let str = &#39;x\uD83D\uDE80y&#39;;

str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;</code></pre>
<p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确</p>
<ol>
<li><p><strong>转换所有带Iterator接口的对象</strong></p>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
</li>
</ol>
<pre><code class="javascript">let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]</code></pre>
<p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code class="javascript">var go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]</code></pre>
<p>上面代码中，变量<code>go</code>是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有<code>iterator</code>接口的对象，使用扩展运算符，将会报错。</p>
<pre><code class="javascript">var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object</code></pre>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<pre><code class="javascript">function foo() {}
foo.name // &quot;foo&quot;</code></pre>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<pre><code class="javascript">var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;</code></pre>
<p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</p>
<pre><code class="javascript">const bar = function baz() {};

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;</code></pre>
<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<pre><code class="javascript">(new Function).name // &quot;anonymous&quot;</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<pre><code class="javascript">function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>如果没有参数，必须要用一个括号，只有一个参数，不用写括号，返回值不用写return</p>
<pre><code class="javascript">var f = v =&gt; v;
//等于
var f = function(v) {
  return v;
};
var f = () =&gt; 5;
var sum = (num1, num2) =&gt; num1 + num2;</code></pre>
<h3 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h3><p>如果只是返回对象，必须要加一个括号，否则编译器认不出</p>
<pre><code class="javascript">var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });</code></pre>
<h3 id="与解构"><a href="#与解构" class="headerlink" title="与解构"></a>与解构</h3><pre><code class="javascript">const full = ({ first, last }) =&gt; first + &#39; &#39; + last;

// 等同于
function full(person) {
  return person.first + &#39; &#39; + person.last;
}</code></pre>
<h3 id="简化回调"><a href="#简化回调" class="headerlink" title="简化回调"></a>简化回调</h3><pre><code class="javascript">// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);

// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);</code></pre>
<h3 id="与rest结合"><a href="#与rest结合" class="headerlink" title="与rest结合"></a>与rest结合</h3><pre><code class="javascript">const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]</code></pre>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）<strong>不可以当作构造函数</strong>，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，<strong>可以用Rest参数代替</strong>。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数<strong>不能用作Generator函数</strong>。</p>
<p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<pre><code class="javascript">var handler = {
  id: &#39;123456&#39;,

  init: function() {
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);   //如果不用箭头函数那this指向document
  },

  doSomething: function(type) {
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  }
};</code></pre>
<p>所以，箭头函数转成ES5的代码如下。</p>
<pre><code class="javascript">// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;    //这里引用了外面的this

  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}</code></pre>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<pre><code class="javascript">(function() {
  return [
    (() =&gt; this.x).bind({ x: &#39;inner&#39; })()
  ];
}).call({ x: &#39;outer&#39; });
// [&#39;outer&#39;]</code></pre>
<h3 id="arguments-super-target"><a href="#arguments-super-target" class="headerlink" title="arguments,super,target"></a>arguments,super,target</h3><p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>
<pre><code class="javascript">function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;args:&#39;, arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]</code></pre>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><pre><code class="javascript">function f(x){
  return g(x);
}</code></pre>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<pre><code class="javascript">function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}</code></pre>
<p>以下不是尾调用</p>
<pre><code class="javascript">// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;  // ==  var tmp = g(x); return tmp+1;
}

// 情况三
function f(x){
  g(x);    //  g(x);   return undefined;
}</code></pre>
<p><strong>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧</strong>，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<pre><code class="javascript">function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);</code></pre>
<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p>
<pre><code class="javascript">function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}</code></pre>
<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但<strong>对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</strong></p>
<pre><code class="javascript">function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120</code></pre>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<pre><code class="javascript">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120</code></pre>
<p>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p>
<p>如果是非尾递归的fibonacci 递归方法</p>
<pre><code class="javascript">function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10); // 89
// Fibonacci(100)
// Fibonacci(500)
// 堆栈溢出了</code></pre>
<p>如果我们使用尾递归优化过的fibonacci 递归算法</p>
<pre><code class="javascript">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity</code></pre>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。<strong>ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。</strong>这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h3><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<pre><code class="javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)</code></pre>
<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归100000次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<pre><code class="javascript">function trampoline(f) {
  while (f &amp;&amp; f instanceof Function) {
    f = f();
  }
  return f;
}</code></pre>
<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<pre><code class="javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}</code></pre>
<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<pre><code class="javascript">trampoline(sum(1, 100000))
// 100001</code></pre>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<pre><code class="javascript">function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001</code></pre>
<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="属性简洁表达"><a href="#属性简洁表达" class="headerlink" title="属性简洁表达"></a>属性简洁表达</h2><p>ES6允许<strong>直接写入变量和函数，作为对象的属性和方法</strong>。这样的书写更加简洁。</p>
<pre><code class="javascript">var foo = &#39;bar&#39;;
var baz = {foo};
baz // {foo: &quot;bar&quot;}</code></pre>
<p>属性名直接是变量名，属性值是变量值</p>
<pre><code class="javascript">var birth = &#39;2000/01/01&#39;;

var Person = {
  name: &#39;张三&#39;,
  //等同于birth: &#39;2000/01/01&#39;;
  birth,
  // 等同于hello: function ()...
  hello() { console.log(&#39;我的名字是&#39;, this.name); }
};</code></pre>
<p>CommonJS模块输出变量，就非常合适使用简洁写法。</p>
<pre><code class="javascript">var ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};</code></pre>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre><code class="javascript">var obj = {
  class () {}   //class是字符串，所以不会因为它属于关键字，而导致语法解析报错。
};
// 等同于
var obj = {
  &#39;class&#39;: function() {}    
};</code></pre>
<p>如果某个方法的值是一个Generator函数，前面需<strong>要加上星号。</strong></p>
<pre><code class="javascript">var obj = {
  * m(){
    yield &#39;hello world&#39;;
  }
};</code></pre>
<h2 id="字面量中可用"><a href="#字面量中可用" class="headerlink" title="字面量中可用[]"></a>字面量中可用[]</h2><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，<strong>即把表达式放在方括号内</strong>。</p>
<pre><code class="javascript">let propKey = &#39;foo&#39;;

let obj = {
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
};
//Object {foo: true, abc: 123}</code></pre>
<p>表达式还可以用于定义方法名。</p>
<pre><code class="javascript">let obj = {
  [&#39;h&#39; + &#39;ello&#39;]() {
    return &#39;hi&#39;;
  }
};

obj.hello() // hi</code></pre>
<p><strong>注意</strong>，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code class="javascript">// 报错
var foo = &#39;bar&#39;;
var bar = &#39;abc&#39;;
var baz = { [foo] };

// 正确
var foo = &#39;bar&#39;;
var baz = { [foo]: &#39;abc&#39;};
var baz = {foo}</code></pre>
<p><strong>注意</strong>，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<pre><code class="javascript">const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
};

myObject // Object {[object Object]: &quot;valueB&quot;}
//[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解控制/" itemprop="url">Java题解控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章控制执行"><a href="#第三章控制执行" class="headerlink" title="第三章控制执行"></a>第三章控制执行</h2><p> public class Count {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              for(int i = 1; i &lt; 101; i++)</p>
<p>​                     System.out.println(i);</p>
<p>​       }</p>
<p>}</p>
<p>public class CompareInts {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Random rand1 = new Random();</p>
<p>​              Random rand2 = new Random();</p>
<p>​              for(int i = 0; i &lt; 25; i++) {</p>
<p>​                     int x = rand1.nextInt();</p>
<p>​                     int y = rand2.nextInt();</p>
<p>​                     if(x &lt; y) print(x + “ &lt; “ + y);</p>
<p>​                     else if(x &gt; y) print(x + “ &gt; “ + y);</p>
<p>​                     else print(x + “ = “ + y);</p>
<p>​              }</p>
<p>​              Random rand3 = new Random();</p>
<p>​              Random rand4 = new Random();</p>
<p>​              for(int i = 0; i &lt; 25; i++) {</p>
<p>​                     int x = rand3.nextInt(10);</p>
<p>​                     int y = rand4.nextInt(10);</p>
<p>​                     if(x &lt; y) print(x + “ &lt; “ + y);</p>
<p>​                     else if(x &gt; y) print(x + “ &gt; “ + y);</p>
<p>​                     else print(x + “ = “ + y);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class CompareIntsForever {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Random rand1 = new Random();</p>
<p>​              Random rand2 = new Random();</p>
<p>​              for(int i = 0; i &lt; 25; i++) {</p>
<p>​                     int x = rand1.nextInt();</p>
<p>​                     int y = rand2.nextInt();</p>
<p>​                     if(x &lt; y) print(x + “ &lt; “ + y);</p>
<p>​                     else if(x &gt; y) print(x + “ &gt; “ + y);</p>
<p>​                     else print(x + “ = “ + y);</p>
<p>​              }</p>
<p>​              Random rand3 = new Random();</p>
<p>​              Random rand4 = new Random();</p>
<p>​              while(true) {</p>
<p>​                                  int x = rand3.nextInt(10);</p>
<p>​                     int y = rand4.nextInt(10);</p>
<p>​                     if(x &lt; y) print(x + “ &lt; “ + y);</p>
<p>​                     else if(x &gt; y) print(x + “ &gt; “ + y);</p>
<p>​                     else print(x + “ = “ + y);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>  public class Primes {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              for(int i = 1; i &lt; 1000; i++ ) {</p>
<p>​                     int factors = 0;</p>
<p>​                     for(int j = 1; j &lt; (i + 2)                       if((i % j) == 0) factors++;                   </p>
<p>​                     }</p>
<p>​                     if(factors &lt; 2) System.out.println(i + “ is prime”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class BitTest {</p>
<p>​       static void binaryPrint (int q) {</p>
<p>​              if(q == 0) System.out.print(0);</p>
<p>​              else {</p>
<p>​                     int nlz = Integer.numberOfLeadingZeros(q); </p>
<p>​                     q &lt;&lt;= nlz;</p>
<p>​                     for(int p = 0; p &lt; 32 - nlz; p++) {</p>
<p>​                            int n = (Integer.numberOfLeadingZeros(q) == 0) ? 1 : 0;</p>
<p>​                            System.out.print(n);             </p>
<p>​                            q &lt;&lt;= 1;</p>
<p>​                     }             </p>
<p>​              }</p>
<p>​              System.out.println(“”);</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              int i = 1 + 4 + 16 + 64;</p>
<p>​              int j = 2 + 8 + 32 + 128;</p>
<p>​              int k = 0x100;</p>
<p>​              int m = 0;</p>
<p>​              P.rintln(“Using Integer.toBinaryString():”);</p>
<p>​              P.rintln(“i = “ + Integer.toBinaryString(i));</p>
<p>​              P.rintln(“j = “ + Integer.toBinaryString(j));</p>
<p>​              P.rintln(“k = “ + Integer.toBinaryString(k));</p>
<p>​              P.rintln(“m = “ + Integer.toBinaryString(m));            </p>
<p>​              P.rintln(“i &amp; j = “ + (i &amp; j) + “ = “ + Integer.toBinaryString(i &amp; j));</p>
<p>​              P.rintln(“i | j = “ + (i | j) + “ = “ + Integer.toBinaryString(i | j));</p>
<p>​              P.rintln(“i ^ j = “ + (i ^ j) + “ = “ + Integer.toBinaryString(i ^ j));</p>
<p>​              P.rintln(“<del>i = “ + Integer.toBinaryString(</del>i));</p>
<p>​              P.rintln(“<del>j = “ + Integer.toBinaryString(</del>j));</p>
<p>​              P.rintln(“Using binaryPrint():”);</p>
<p>​              P.rint(“i = “ + i + “ = “);</p>
<p>​              binaryPrint(i);        </p>
<p>​              P.rint(“j = “ + j + “ = “);</p>
<p>​              binaryPrint(j);</p>
<p>​              P.rint(“k = “ + k + “ = “);</p>
<p>​              binaryPrint(k);       </p>
<p>​              P.rint(“m = “ + m + “ = “);</p>
<p>​              binaryPrint(m);</p>
<p>​              P.rint(“i &amp; j = “ + (i &amp; j) + “ = “);</p>
<p>​              binaryPrint(i &amp; j);</p>
<p>​              P.rint(“i | j = “ + (i | j) + “ = “);</p>
<p>​              binaryPrint(i | j);</p>
<p>​              P.rint(“i ^ j = “ + (i ^ j) + “ = “);</p>
<p>​              binaryPrint(i ^ j);</p>
<p>​              P.rint(“~i = “ + ~i + “ = “);</p>
<p>​              binaryPrint(~i);             </p>
<p>​              P.rint(“~j = “ + ~j + “ = “);</p>
<p>​              binaryPrint(~j);</p>
<p>​       }      </p>
<p>}</p>
<p>public class IfElseTest {</p>
<p>​       static int test(int testval, int begin, int end) {</p>
<p>​              if(end &lt; begin) {</p>
<p>​                     print(“end cannot be &lt; begin”);</p>
<p>​                     return 0;</p>
<p>​              } </p>
<p>​              if((testval &gt; (begin - 1)) &amp;&amp; (testval &lt; (end + 1))) </p>
<p>​                     return +1;</p>
<p>​              if((testval &lt; begin) || (testval &gt; end))</p>
<p>​                     return -1;</p>
<p>​              print(“exceptional case”);</p>
<p>​              return 13;</p>
<p>​       }      </p>
<p>​       public static void main(String[] args) {</p>
<p>​              print(test(10, 5, 4));</p>
<p>​              print(test(5, 4, 10));</p>
<p>​              print(test(5, 5, 6));</p>
<p>​              print(test(10, 5, 7));       </p>
<p>​              print(test(5, 5, 5));  </p>
<p>​       }</p>
<p>}</p>
<p>public class IntCount {</p>
<p>​       static void Count1(int n) {</p>
<p>​              for(int i = 0; i &lt; n; i++)</p>
<p>​                     print(i + 1);</p>
<p>​              </p>
<p>​       }</p>
<p>​       static void Count2(int n) {</p>
<p>​              for(int i = 0; i &lt; n; i++) {</p>
<p>​                     print(i + 1);</p>
<p>​                     if(i == 99)</p>
<p>​                            break;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       static void Count3(int n) {</p>
<p>​              for(int i = 0; i &lt; n; i++) {</p>
<p>​                     print(i + 1);</p>
<p>​                     if(i == 99)</p>
<p>​                            return;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Count1(100);  </p>
<p>​              Count2(100);</p>
<p>​              Count3(100);</p>
<p>​       }</p>
<p>}</p>
<p>public class SwitchTest {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              for(int i = 0; i &lt; 11; i++) {     </p>
<p>​                     switch(i) {</p>
<p>​                            case 0: print(“zero”); break;</p>
<p>​                            case 1: print(“isa”); break;</p>
<p>​                            case 2: print(“dalawa”); break;</p>
<p>​                            case 3: print(“tatlo”); break;</p>
<p>​                            case 4: print(“apat”); break;</p>
<p>​                            case 5: print(“lima”); break;</p>
<p>​                            case 6: print(“anim”); break;</p>
<p>​                            case 7: print(“pito”); break;</p>
<p>​                            case 8: print(“walo”); break;</p>
<p>​                            case 9: print(“siyam”); break;</p>
<p>​                            default: print(“default”);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }      </p>
<p>} </p>
<p>public class Fibonacci {</p>
<p>​       int fib(int n) {</p>
<p>​              if(n &lt; 2) return 1;</p>
<p>​              return (fib(n - 2) + fib(n - 1));</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Fibonacci f = new Fibonacci();</p>
<p>​              int k = Integer.parseInt(args[0]);</p>
<p>​              System.out.println(“First “ + k + “ Fibonacci number(s): “);</p>
<p>​              for(int i = 0; i &lt; k; i++)</p>
<p>​                     System.out.println(f.fib(i));</p>
<p>​       }      </p>
<p>}</p>
<p>public class VampireNumbers {   </p>
<p>​              static int a(int i) {</p>
<p>​                     return i         }</p>
<p>​              static int b(int i) {</p>
<p>​                     return (i%1000)            }</p>
<p>​              static int c(int i) {</p>
<p>​                     return ((i%1000)%100)          }</p>
<p>​              static int d(int i) {</p>
<p>​                     return ((i%1000)%100)%10;</p>
<p>​              }</p>
<p>​              static int com(int i, int j) {</p>
<p>​                     return (i * 10) + j;</p>
<p>​              }</p>
<p>​              static void productTest (int i, int m, int n) {</p>
<p>​                     if(m * n == i) System.out.println(i + “ = “ + m + “ * “ + n);</p>
<p>​              }      </p>
<p>​       public static void main(String[] args) {        </p>
<p>​              for(int i = 1001; i &lt; 9999; i++) {                </p>
<p>​                     productTest(i, com(a(i), b(i)), com(c(i), d(i)));</p>
<p>​                     productTest(i, com(a(i), b(i)), com(d(i), c(i)));</p>
<p>​                     productTest(i, com(a(i), c(i)), com(b(i), d(i)));</p>
<p>​                     productTest(i, com(a(i), c(i)), com(d(i), b(i)));</p>
<p>​                     productTest(i, com(a(i), d(i)), com(b(i), c(i)));</p>
<p>​                     productTest(i, com(a(i), d(i)), com(c(i), b(i)));</p>
<p>​                     productTest(i, com(b(i), a(i)), com(c(i), d(i)));</p>
<p>​                     productTest(i, com(b(i), a(i)), com(d(i), c(i)));</p>
<p>​                     productTest(i, com(b(i), c(i)), com(d(i), a(i)));</p>
<p>​                     productTest(i, com(b(i), d(i)), com(c(i), a(i)));</p>
<p>​                     productTest(i, com(c(i), a(i)), com(d(i), b(i)));</p>
<p>​                     productTest(i, com(c(i), b(i)), com(d(i), a(i)));</p>
<p>​              }                    </p>
<p>​       } </p>
<p>}</p>
<p> class Tester {</p>
<p>​       String s;</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Leetcode图解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Leetcode图解/" itemprop="url">Leetcode图解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><table>
<thead>
<tr>
<th>ID</th>
<th>Problem</th>
<th>Article</th>
<th>Animation</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>两数之和</td>
<td><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483740&idx=1&sn=1950545589ea9b86ee65fbb6be1f4290&chksm=fa0e6eddcd79e7cb542b7d4dc1304eead516994315fa4f52b575230f0f022c9e0a88ede3714e&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Two Sum</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161033.gif" alt="img"></td>
</tr>
<tr>
<td>019</td>
<td>删除链表的倒数第N个节点</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483821&idx=1&sn=11ecccab76cd53163e9dedb75effeb93&chksm=fa0e6e2ccd79e73ae9137c0d91b3533df4ea4ead4ad081834b8d91ff364c0d55c350ddcfa6c4&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Remove Nth Node From End of List</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161058.gif" alt="img"></td>
</tr>
<tr>
<td>020</td>
<td>有效的括号</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483824&idx=1&sn=ab9362e125dc5e2b3ef1611cad9448c2&chksm=fa0e6e31cd79e727c6e1e0e3c467e193edb6ae841a41e5dc8eef39d0bf3141cc53f63b019cba&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Valid Parentheses</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161106.gif" alt="img"></td>
</tr>
<tr>
<td>024</td>
<td>两两交换链表中的节点</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483773&idx=1&sn=db6cf272df968cd6571eb0bb50ecc721&chksm=fa0e6efccd79e7ea26810d335e6ece9ac23b8e3ac31be00dbd534018737ccb3ef9a00f22aff3&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Swap Nodes in Pairs</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161115.gif" alt="img"></td>
</tr>
<tr>
<td>026</td>
<td>删除排序数组中的重复项</td>
<td>每天一算：Remove Duplicates from Sorted Array</td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161124.gif" alt="img"></td>
</tr>
<tr>
<td>075</td>
<td>颜色分类</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483706&idx=1&sn=905f43c882a91b55fd169d812620f277&chksm=fa0e6ebbcd79e7ad8857b0dad9ad14dbaf17fe557ef56ba600cec26b2bb668df2e171431d74c&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Sort Colors</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161136.gif" alt="img"></td>
</tr>
<tr>
<td>086</td>
<td>分隔链表</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483781&idx=1&sn=f31548ebbb2cf9ba56d979d3e51ddde2&chksm=fa0e6e04cd79e712d6cc7ff8e8b7631b7300ac0fa1a3e4c4e3b836de7a01fb5d0d6428a18bc4&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Partition List</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161147.gif" alt="img"></td>
</tr>
<tr>
<td>092</td>
<td>反转链表 II</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483820&idx=1&sn=113e87b55c8ac8e22e9db00673798118&chksm=fa0e6e2dcd79e73b5835a262599b935783de3317a453bc0ed8df9fa5d1532785a085ea663e59&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Reverse Linked List II</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161156.gif" alt="img"></td>
</tr>
<tr>
<td>094</td>
<td>二叉树的中序遍历</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483853&idx=1&sn=94cd4b4ee8dc2268290a72334c6af57b&chksm=fa0e6e4ccd79e75a41a6b78397b80cdfccda332823874475b516f997f89e786488599fc5cc1e&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Binary Tree Inorder Traversal</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161208.gif" alt="img"></td>
</tr>
<tr>
<td>102</td>
<td>二叉树的层序遍历</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483868&idx=1&sn=d50041789fcd13a75a2296f620b69d71&chksm=fa0e6e5dcd79e74b0030ac5129f10ec4ba87c98da63c5904affe9f06e06ecf28695c410d3ec7&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Binary Tree Level Order Traveral</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161232.gif" alt="img"></td>
</tr>
<tr>
<td>144</td>
<td>二叉树的前序遍历</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483843&idx=1&sn=994bf0d42dd9941a879a3a3ed500a4d6&chksm=fa0e6e42cd79e75472404eb5da7ee98f20d303efe230eb4f41efec57164630f555e7111e62ff&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Binary Tree Preorder Traversal</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161242.gif" alt="img"></td>
</tr>
<tr>
<td>145</td>
<td>二叉树的后序遍历</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483853&idx=1&sn=94cd4b4ee8dc2268290a72334c6af57b&chksm=fa0e6e4ccd79e75a41a6b78397b80cdfccda332823874475b516f997f89e786488599fc5cc1e&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Binary Tree Postorder Traversal</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161255.gif" alt="img"></td>
</tr>
<tr>
<td>150</td>
<td>逆波兰表达式求值</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483834&idx=1&sn=27cbff99f10dfcdb56cb37c237d7f2bb&chksm=fa0e6e3bcd79e72dc430bf81aed9dde9bd01634239dcf7820d6befa881efd323d9d58d76d90d&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Evaluate Reverse Polish Notation</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161304.gif" alt="img"></td>
</tr>
<tr>
<td>167</td>
<td>两数之和 II - 输入有序数组</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483711&idx=1&sn=3afec74e9e9effa71dc0b22659e14b44&chksm=fa0e6ebecd79e7a84db7861c9b5dbccdc98aa9d9a6994dda49a37edeb729e8242ea6af8f20ad&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Two Sum II</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161314.gif" alt="img"></td>
</tr>
<tr>
<td>199</td>
<td>二叉树的右视图</td>
<td>每天一算：Binary Tree Right Side View</td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161328.gif" alt="img"></td>
</tr>
<tr>
<td>203</td>
<td>移除链表元素</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483766&idx=1&sn=6721376a65680bf7cf9064cf7b1ae4ae&chksm=fa0e6ef7cd79e7e1665e60fe6ea3f2087bca518c1573bc4c4b9425573f98401bafc59542dca0&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Remove Linked List Elements</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161338.gif" alt="img"></td>
</tr>
<tr>
<td>219</td>
<td>存在重复元素 II</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483755&idx=1&sn=2501b6ca09c43eaa9fba71a9bd1f5253&chksm=fa0e6eeacd79e7fc192c0a23cf90d98fe6f2c35f9e4f2d0f937ccba45a58cf23a0a9c49d35d5&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Contains Duplicate II</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161352.gif" alt="img"></td>
</tr>
<tr>
<td>237</td>
<td>删除链表中的节点</td>
<td>每天一算：Delete Node in a Linked List</td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161400.gif" alt="img"></td>
</tr>
<tr>
<td>283</td>
<td>移动零</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483700&idx=1&sn=465f778d60e8560742feab5844d7cac5&chksm=fa0e6eb5cd79e7a357899d378edb532b498cd63e3ce9113f8ac74d397ce4b214ca5aa8198b7d&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Move Zeros</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161421.gif" alt="img"></td>
</tr>
<tr>
<td>328</td>
<td>奇偶链表</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483786&idx=1&sn=f7810950b34675e1c4420361faf5e361&chksm=fa0e6e0bcd79e71d2c6fc6a4a68b6ef7a17abc3dc9897548f8e44b51e9494f52c4cebbc4176e&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Odd Even Linked List</a></td>
<td></td>
</tr>
<tr>
<td>344</td>
<td>反转字符串</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483799&idx=1&sn=c2212c8963809e8d3392abeeb851dbfc&chksm=fa0e6e16cd79e7003c2d30b1a2bb4f23dc56df38e3efedd0ab2cfae291609280a832eabe67de&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Reverse String</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161431.gif" alt="img"></td>
</tr>
<tr>
<td>349</td>
<td>两个数组的交集</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483726&idx=1&sn=a887f6b983058d97c183dd300832ecbb&chksm=fa0e6ecfcd79e7d985587b543622c85aadc83a4d7a074135e1356fb4a0ebfd07e7af13467906&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Intersection of Two Arrays</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161441.gif" alt="img"></td>
</tr>
<tr>
<td>350</td>
<td>两个数组的交集 II</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483733&idx=1&sn=946bd6de3251437dd77b43ecab056c82&chksm=fa0e6ed4cd79e7c2a439b5f1853bf5154a3438ed282c7ba5e94948780c426a1f1492c0b201c4&scene=21#wechat_redirect" target="_blank" rel="noopener">每天一算：Intersection of Two Arrays II</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161729.gif" alt="img"></td>
</tr>
<tr>
<td>447</td>
<td>回旋镖的数量</td>
<td><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483747&idx=1&sn=7774eee0b252b311257134f6a52c4e2d&chksm=fa0e6ee2cd79e7f44858c46c3d04859ced9073dbb9de95ce7ee0bcc131e613862ddfd9a6f158&scene=21#wechat_redirect" target="_blank" rel="noopener">每日一算：Number of Boomerangs</a></td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161738.gif" alt="img"></td>
</tr>
<tr>
<td>454</td>
<td>四数相加 II</td>
<td>每日一算：4Sum II</td>
<td><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181206161751.gif" alt="img"></td>
</tr>
</tbody></table>
<p>蓝色链接可直接进入原文阅读，黑色文章标题表明还未发布！</p>
<p>解释：</p>
<p>比如这题：有效的括号动画分析<br>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。</p>
<p>这里我们使用栈。</p>
<p>遍历输入字符串<br>如果当前字符为左半边括号时，则将其压入栈中<br>如果遇到右半边括号时，分类讨论：<br>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环<br>2）若此时栈为空，则直接返回false<br>3）若不为对应的左半边括号，反之返回false</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解内部类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解内部类/" itemprop="url">Java题解内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第十章内部类"><a href="#第十章内部类" class="headerlink" title="第十章内部类"></a>第十章内部类</h2><p>public class Outer1 {</p>
<p>​       class Inner { </p>
<p>​              Inner() { System.out.println(“Inner()”); }</p>
<p>​       }</p>
<p>​       Outer1() { System.out.println(“Outer1()”); }</p>
<p>​             Inner makeInner() {</p>
<p>​              return new Inner();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer1 o = new Outer1();</p>
<p>​              Inner i = o.makeInner();</p>
<p>​       }</p>
<p>}</p>
<p>class Word {</p>
<p>​       private String word;</p>
<p>​       public Word(String s) { word = s; }</p>
<p>​       public String toString() { return word; }</p>
<p>} </p>
<p>interface Selector {</p>
<p>​       boolean end();</p>
<p>​       Object current();</p>
<p>​       void next();</p>
<p>}</p>
<p>public class Sequence2 {</p>
<p>​       private Object[] items;</p>
<p>​       private int next = 0;</p>
<p>​       public Sequence2(int size) { items = new Object[size]; }</p>
<p>​       public void add(Object x) {</p>
<p>​              if(next &lt; items.length)</p>
<p>​                     items[next++] = x;</p>
<p>​       }</p>
<p>​       private class SequenceSelector implements Selector {</p>
<p>​              private int i = 0;</p>
<p>​              public boolean end() { return i == items.length; }</p>
<p>​              public Object current() { return items[i]; }</p>
<p>​              public void next() { if(i &lt; items.length) i++; } </p>
<p>​       }</p>
<p>​       public Selector selector() {</p>
<p>​              return new SequenceSelector();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Sequence2 sequence = new Sequence2(10);</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     sequence.add(new Word(Integer.toString(i)));</p>
<p>​              Selector selector = sequence.selector();</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​              Word w1 = new Word(“Peace”);</p>
<p>​              Word w2 = new Word(“Love”);</p>
<p>​              Word w3 = new Word(“Easter”);</p>
<p>​              Sequence2 message = new Sequence2(3);</p>
<p>​              message.add(w1);</p>
<p>​              message.add(w2);</p>
<p>​              message.add(w3);</p>
<p>​              Selector sel = message.selector();</p>
<p>​              while(!sel.end()) {</p>
<p>​                     System.out.print(sel.current() + “ “);</p>
<p>​                     sel.next();</p>
<p>​              }</p>
<p>​                     </p>
<p>​       }</p>
<p>}</p>
<p>public class Outer3 {</p>
<p>​       private String s;</p>
<p>​       class Inner3 { </p>
<p>​              Inner3() { System.out.println(“Inner()”); }</p>
<p>​              public String toString() { return s; }</p>
<p>​       }</p>
<p>​       Outer3(String s) { </p>
<p>​              System.out.println(“Outer1()”);</p>
<p>​              this.s = s;</p>
<p>​       }</p>
<p>​       Inner3 makeInner3() {</p>
<p>​              return new Inner3();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer3 o = new Outer3(“Hi is risen!”);</p>
<p>​              Inner3 i = o.makeInner3();</p>
<p>​              System.out.println(i.toString());</p>
<p>​       }</p>
<p>}</p>
<p>interface Selector {</p>
<p>​       boolean end();</p>
<p>​       Object current();</p>
<p>​       void next();</p>
<p>}</p>
<p>public class Sequence4 {</p>
<p>​       private Object[] items;</p>
<p>​       private int next = 0;</p>
<p>​             public void test() { System.out.println(“Sequence4.test()”); }</p>
<p>​       public Sequence4(int size) { items = new Object[size]; }</p>
<p>​       public void add(Object x) {</p>
<p>​              if(next &lt; items.length)</p>
<p>​                     items[next++] = x;</p>
<p>​       }</p>
<p>​       private class SequenceSelector implements Selector {</p>
<p>​              private int i = 0;</p>
<p>​              public boolean end() { return i == items.length; }</p>
<p>​              public Object current() { return items[i]; }</p>
<p>​              public void next() { if(i &lt; items.length) i++; } </p>
<p>​                           public Sequence4 sequence4() { return Sequence4.this; }</p>
<p>​       }</p>
<p>​       public Selector selector() {</p>
<p>​              return new SequenceSelector();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Sequence4 sequence = new Sequence4(10);</p>
<p>​              for(int i = 0; i &lt; 10; i++)</p>
<p>​                     sequence.add(Integer.toString(i));</p>
<p>​              Selector selector = sequence.selector();</p>
<p>​              while(!selector.end()) {</p>
<p>​                     System.out.print(selector.current() + “ “);</p>
<p>​                     selector.next();</p>
<p>​              }</p>
<p>​                           ((SequenceSelector)selector).sequence4().test();        </p>
<p>​       }</p>
<p>}</p>
<p>class Outer {</p>
<p>​       class Inner { </p>
<p>​              Inner() { System.out.println(“Outer.Inner()”); } </p>
<p>​       }      </p>
<p>}</p>
<p>public class OtherOuter { </p>
<p>​       public static void main(String[] args) {</p>
<p>​                           Outer o = new Outer();</p>
<p>​                           Outer.Inner oi = o.new Inner();                  </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex6 extends Ex6Base {</p>
<p>​       Ex6Interface getBaseInner() { </p>
<p>​              return this.new Ex6BaseInner();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex6 ex = new Ex6();</p>
<p>​              System.out.println(ex.getBaseInner().say());</p>
<p>​       }      </p>
<p>}</p>
<p>class Outer7 {</p>
<p>​       private int oi = 1;</p>
<p>​       private void hi() { System.out.println(“Outer hi”); }</p>
<p>​       class Inner {</p>
<p>​              void modifyOuter() { </p>
<p>​                     oi *= 2;</p>
<p>​                     hi(); </p>
<p>​              }</p>
<p>​       }</p>
<p>​       public void showOi() { System.out.println(oi); }</p>
<p>​       void testInner() {</p>
<p>​              Inner in = new Inner();</p>
<p>​              in.modifyOuter();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer7 out = new Outer7();</p>
<p>​              out.showOi();</p>
<p>​              out.testInner();</p>
<p>​              out.showOi();</p>
<p>​       }</p>
<p>}</p>
<p>class Outer8 { </p>
<p>​       class Inner {</p>
<p>​              private int ii1 = 1;</p>
<p>​              private int ii2 = 2;</p>
<p>​              private void showIi2() { System.out.println(ii2); }</p>
<p>​              private void hi() { System.out.println(“Inner hi”); }</p>
<p>​              }</p>
<p>​             int oi = new Inner().ii1;</p>
<p>​       void showOi() { System.out.println(oi); }</p>
<p>​       void showIi2() { new Inner().showIi2(); } </p>
<p>​       void outerHi() { new Inner().hi(); }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer8 out = new Outer8();</p>
<p>​              out.showOi();</p>
<p>​              out.showIi2();</p>
<p>​              out.outerHi();</p>
<p>​       }</p>
<p>}</p>
<p>interface Ex9Interface {</p>
<p>​       void say(String s); </p>
<p>}</p>
<p>public class Ex9 {   </p>
<p>​       Ex9Interface f() {</p>
<p>​              class Inner implements Ex9Interface {</p>
<p>​                     public void say(String s) {</p>
<p>​                            System.out.println(s); </p>
<p>​                     }</p>
<p>​              }</p>
<p>​              return new Inner();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex9 x = new Ex9();</p>
<p>​              x.f().say(“hi”);</p>
<p>​       } </p>
<p>}</p>
<p>interface Ex10Interface {</p>
<p>​       void say(String s); </p>
<p>}</p>
<p>public class Ex10 { </p>
<p>​       Ex10Interface f(boolean b) {</p>
<p>​              if(b) {</p>
<p>​                     class Inner implements Ex10Interface {</p>
<p>​                            public void say(String s) {</p>
<p>​                                   System.out.println(s); </p>
<p>​                            }</p>
<p>​                     }</p>
<p>​                     return new Inner();</p>
<p>​              }</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex10 x = new Ex10();</p>
<p>​              x.f(true).say(“hi”);</p>
<p>​       } </p>
<p>}</p>
<p>class Test {</p>
<p>​       private class Inner implements Ex11Interface {</p>
<p>​              public void say(String s) {</p>
<p>​                     System.out.println(s); </p>
<p>​              }</p>
<p>​       }</p>
<p>​       Ex11Interface f() {</p>
<p>​              return new Inner();</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex11 { </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Test t = new Test();</p>
<p>​              t.f().say(“hi”);</p>
<p>​                                 } </p>
<p>}</p>
<p>interface Inner12 {</p>
<p>​       void modifyOuter();</p>
<p>}</p>
<p>public class Outer12 {</p>
<p>​       private int oi = 1;</p>
<p>​       private void hi() { System.out.println(“Outer hi”); }</p>
<p>​       public Inner12 inner() {</p>
<p>​              return new Inner12() {</p>
<p>​                     public void modifyOuter() { </p>
<p>​                            oi *= 2;</p>
<p>​                            hi(); </p>
<p>​                     }</p>
<p>​              }; </p>
<p>​       }</p>
<p>​       public void showOi() { System.out.println(oi); }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer12 out = new Outer12();</p>
<p>​              out.showOi();</p>
<p>​              out.inner().modifyOuter();</p>
<p>​              out.showOi();</p>
<p>​       }</p>
<p>}</p>
<p>interface Ex13Interface {</p>
<p>​       String say(String s); </p>
<p>}</p>
<p>public class Outer13 {   </p>
<p>​       Ex13Interface f() {</p>
<p>​              return new Ex13Interface() {</p>
<p>​                     public String say(String s) { return s; }</p>
<p>​              };</p>
<p>​       } </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Outer13 o = new Outer13();</p>
<p>​              System.out.println(o.f().say(“Hi”));</p>
<p>​       }</p>
<p>}</p>
<p>interface Monster {</p>
<p>​       void menace();</p>
<p>}      </p>
<p>interface DangerousMonster extends Monster {</p>
<p>​       void destroy();</p>
<p>}      </p>
<p>interface Lethal {</p>
<p>​       void kill();</p>
<p>}</p>
<p>class DragonZilla implements DangerousMonster {</p>
<p>​       public void menace() {}</p>
<p>​       public void destroy() {}</p>
<p>}</p>
<p>interface Vampire extends DangerousMonster, Lethal {</p>
<p>​       void drinkBlood();</p>
<p>}</p>
<p>class VeryBadVampire implements Vampire {</p>
<p>​       public void menace() {}</p>
<p>​       public void destroy() {}</p>
<p>​       public void kill() {}</p>
<p>​       public void drinkBlood() {} </p>
<p>}</p>
<p>public class HorrorShow14 {</p>
<p>​       static void u(Monster b) { b.menace(); }</p>
<p>​       static void v(DangerousMonster d) {</p>
<p>​              d.menace();</p>
<p>​              d.destroy();</p>
<p>​       }</p>
<p>​       static void w(Lethal l) { l.kill(); }</p>
<p>​       public DangerousMonster monsterMaker() {</p>
<p>​              return new DangerousMonster() {</p>
<p>​                     public void menace() { println(“DangerousMonster Menace”); }</p>
<p>​                     public void destroy() { println(“DangerousMonster Destroy”); }</p>
<p>​              };</p>
<p>​       }</p>
<p>​       public Vampire vampireMaker() {</p>
<p>​              return new Vampire() {</p>
<p>​                     public void menace() { println(“Vampire Menace”); }</p>
<p>​                     public void destroy() { println(“Vampire Destroy”); }</p>
<p>​                     public void kill() { println(“Vampire Kill”); }</p>
<p>​                     public void drinkBlood() { println(“Vampire DrinkBlood”); }</p>
<p>​              };</p>
<p>​       }             </p>
<p>​       public static void main(String[] args) {</p>
<p>​              HorrorShow14 show = new HorrorShow14();</p>
<p>​              show.u(show.monsterMaker());</p>
<p>​              show.v(show.monsterMaker());</p>
<p>​              show.u(show.vampireMaker());</p>
<p>​              show.v(show.vampireMaker());</p>
<p>​              show.w(show.vampireMaker());</p>
<p>​       }</p>
<p>}</p>
<p>class One {</p>
<p>​       private String s;</p>
<p>​       One(String s) { this.s = s; } </p>
<p>​       public String showS() { return s; }</p>
<p>}</p>
<p>public class Ex15 {</p>
<p>​       public One makeOne(String s) {</p>
<p>​              return new One(s) { };</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex15 x = new Ex15();</p>
<p>​              System.out.println(x.makeOne(“hi”).showS());</p>
<p>​       }</p>
<p>}</p>
<p>interface Cycle {</p>
<p>​       void ride();</p>
<p>}</p>
<p>interface CycleFactory {</p>
<p>​       Cycle getCycle();</p>
<p>}</p>
<p>class Unicycle implements Cycle {</p>
<p>​       private Unicycle() { println(“Unicycle()”); }</p>
<p>​       public void ride() { println(“Ride Unicycle”); }</p>
<p>​       public static CycleFactory factory =</p>
<p>​              new CycleFactory() {</p>
<p>​                     public Cycle getCycle() { return new Unicycle(); }</p>
<p>​              };</p>
<p>}</p>
<p>class Bicycle implements Cycle {</p>
<p>​       private Bicycle() { println(“Bicycle()”); }</p>
<p>​       public void ride() { println(“Ride Bicycle”); }</p>
<p>​       public static CycleFactory factory =</p>
<p>​              new CycleFactory() {</p>
<p>​                     public Cycle getCycle() { return new Bicycle(); }</p>
<p>​              };</p>
<p>}</p>
<p>class Tricycle implements Cycle {</p>
<p>​       private Tricycle() { println(“Tricycle()”); }</p>
<p>​       public void ride() { println(“Ride Tricycle”); }</p>
<p>​       public static CycleFactory factory =</p>
<p>​              new CycleFactory() {</p>
<p>​                     public Cycle getCycle() { return new Tricycle(); }</p>
<p>​              }; </p>
<p>}</p>
<p>public class Cycles {</p>
<p>​       public static void rideCycle(CycleFactory factory) {</p>
<p>​              Cycle c = factory.getCycle();</p>
<p>​              c.ride();</p>
<p>​       }</p>
<p>​       public static void main(String [] args) {</p>
<p>​              rideCycle(Unicycle.factory);</p>
<p>​              rideCycle(Bicycle.factory);</p>
<p>​              rideCycle(Tricycle.factory);    </p>
<p>​       }</p>
<p>}</p>
<p>interface Games {</p>
<p>​       void play();</p>
<p>}</p>
<p>interface GamesFactory {</p>
<p>​       Games getGames();</p>
<p>}</p>
<p>class CoinToss implements Games {</p>
<p>​       Random rand = new Random();</p>
<p>​       public void play() { </p>
<p>​              print(“Toss Coin: “);</p>
<p>​              switch(rand.nextInt(2)) {</p>
<p>​                     case 0 : println(“Heads”); return;</p>
<p>​                     case 1 : println(“Tails”); return;</p>
<p>​                     default: println(“OnEdge”); return;</p>
<p>​              } </p>
<p>​       }</p>
<p>​       public static GamesFactory factory =</p>
<p>​              new GamesFactory() {</p>
<p>​                     public Games getGames() { return new CoinToss(); }       </p>
<p>​              };</p>
<p>}</p>
<p>class DiceThrow implements Games {</p>
<p>​       Random rand = new Random();</p>
<p>​       public void play() { </p>
<p>​              print(“Throw Dice: “ + (rand.nextInt(6) + 1));            </p>
<p>​       }</p>
<p>​       public static GamesFactory factory =</p>
<p>​              new GamesFactory() {</p>
<p>​                     public Games getGames() { return new DiceThrow(); }</p>
<p>​              };</p>
<p>}</p>
<p>public class Games17 {</p>
<p>​       public static void playGame(GamesFactory factory) {</p>
<p>​              Games g = factory.getGames();</p>
<p>​              g.play();</p>
<p>​       }</p>
<p>​       public static void main(String [] args) {</p>
<p>​              playGame(CoinToss.factory);</p>
<p>​              playGame(DiceThrow.factory);                  </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex18 {</p>
<p>​       Ex18() { System.out.println(“Ex18()”); }</p>
<p>​       public static class Ex18Nest1 {</p>
<p>​              Ex18Nest1() { System.out.println(“Ex18Nest1()”); }</p>
<p>​       }</p>
<p>​       private static class Ex18Nest2 {</p>
<p>​              Ex18Nest2() { System.out.println(“Ex18Nest2()”); }</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex18Nest1 en1 = new Ex18Nest1();</p>
<p>​              Ex18Nest2 en2 = new Ex18Nest2();</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex19 {</p>
<p>​       Ex19() { System.out.println(“Ex19()”); }</p>
<p>​       private class Ex19Inner {</p>
<p>​              Ex19Inner() { System.out.println(“Ex19Inner()”); } </p>
<p>​              private class Ex19InnerInner {</p>
<p>​                     Ex19InnerInner() {</p>
<p>​                            System.out.println(“Ex19InnerInner()”);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }</p>
<p>​       private static class Ex19Nested {</p>
<p>​              Ex19Nested() { System.out.println(“Ex19Nested()”); }</p>
<p>​              private static class Ex19NestedNested {</p>
<p>​                     Ex19NestedNested() { </p>
<p>​                     System.out.println(“Ex19NestedNested()”); </p>
<p>​                     }</p>
<p>​              }</p>
<p>​       }      </p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex19Nested en = new Ex19Nested();</p>
<p>​              Ex19Nested.Ex19NestedNested enn = new Ex19Nested.Ex19NestedNested();</p>
<p>​              Ex19 e19 = new Ex19();</p>
<p>​              Ex19.Ex19Inner ei = e19.new Ex19Inner();</p>
<p>​              Ex19.Ex19Inner.Ex19InnerInner eii = ei.new Ex19InnerInner();</p>
<p>​       }</p>
<p>}</p>
<p>interface In {</p>
<p>​       class Nested {</p>
<p>​              Nested() { System.out.println(“Nested()”); }</p>
<p>​              public void hi() { System.out.println(“hi”); }        </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex20 implements In {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              In.Nested in = new In.Nested();</p>
<p>​              in.hi();                          </p>
<p>​       }</p>
<p>}</p>
<p>interface In {</p>
<p>​       String f();</p>
<p>​       String g(); </p>
<p>​       class Nested {</p>
<p>​              static void testIn(In i) { </p>
<p>​                     System.out.println(i.f() + i.g());</p>
<p>​              }             </p>
<p>​       }             </p>
<p>}</p>
<p>public class Ex21 implements In {</p>
<p>​       public String f() { return “hello “; }</p>
<p>​       public String g() { return “friend”; }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              Ex21 x = new Ex21();</p>
<p>​              In.Nested.testIn(x);                                    </p>
<p>​       }</p>
<p>}</p>
<p>interface U {</p>
<p>​       void f();</p>
<p>​       void g();</p>
<p>​       String toString();</p>
<p>}</p>
<p>class A {</p>
<p>​       U buildU() {</p>
<p>​              return new U() {</p>
<p>​                     public void f() { System.out.println(“f()”); }</p>
<p>​                     public void g() { System.out.println(“g()”); }</p>
<p>​                     public String toString() { return “I’m a U”; }</p>
<p>​              };</p>
<p>​       }</p>
<p>}</p>
<p>class B {</p>
<p>​       private U[] us;</p>
<p>​       B(int i) {</p>
<p>​              us = new U[i];</p>
<p>​       }</p>
<p>​       void addU(U u, int i) {</p>
<p>​              us[i] = u;</p>
<p>​       }</p>
<p>​       void eraseU(int i) {</p>
<p>​              us[i] = null;    </p>
<p>​       }</p>
<p>​       void testUs() {</p>
<p>​              for(U u : us) {</p>
<p>​                     u.f();</p>
<p>​                     u.g();</p>
<p>​                     u.toString();</p>
<p>​              }             </p>
<p>​       }</p>
<p>​       void showUs() {</p>
<p>​              for(U u : us) { </p>
<p>​                     if(u != null) System.out.println(u.toString());</p>
<p>​                     else System.out.println(“I’m null”);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex23 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              A a0 = new A();</p>
<p>​              A a1 = new A();</p>
<p>​              A a2 = new A();</p>
<p>​              B b = new B(3);</p>
<p>​              b.addU(a0.buildU(), 0);</p>
<p>​              b.addU(a1.buildU(), 1);</p>
<p>​              b.addU(a2.buildU(), 2);</p>
<p>​              b.showUs();</p>
<p>​              b.testUs();</p>
<p>​              b.eraseU(0);</p>
<p>​              b.eraseU(1);</p>
<p>​              b.showUs();</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseController24 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls24 gc = new GreenhouseControls24();</p>
<p>​                                        gc.addEvent(gc.new Bell(900));</p>
<p>​              Event[] eventList = {</p>
<p>​                     gc.new ThermostatNight(0),</p>
<p>​                     gc.new LightOn(200),</p>
<p>​                     gc.new FanOn(300),</p>
<p>​                     gc.new LightOff(400),</p>
<p>​                     gc.new FanOff(500),</p>
<p>​                     gc.new WaterOn(600),</p>
<p>​                     gc.new WaterOff(800),</p>
<p>​                     gc.new ThermostatDay(1400),</p>
<p>​              };</p>
<p>​              gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​              if(args.length == 1)</p>
<p>​                     gc.addEvent(</p>
<p>​                            new GreenhouseControls24.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseControls24 extends Controller {</p>
<p>​       private boolean fan = false;</p>
<p>​       public class FanOn extends Event {</p>
<p>​              public FanOn(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             fan = true;</p>
<p>​              }</p>
<p>​              public String toString() { return “Fan is on”; }</p>
<p>​       }</p>
<p>​       public class FanOff extends Event {</p>
<p>​              public FanOff(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             fan = false;</p>
<p>​              }</p>
<p>​              public String toString() { return “Fan is off”; }</p>
<p>​       }</p>
<p>​       private boolean light = false;</p>
<p>​       public class LightOn extends Event {</p>
<p>​              public LightOn(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             light = true;</p>
<p>​              }</p>
<p>​              public String toString() { return “Light is on”; }</p>
<p>​       }</p>
<p>​       public class LightOff extends Event {</p>
<p>​              public LightOff(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                                             light = false;</p>
<p>​              }</p>
<p>​              public String toString() { return “Light is off”; }</p>
<p>​       }</p>
<p>​       private boolean water = false;</p>
<p>​       public class WaterOn extends Event {</p>
<p>​              public WaterOn(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                         water = true;</p>
<p>​              }</p>
<p>​              public String toString() { </p>
<p>​                     return “Greenhouse water is on”;</p>
<p>​              } </p>
<p>​       }</p>
<p>​       public class WaterOff extends Event {</p>
<p>​              public WaterOff(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                                         water = false;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Greenhouse water is off”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       private String thermostat = “Day”;</p>
<p>​       public class ThermostatNight extends Event {</p>
<p>​              public ThermostatNight(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                                         thermostat = “Night”;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Thermostat on night setting”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public class ThermostatDay extends Event {</p>
<p>​              public ThermostatDay(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }      </p>
<p>​              public void action() {</p>
<p>​                                         thermostat = “Day”;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Thermostat on day setting”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​                   public class Bell extends Event {</p>
<p>​              public Bell(long delayTime) { super(delayTime); }</p>
<p>​              public void action() {</p>
<p>​                     addEvent(new Bell(delayTime));</p>
<p>​              }</p>
<p>​              public String toString() { return “Bing!”; }</p>
<p>​       }</p>
<p>​       public class Restart extends Event {</p>
<p>​              private Event[] eventList;</p>
<p>​              public Restart(long delayTime, Event[] eventList) {</p>
<p>​                     super(delayTime);</p>
<p>​                     this.eventList = eventList;</p>
<p>​                     for(Event e : eventList)</p>
<p>​                            addEvent(e);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                     for(Event e : eventList) {</p>
<p>​                            e.start();                             addEvent(e);</p>
<p>​                     }</p>
<p>​                     start();                 addEvent(this);</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Restarting system”;</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static class Terminate extends Event {</p>
<p>​              public Terminate(long delayTime) { super(delayTime); }</p>
<p>​              public void action() { System.exit(0); }</p>
<p>​              public String toString() { return “Terminating”; }</p>
<p>​       }</p>
<p>}      </p>
<p>public class GreenhouseController25 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls25 gc = new GreenhouseControls25();</p>
<p>​                                        gc.addEvent(gc.new Bell(900));</p>
<p>​              Event[] eventList = {</p>
<p>​                     gc.new ThermostatNight(0),</p>
<p>​                     gc.new LightOn(200),</p>
<p>​                     gc.new LightOff(400),</p>
<p>​                     gc.new WaterOn(600),</p>
<p>​                     gc.new WaterMistOn(650),</p>
<p>​                     gc.new WaterMistOff(700),</p>
<p>​                     gc.new WaterOff(800),</p>
<p>​                     gc.new ThermostatDay(1400),</p>
<p>​              };</p>
<p>​              gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​              if(args.length == 1)</p>
<p>​                     gc.addEvent(</p>
<p>​                            new GreenhouseControls.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseControls25 extends GreenhouseControls {</p>
<p>​       private boolean waterMist = false;</p>
<p>​       public class WaterMistOn extends Event {</p>
<p>​              public WaterMistOn(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                                                             waterMist = true;</p>
<p>​              }</p>
<p>​              public String toString() { </p>
<p>​                     return “Water mist generator on”;  </p>
<p>​              }</p>
<p>​       }      </p>
<p>​       public class WaterMistOff extends Event {</p>
<p>​              public WaterMistOff(long delayTime) {</p>
<p>​                     super(delayTime);</p>
<p>​              }</p>
<p>​              public void action() {</p>
<p>​                                                             waterMist = false;</p>
<p>​              }</p>
<p>​              public String toString() {</p>
<p>​                     return “Water mist generator off”;</p>
<p>​              }</p>
<p>​       }      </p>
<p>}</p>
<p>class FirstOuter {</p>
<p>​       public class FirstInner {</p>
<p>​              FirstInner(String s) { </p>
<p>​                     System.out.println(“FirstOuter.FirstInner() “ + s ); </p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class SecondOuter {</p>
<p>​       public class SecondInner extends FirstOuter.FirstInner {</p>
<p>​              SecondInner(FirstOuter x) { </p>
<p>​                     x.super(“hello”); </p>
<p>​                     System.out.println(“SecondOuter.SecondInner()”); </p>
<p>​              }             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              FirstOuter fo = new FirstOuter();</p>
<p>​              SecondOuter so = new SecondOuter();</p>
<p>​              SecondInner si = so.new SecondInner(fo);        </p>
<p>​       }      </p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/06/2019-10-06-Java题解IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/2019-10-06-Java题解IO/" itemprop="url">Java题解IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T10:00:00+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第十八章-IO"><a href="#第十八章-IO" class="headerlink" title="第十八章 IO"></a>第十八章 IO</h2><p>public class DirList1a {         </p>
<p>​       public static void main(final String[] args) {</p>
<p>​              File path = new File(“.”);</p>
<p>​              final String[] list;</p>
<p>​              if(args.length &lt; 2) { </p>
<p>​                     list = path.list();</p>
<p>​                     System.out.println(“Usage: enter filtering regex”);</p>
<p>​                     System.out.println(</p>
<p>​                     “followed by words, one or more of which each file must contain.”);</p>
<p>​              }</p>
<p>​              else {</p>
<p>​                     list = path.list(new FilenameFilter() {</p>
<p>​                            private Pattern pattern = Pattern.compile(args[0]);</p>
<p>​                            public boolean accept(File dir, String name) {</p>
<p>​                                   return pattern.matcher(name).matches() &amp;&amp;</p>
<p>​                                   !(Collections.disjoint(</p>
<p>​                                          Arrays.asList(args).subList(1, args.length),</p>
<p>​                                          new TextFile(name, “\W+”)</p>
<p>​                                   ));</p>
<p>​                            }</p>
<p>​                     });</p>
<p>​              }</p>
<p>​              Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</p>
<p>​              for(String dirItem : list)</p>
<p>​                     System.out.println(dirItem);</p>
<p>​       }</p>
<p>}</p>
<p>public class DirList1b {         </p>
<p>​       public static void main(final String[] args) {</p>
<p>​              File path = new File(“.”);</p>
<p>​              final String[] list;</p>
<p>​              if(args.length == 0) { </p>
<p>​                     list = path.list();</p>
<p>​                     System.out.println(</p>
<p>​                            “Usage: enter words, one or more of which each file must contain”);</p>
<p>​              }</p>
<p>​              else {</p>
<p>​                     list = path.list(new FilenameFilter() {</p>
<p>​                            public boolean accept(File dir, String name) {</p>
<p>​                                   return !(Collections.disjoint(</p>
<p>​                                                 Arrays.asList(args),</p>
<p>​                                                 new TextFile(name, “\W+”)</p>
<p>​                                          )</p>
<p>​                                   );</p>
<p>​                            }</p>
<p>​                     });</p>
<p>​              }</p>
<p>​              Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</p>
<p>​              for(String dirItem : list)</p>
<p>​                     System.out.println(dirItem);</p>
<p>​       }</p>
<p>}</p>
<p>public class SortedDirList2 {</p>
<p>​       private String[] dirList;</p>
<p>​       public SortedDirList2(File dir) {</p>
<p>​              dirList = dir.list();</p>
<p>​              Arrays.sort(dirList, String.CASE_INSENSITIVE_ORDER);</p>
<p>​       }</p>
<p>​       public String[] list() { return dirList; }</p>
<p>​       public String[] list(String regex) {</p>
<p>​              Pattern pattern = Pattern.compile(regex);</p>
<p>​              ArrayList<string> slist = new ArrayList<string>();</string></string></p>
<p>​              int count = 0;</p>
<p>​              for(String s : dirList) {</p>
<p>​                     if(pattern.matcher(s).matches()) {</p>
<p>​                            count++;</p>
<p>​                            slist.add(s);</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              return slist.toArray(new String[count]);</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              StringBuilder sb = new StringBuilder();</p>
<p>​              for(String s : dirList) sb.append(s + ‘\n’);</p>
<p>​              return sb.toString();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              SortedDirList2 dirList = new SortedDirList2(new File(“.”));</p>
<p>​              System.out.println(dirList);</p>
<p>​              for(String s : dirList.list()) </p>
<p>​                     System.out.println(s);</p>
<p>​              System.out.println();</p>
<p>​              for(String s : dirList.list(“.+\.java”))</p>
<p>​                     System.out.println(s);</p>
<p>​       }</p>
<p>}</p>
<p>public class DirListFileSizes { </p>
<p>​       public static void main(final String[] args) {</p>
<p>​              File path = new File(“.”);</p>
<p>​              File[] files;</p>
<p>​              if(args.length == 0)</p>
<p>​                    files = path.listFiles(); </p>
<p>​              else</p>
<p>​                     files = path.listFiles(new FileFilter() {</p>
<p>​                            private Pattern pattern = Pattern.compile(args[0]);</p>
<p>​                            public boolean accept(File file) {</p>
<p>​                                   return pattern.matcher(file.getPath()).matches();</p>
<p>​                            }</p>
<p>​                     });</p>
<p>​              Arrays.sort(files);</p>
<p>​              long sum = 0;</p>
<p>​              for(File f : files) {</p>
<p>​                     System.out.print(f + “: “);</p>
<p>​                     System.out.println(f.length());</p>
<p>​                     sum += f.length();</p>
<p>​              }</p>
<p>​              System.out.println(“Total size: “ + sum);</p>
<p>​       }</p>
<p>}</p>
<p>public class Ex4 {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              long sum = 0;</p>
<p>​              if(args.length == 0) {</p>
<p>​                     for(File file : Directory.walk(“.”).files) {</p>
<p>​                            System.out.print(file + “: “);</p>
<p>​                            System.out.println(file.length());</p>
<p>​                            sum += file.length();</p>
<p>​                     }</p>
<p>​                     </p>
<p>​              }</p>
<p>​              else </p>
<p>​                     for(String arg : args) {</p>
<p>​                            {</p>
<p>​                            for(File file : Directory.walk(“.”, arg).files) {</p>
<p>​                                   System.out.print(file + “: “);</p>
<p>​                                   System.out.println(file.length());</p>
<p>​                                   sum += file.length();</p>
<p>​                            }</p>
<p>​                            System.out.println();</p>
<p>​                     }</p>
<p>​              }</p>
<p>​              System.out.println(“Total size: “ + sum);</p>
<p>​       }</p>
<p>}</p>
<p>public class ProcessFiles5 {</p>
<p>​       public interface Strategy {</p>
<p>​                  void process(File file);</p>
<p>​      }</p>
<p>​      private Strategy strategy;</p>
<p>​      private String regex;</p>
<p>​       public ProcessFiles5(Strategy strategy, String regex) {</p>
<p>​                  this.strategy = strategy;</p>
<p>​           this.regex = regex;</p>
<p>​      }</p>
<p>​      public void start(String[] args) {</p>
<p>​                  try {</p>
<p>​                        if(args.length == 0)</p>
<p>​                      processDirectoryTree(new File(“.”));</p>
<p>​                 else</p>
<p>​                      for(String arg : args) {</p>
<p>​                            File fileArg = new File(arg);</p>
<p>​                            if(fileArg.isDirectory())</p>
<p>​                                        processDirectoryTree(fileArg);</p>
<p>​                            else {</p>
<p>​                                   Pattern pattern = Pattern.compile(regex);</p>
<p>​                                   if(pattern.matcher(arg).matches())                                                    strategy.process(</p>
<p>​                                                     new File(arg).getCanonicalFile());</p>
<p>​                            }</p>
<p>​                      }</p>
<p>​                  } catch(IOException e) {</p>
<p>​                        throw new RuntimeException(e);</p>
<p>​                  }</p>
<p>​      }</p>
<p>​      public void processDirectoryTree(File root) throws IOException {</p>
<p>​                  for(File file : Directory.walk(</p>
<p>​                      root.getAbsolutePath(), regex))</p>
<p>​                 strategy.process(file.getCanonicalFile());</p>
<p>​      }</p>
<p>​           public static void main(String[] args) {</p>
<p>​                  new ProcessFiles5(new ProcessFiles5.Strategy() {</p>
<p>​                        public void process(File file) {</p>
<p>​                             System.out.println(file);</p>
<p>​                        }</p>
<p>​                  }, “.<em>D.</em>“).start(args);</p>
<p>​      }</p>
<p>} </p>
<p>public class ModifiedAfter6 {</p>
<p>​       public static void main(final String[] args) {</p>
<p>​              if(args.length != 2) {</p>
<p>​                     System.out.println(“Usage: directory date(mm                      System.out.println(“(Outputs a listing of all java files in the given directory” +</p>
<p>​                            “\nthat were last modified on or after the given date.)”);</p>
<p>​                     return;</p>
<p>​              }</p>
<p>​              final SimpleDateFormat sdf = new SimpleDateFormat(“MM        new ProcessFiles(new ProcessFiles.Strategy() {</p>
<p>​                     public void process(File file) {</p>
<p>​                            Date modDate = new Date(file.lastModified());</p>
<p>​                            try {</p>
<p>​                                   if(modDate.after(sdf.parse(args[1])))</p>
<p>​                                          System.out.println(file);</p>
<p>​                            } catch(ParseException e) {</p>
<p>​                                   System.out.println(e.getMessage());</p>
<p>​                            }</p>
<p>​                     }</p>
<p>​              }, “java”).start(args);</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLines7 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)</p>
<p>​                     list.add(s);            while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);               in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              System.out.print(readAndReverse(“ReverseLines7.java”));</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLines8 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)</p>
<p>​                     list.add(s);            while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);               in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length != 1) {</p>
<p>​                     System.out.println(“Usage: enter file name”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.print(readAndReverse(args[0]));</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLines9 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)</p>
<p>​                     list.add(s.toUpperCase());          while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);            in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length != 1) {</p>
<p>​                     System.out.println(“Usage: enter file name”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.print(readAndReverse(args[0]));</p>
<p>​       }</p>
<p>}</p>
<p>public class ReverseLinesWordSearch10 {</p>
<p>​             public static String readReverseFind(String[] sa) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(sa[0]));</p>
<p>​              String s;</p>
<p>​              List<string> find = new ArrayList<string>();</string></string></p>
<p>​              for(String t : sa) find.add(t);</p>
<p>​              find.remove(0);           LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null) {</p>
<p>​                                         List<string> line = Arrays.asList(s.split(“\W+”));</string></p>
<p>​                                         if(!(Collections.disjoint(line, find))) </p>
<p>​                            list.add(s);            }</p>
<p>​              while(list.peekLast() != null)                     sb.append(list.pollLast() + “\n”);               in.close();</p>
<p>​              return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length &lt; 2) {</p>
<p>​                     System.out.println(“Usage: enter file name\n” +</p>
<p>​                            “followed by words to find in lines of that file”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.print(readReverseFind(args));</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseController11 {</p>
<p>​             public static Map&lt;String,Long&gt; readEvents(String filename) </p>
<p>​       throws IOException {</p>
<p>​              BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              Map&lt;String,Long&gt; map = new HashMap&lt;String,Long&gt;();</p>
<p>​              while((s = in.readLine()) != null) {</p>
<p>​                     String [] sa = s.split(“[()]”);</p>
<p>​                     map.put(sa[0], new Long(sa[1]));</p>
<p>​              }</p>
<p>​              in.close();</p>
<p>​              return map;</p>
<p>​       }</p>
<p>​             private static Event makeEvent(GreenhouseControls gc, Map.Entry&lt;String,Long&gt; me) {</p>
<p>​              String key = me.getKey();</p>
<p>​              Long value = me.getValue();</p>
<p>​              if(key.equals(“Bell”)) return gc.new Bell(value);</p>
<p>​              if(key.equals(“LightOn”)) return gc.new LightOn(value);</p>
<p>​              if(key.equals(“LightOff”)) return gc.new LightOff(value);</p>
<p>​              if(key.equals(“WaterOn”)) return gc.new WaterOn(value);</p>
<p>​              if(key.equals(“WaterOff”)) return gc.new WaterOff(value);</p>
<p>​              if(key.equals(“ThermostatDay”)) return gc.new ThermostatDay(value);</p>
<p>​              if(key.equals(“ThermostatNight”)) return gc.new ThermostatNight(value);</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls gc = new GreenhouseControls();</p>
<p>​                                        try {</p>
<p>​                                         Map&lt;String,Long&gt; map = readEvents(“Events.txt”);</p>
<p>​                     Event[] eventList = new Event[map.size()];</p>
<p>​                     int i = 0;</p>
<p>​                                         for(Map.Entry&lt;String,Long&gt; me : map.entrySet()) {</p>
<p>​                            eventList[i++] = makeEvent(gc, me);</p>
<p>​                     }</p>
<p>​                     gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​                     if(args.length != 1) {</p>
<p>​                            System.out.println(“Usage: enter integer terminate time”);</p>
<p>​                            System.exit(0);</p>
<p>​                     }</p>
<p>​                     if(args.length == 1)</p>
<p>​                            gc.addEvent(new GreenhouseControls.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }      </p>
<p>​       }      </p>
<p>}</p>
<p>interface EventFactory {</p>
<p>​       Event getEvent(GreenhouseControls gc, Long time);</p>
<p>}</p>
<p>class BellFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new Bell(time);</p>
<p>​       }</p>
<p>}</p>
<p>class LightOnFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new LightOn(time);</p>
<p>​       }</p>
<p>}</p>
<p>class LightOffFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new LightOff(time);</p>
<p>​       }</p>
<p>}</p>
<p>class WaterOnFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new WaterOn(time);</p>
<p>​       }</p>
<p>}</p>
<p>class WaterOffFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new WaterOff(time);</p>
<p>​       }</p>
<p>}</p>
<p>class ThermostatDayFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new ThermostatDay(time);</p>
<p>​       }</p>
<p>}</p>
<p>class ThermostatNightFactory implements EventFactory {</p>
<p>​       public Event getEvent(GreenhouseControls gc, Long time) {</p>
<p>​              return gc.new ThermostatNight(time);</p>
<p>​       }</p>
<p>}</p>
<p>public class GreenhouseController11b {</p>
<p>​             public static Map&lt;String,Long&gt; readEvents(String filename) </p>
<p>​       throws IOException {</p>
<p>​              BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              Map&lt;String,Long&gt; map = new HashMap&lt;String,Long&gt;();</p>
<p>​              while((s = in.readLine()) != null) {</p>
<p>​                     String [] sa = s.split(“[()]”);</p>
<p>​                     map.put(sa[0], new Long(sa[1]));</p>
<p>​              }</p>
<p>​              in.close();</p>
<p>​              return map;</p>
<p>​       }</p>
<p>​             private static Event makeEvent(GreenhouseControls gc, Map.Entry&lt;String,Long&gt; me) {</p>
<p>​              String key = me.getKey();</p>
<p>​              Long value = me.getValue();</p>
<p>​              if(key.equals(“Bell”)) return new BellFactory().getEvent(gc,value);</p>
<p>​              if(key.equals(“LightOn”)) return new LightOnFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“LightOff”)) return new LightOffFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“WaterOn”)) return new WaterOnFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“WaterOff”)) return new WaterOffFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“ThermostatDay”)) </p>
<p>​                     return new ThermostatDayFactory().getEvent(gc, value);</p>
<p>​              if(key.equals(“ThermostatNight”)) </p>
<p>​                     return new ThermostatNightFactory().getEvent(gc, value);</p>
<p>​              return null;</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​              GreenhouseControls gc = new GreenhouseControls();</p>
<p>​                                        try {</p>
<p>​                                         Map&lt;String,Long&gt; map = readEvents(“Events.txt”);</p>
<p>​                     Event[] eventList = new Event[map.size()];</p>
<p>​                     int i = 0;</p>
<p>​                                         for(Map.Entry&lt;String,Long&gt; me : map.entrySet()) {</p>
<p>​                            eventList[i++] = makeEvent(gc, me);</p>
<p>​                     }</p>
<p>​                     gc.addEvent(gc.new Restart(2000, eventList));</p>
<p>​                     if(args.length != 1) {</p>
<p>​                            System.out.println(“Usage: enter integer terminate time”);</p>
<p>​                            System.exit(0);</p>
<p>​                     }</p>
<p>​                     if(args.length == 1)</p>
<p>​                            gc.addEvent(new GreenhouseControls.Terminate(</p>
<p>​                                   new Integer(args[0])));</p>
<p>​              gc.run();</p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.out.println(e);</p>
<p>​              }      </p>
<p>​       }      </p>
<p>}</p>
<p>public class ReverseLines12 {</p>
<p>​             public static String readAndReverse(String filename) throws IOException {</p>
<p>​                           BufferedReader in = new BufferedReader(new FileReader(filename));</p>
<p>​              String s;</p>
<p>​              LinkedList<string> list = new LinkedList<string>(); </string></string></p>
<p>​              StringBuilder sb = new StringBuilder();           String[] temp = filename.split(“\.”);</p>
<p>​              String file = temp[0] + “Reversed.” + temp[1]; </p>
<p>​              PrintWriter out = new PrintWriter(file);            int lineCount = 1;</p>
<p>​              while((s = in.readLine()) != null)</p>
<p>​                                         list.add(lineCount++ + “ “ + s); </p>
<p>​              while(list.peekLast() != null) {                   String t = list.pollLast();                    out.println(t);</p>
<p>​                     sb.append(t + “\n”); </p>
<p>​              }</p>
<p>​              in.close();</p>
<p>​              out.close();          return sb.toString();             </p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              if(args.length != 1) {</p>
<p>​                     System.out.println(“Usage: enter file name”);</p>
<p>​                     System.exit(1);</p>
<p>​              }</p>
<p>​              System.out.println(readAndReverse(args[0]));</p>
<p>​       }</p>
<p>}</p>
<p>public class BasicFileOutput13 {</p>
<p>​       static String file = “BasicFileOutput13.out”;</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              LineNumberReader in = new LineNumberReader(</p>
<p>​                     new FileReader(“BasicFileOutput13.java”));</p>
<p>​              PrintWriter out = new PrintWriter(file);</p>
<p>​              String s;</p>
<p>​              while((s = in.readLine()) != null )</p>
<p>​                     out.println(in.getLineNumber() + “: “ + s);</p>
<p>​              out.close();</p>
<p>​                           System.out.println(BufferedInputFile.read(file));</p>
<p>​       }             </p>
<p>}</p>
<p>public class BasicFileOutput14 {</p>
<p>​       static String file = “BasicFileOutput14.out”;</p>
<p>​       static String file2 = “BasicFileOutput142.out”;</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              BufferedReader in = new BufferedReader(</p>
<p>​                     new StringReader(</p>
<p>​                            BufferedInputFile.read(“BasicFileOutput14.java”)));</p>
<p>​                           PrintWriter out = new PrintWriter(</p>
<p>​                     new BufferedWriter(new FileWriter(file)));</p>
<p>​              int lineCount = 1;</p>
<p>​              String s;</p>
<p>​              long start = System.nanoTime();</p>
<p>​              while((s = in.readLine()) != null )</p>
<p>​                     out.println(lineCount++ + “: “ + s);</p>
<p>​              long duration = System.nanoTime() - start;</p>
<p>​              out.close();</p>
<p>​              System.out.println(“Buffered write:   “ + duration + “ nanoseconds”);</p>
<p>​              BufferedReader in2 = new BufferedReader(</p>
<p>​                     new StringReader(</p>
<p>​                            BufferedInputFile.read(“BasicFileOutput14.java”)));</p>
<p>​                           PrintWriter out2 = new PrintWriter(new FileWriter(file2));</p>
<p>​              int lineCount2 = 1;</p>
<p>​              String s2;</p>
<p>​              long start2 = System.nanoTime();</p>
<p>​              while((s2 = in2.readLine()) != null )</p>
<p>​                     out2.println(lineCount2++ + “: “ + s2);</p>
<p>​              long duration2 = System.nanoTime() - start2;</p>
<p>​              out2.close();</p>
<p>​              System.out.println(“Unbuffered write: “ + duration2 + “ nanoseconds”);</p>
<p>​                           System.out.println(“file: “ + BufferedInputFile.read(file));</p>
<p>​              System.out.println(“file2: “ + BufferedInputFile.read(file2));</p>
<p>​       }             </p>
<p>}</p>
<p>public class StoringAndRecoveringData15 {</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              DataOutputStream out = new DataOutputStream(</p>
<p>​                     new BufferedOutputStream(</p>
<p>​                            new FileOutputStream(“Data.txt”)));</p>
<p>​              println(“Initial out.size() = “ + out.size());</p>
<p>​              byte[] ba = {0,1,2,3};</p>
<p>​                           out.write(ba,0,3);</p>
<p>​                           out.write(ba);</p>
<p>​              out.write((int)255);             out.writeBoolean(true);</p>
<p>​              out.writeByte((int)1000000);</p>
<p>​              out.writeBytes((String)”hi”);</p>
<p>​              out.writeChar(120);</p>
<p>​              out.writeChars(“hi”);            </p>
<p>​              out.writeDouble(3.14159);</p>
<p>​              out.writeFloat(2.1f);</p>
<p>​              out.writeInt(1057);</p>
<p>​              out.writeLong(123456789L);</p>
<p>​              out.writeShort(123);</p>
<p>​              out.writeUTF(“Nice piece of work”);</p>
<p>​              println(“After writing, out.size() = “ + out.size());              </p>
<p>​              out.close();</p>
<p>​              println(“Reading:”);</p>
<p>​              DataInputStream in = new DataInputStream(</p>
<p>​                     new BufferedInputStream(</p>
<p>​                            new FileInputStream(“Data.txt”)));</p>
<p>​              byte[] baIn = new byte[3];</p>
<p>​              println(“bytes read by in.read(baIn, 0, 3) = “ + in.read(baIn, 0, 3));</p>
<p>​              print(“baIn = “);</p>
<p>​              for(int i = 0; i &lt; baIn.length; i++)</p>
<p>​                     print(baIn[i] + “ “);</p>
<p>​              println();</p>
<p>​                           println(“in.readInt() = “ + in.readInt());</p>
<p>​              println(“in.read() = “ + in.read());        </p>
<p>​              println(“in.readBoolean() = “ + in.readBoolean());            </p>
<p>​              println(“in.readByte() = “ + in.readByte());         </p>
<p>​              println(“in.read() = “ + in.read());             println(“in.read() = “ + in.read());             println(“in.readChar() = “ + in.readChar());</p>
<p>​              println(“in.readChar() = “ + in.readChar());</p>
<p>​              println(“in.readChar() = “ + in.readChar());</p>
<p>​              println(“in.readDouble() = “ + in.readDouble());</p>
<p>​              println(“in.readFloat() = “ + in.readFloat());</p>
<p>​              println(“in.readInt() = “ + in.readInt());</p>
<p>​              println(“in.readLong() = “ + in.readLong());</p>
<p>​              println(“in.readShort() = “ + in.readShort());</p>
<p>​              println(“in.readUTF() = “ + in.readUTF());          </p>
<p>​       }</p>
<p>}</p>
<p>public class UsingRandomAccessFile16 {</p>
<p>​       static String file = “r16test.dat”;</p>
<p>​       static void display() throws IOException {</p>
<p>​              RandomAccessFile rf = new RandomAccessFile(file, “r”);</p>
<p>​              byte[] bIn = new byte[3];</p>
<p>​              rf.read(bIn);</p>
<p>​              for(int i = 0; i &lt; bIn.length; i++)</p>
<p>​                     print(bIn[i] + “ “);</p>
<p>​              println();</p>
<p>​                           println(“rf.readInt() = “ + rf.readInt());</p>
<p>​              println(“rf.read() = “ + rf.read());         </p>
<p>​              println(“rf.readBoolean() = “ + rf.readBoolean());             </p>
<p>​              println(“rf.readByte() = “ + rf.readByte());          </p>
<p>​              println(“rf.read() = “ + rf.read());              println(“rf.read() = “ + rf.read());              println(“rf.readChar() = “ + rf.readChar());</p>
<p>​              println(“rf.readChar() = “ + rf.readChar());</p>
<p>​              println(“rf.readChar() = “ + rf.readChar());</p>
<p>​              println(“rf.readDouble() = “ + rf.readDouble());</p>
<p>​              println(“rf.readFloat() = “ + rf.readFloat());</p>
<p>​              println(“rf.readInt() = “ + rf.readInt());</p>
<p>​              println(“rf.readLong() = “ + rf.readLong());</p>
<p>​              println(“rf.readShort() = “ + rf.readShort());</p>
<p>​              println(“rf.readUTF() = “ + rf.readUTF());</p>
<p>​              rf.close();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) throws IOException {     </p>
<p>​              RandomAccessFile rf = new RandomAccessFile(file, “rw”);</p>
<p>​              byte[] ba = {0,1,2,3};</p>
<p>​                           rf.write(ba,0,3);</p>
<p>​                           rf.write(ba);</p>
<p>​              rf.write((int)255);                rf.writeBoolean(true);</p>
<p>​              rf.writeByte((int)1000000);</p>
<p>​              rf.writeBytes((String)”hi”);</p>
<p>​              rf.writeChar(120);</p>
<p>​              rf.writeChars(“hi”);        </p>
<p>​              rf.writeDouble(3.14159);</p>
<p>​              rf.writeFloat(2.1f);</p>
<p>​              rf.writeInt(1057);</p>
<p>​              rf.writeLong(123456789L);</p>
<p>​              rf.writeShort(123);</p>
<p>​              rf.writeUTF(“Nice piece of work”);              </p>
<p>​              display();        </p>
<p>​       }</p>
<p>}</p>
<p>public class CharCounter {</p>
<p>​       </p>
<p>​       public static void main(String[] args) {</p>
<p>​                           String fileName = “CharCounter.java”;</p>
<p>​                           char[] ca = read(fileName).toCharArray();</p>
<p>​                           Set<character> charSet = new TreeSet<character>();    </character></character></p>
<p>​              for(char c : ca) charSet.add(c);                       List<character> charList = new ArrayList<character>();</character></character></p>
<p>​              for(char c : ca) charList.add(c);</p>
<p>​              Map&lt;Character,Integer&gt; charMap = new HashMap&lt;Character,Integer&gt;();</p>
<p>​              for(Character c : charSet) {</p>
<p>​                     int count = 0;</p>
<p>​                     for(Character d : charList) {</p>
<p>​                            if(d.equals(c)) count++;</p>
<p>​                     }</p>
<p>​                     charMap.put(c, count);</p>
<p>​              }  </p>
<p>​              print();</p>
<p>​              print(charMap);            </p>
<p>​       }</p>
<p>}</p>
<p>public class TextFile18 extends ArrayList<string> {</string></p>
<p>​            public static String read(String fileName) throws IOException {</p>
<p>​                  StringBuilder sb = new StringBuilder();</p>
<p>​                  BufferedReader in = new BufferedReader(new FileReader(</p>
<p>​                      new File(fileName).getAbsoluteFile()));</p>
<p>​                 try {</p>
<p>​                      String s;</p>
<p>​                      while((s = in.readLine()) != null) {</p>
<p>​                            sb.append(s);</p>
<p>​                            sb.append(“\n”);</p>
<p>​                      }</p>
<p>​                 } finally {</p>
<p>​                      in.close();</p>
<p>​                 }</p>
<p>​                  return sb.toString();</p>
<p>​      }</p>
<p>​           public static void write(String fileName, String text) throws IOException {</p>
<p>​                  PrintWriter out = new PrintWriter(</p>
<p>​                      new File(fileName).getAbsoluteFile());</p>
<p>​                 try {</p>
<p>​                      out.print(text);</p>
<p>​                 } finally {</p>
<p>​                      out.close();</p>
<p>​                 }</p>
<p>​           }</p>
<p>​           public TextFile18(String fileName, String splitter) throws IOException {</p>
<p>​                  super(Arrays.asList(read(fileName).split(splitter)));</p>
<p>​                                                    if(get(0).equals(“”)) remove(0);</p>
<p>​      }</p>
<p>​           public TextFile18(String fileName) throws IOException {</p>
<p>​                  this(fileName, “\n”);</p>
<p>​      }</p>
<p>​      public void write(String fileName) throws IOException {</p>
<p>​                  PrintWriter out = new PrintWriter(</p>
<p>​                      new File(fileName).getAbsoluteFile());</p>
<p>​                 try {</p>
<p>​                      for(String item : this)</p>
<p>​                     out.println(item);</p>
<p>​                 } finally {</p>
<p>​                      out.close();</p>
<p>​                 }</p>
<p>​           }</p>
<p>​           public static void main(String[] args) {</p>
<p>​              try {</p>
<p>​                         String file = read(“TextFile18.java”);</p>
<p>​                         write(“test.txt”, file);</p>
<p>​                         TextFile18 text = new TextFile18(“test.txt”);</p>
<p>​                         text.write(“test2.txt”);</p>
<p>​                                                 TreeSet<string> words = new TreeSet<string>(</string></string></p>
<p>​                               new TextFile18(“TextFile18.java”, “\W+”));               </p>
<p>​                                                 System.out.println(words.headSet(“a”));</p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.err.println(“Caught “ + e);</p>
<p>​                     e.printStackTrace();</p>
<p>​              }</p>
<p>​      }</p>
<p>} </p>
<p>public class ByteCounter19 {       </p>
<p>​       public static void main(String[] args) {</p>
<p>​                           String fileName = “ByteCounter19.java”;</p>
<p>​              try {</p>
<p>​                                         byte[] ba = read(fileName);         </p>
<p>​                                         Set<byte> byteSet = new TreeSet<byte>();      </byte></byte></p>
<p>​                     for(Byte b : ba) byteSet.add(b);                                           List<byte> byteList = new ArrayList<byte>();</byte></byte></p>
<p>​                     for(byte b : ba) byteList.add(b);</p>
<p>​                     Map&lt;Byte,Integer&gt; byteMap = new HashMap&lt;Byte,Integer&gt;();</p>
<p>​                     for(Byte b : byteSet) {</p>
<p>​                            int count = 0;</p>
<p>​                            for(Byte d : byteList) {</p>
<p>​                                   if(d.equals(b)) count++;</p>
<p>​                            }</p>
<p>​                     byteMap.put(b, count);</p>
<p>​                     }  </p>
<p>​                     print();</p>
<p>​                     print(byteMap);     </p>
<p>​              } catch(IOException e) {</p>
<p>​                     System.err.print(“Caught “ + e);</p>
<p>​              } </p>
<p>​       }</p>
<p>}</p>
<p>public class Ex20 {</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              for(File file : Directory.walk(“.”, “.*\.class”).files) {</p>
<p>​                     byte[] ba = read(file);</p>
<p>​                     for(int i = 0; i &lt; 4; i++)</p>
<p>​                            print(Integer.toHexString(ba[i] &amp; 0xff).toUpperCase());</p>
<p>​                     println();</p>
<p>​              }             </p>
<p>​       } </p>
<p>}</p>
<p>public class Ex21 {</p>
<p>​       public static void main(String[] args) throws IOException {</p>
<p>​              File file = new File(“Ex21.java”);</p>
<p>​              BufferedInputStream inFile = </p>
<p>​                     new BufferedInputStream(new</p>
<p>​                            FileInputStream(file));</p>
<p>​              System.setIn(inFile);             </p>
<p>​              BufferedReader stdin = new BufferedReader(</p>
<p>​                     new InputStreamReader(System.in));</p>
<p>​              String s;</p>
<p>​              while((s = stdin.readLine()) != null)</p>
<p>​                     System.out.println(s.toUpperCase());          </p>
<p>​       }</p>
<p>}</p>
<p>class OSExecute22Exception extends RuntimeException {</p>
<p>​       public OSExecute22Exception(String s) { super(s); }</p>
<p>}</p>
<p>class OSExecute22 {</p>
<p>​       public static List<string> command(String command) {</string></p>
<p>​              boolean err = false;</p>
<p>​              List<string> ls = new ArrayList<string>(); </string></string></p>
<p>​              try {</p>
<p>​                     Process process = new ProcessBuilder(</p>
<p>​                            command.split(“ “)).start();</p>
<p>​                     BufferedReader results = new BufferedReader(</p>
<p>​                            new InputStreamReader(process.getInputStream()));</p>
<p>​                     String s;                </p>
<p>​                     while((s = results.readLine()) != null) {</p>
<p>​                            ls.add(s);</p>
<p>​                     }</p>
<p>​                     BufferedReader errors = new BufferedReader(</p>
<p>​                            new InputStreamReader(process.getErrorStream()));</p>
<p>​                                                             while((s = errors.readLine()) != null) { </p>
<p>​                            System.err.println(s);</p>
<p>​                            err = true;</p>
<p>​                     }</p>
<p>​              } catch(Exception e) {</p>
<p>​                                                             if(!command.startsWith(“CMD                        command(“CMD                       else</p>
<p>​                            throw new RuntimeException(e);</p>
<p>​              }</p>
<p>​              if(err)</p>
<p>​                     throw new OSExecute22Exception(“Errors executing “ + command);</p>
<p>​              return ls;</p>
<p>​       }</p>
<p>} </p>
<p>public class OSExecute22Test {</p>
<p>​       public static void main(String[] args) {</p>
<p>​              for(String s : OSExecute22.command(“javap OSExecute22Test”))</p>
<p>​                     println(s);</p>
<p>​       }</p>
<p>}</p>
<p>public class CharBufferPrinter23 {</p>
<p>​       public static boolean isPrintable(char c) {</p>
<p>​                           return (((c &gt;= ‘!’) &amp;&amp; (c &lt;= ‘~’)) ? true : false);</p>
<p>​       }</p>
<p>​       public static void printCharBuffer(CharBuffer cb) {</p>
<p>​              cb.clear();            while(cb.hasRemaining()) {</p>
<p>​                     char c = cb.get();          </p>
<p>​                     if(isPrintable(c)) System.out.print(c);</p>
<p>​              }</p>
<p>​       } </p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              char[] ca = {‘w’,’x’,’y’,’z’};</p>
<p>​              CharBuffer cb = CharBuffer.wrap(ca);</p>
<p>​              print(“CharBuffer by wrapping char[]: “);</p>
<p>​              printCharBuffer(cb);</p>
<p>​              println();</p>
<p>​              CharBuffer cb2 = CharBuffer.allocate(6);</p>
<p>​              char[] ca2 = {‘s’,’t’,’u’,’v’,’w’};</p>
<p>​              cb2.put(ca2); </p>
<p>​              print(“CharBuffer by allocation: “);</p>
<p>​              printCharBuffer(cb2);</p>
<p>​              println();</p>
<p>​                           char[] ca3 = {(char)0x01, (char)0x07, (char)0x7F,’b’,’y’,’e’};</p>
<p>​              CharBuffer cb3 = CharBuffer.wrap(ca3);</p>
<p>​              print(“CharBuffer including some unprintables: “);</p>
<p>​              printCharBuffer(cb3);           </p>
<p>​       }</p>
<p>}</p>
<p>public class DoubleBufferDemo24 {</p>
<p>​       private static final int BSIZE = 1024;</p>
<p>​       public static void main(String[] args) {</p>
<p>​              ByteBuffer bb = ByteBuffer.allocate(BSIZE);</p>
<p>​              DoubleBuffer db = bb.asDoubleBuffer();</p>
<p>​                           db.put(new </p>
<p>​                     double[]{11.11,42.42,27.37,99.99,143.143,811.811,1016.1026});</p>
<p>​                           System.out.println(db.get(3));</p>
<p>​              db.put(3, 1811.1811);</p>
<p>​                           db.flip();</p>
<p>​              while(db.hasRemaining()) {</p>
<p>​                     double d = db.get();</p>
<p>​                     System.out.println(d);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class AllocateDirectTest25 {     </p>
<p>​                   public static File toDirect(File f) throws IOException {</p>
<p>​              FileChannel fcIn = new FileInputStream(f).getChannel();  </p>
<p>​              ByteBuffer b = ByteBuffer.allocateDirect((int)f.length());</p>
<p>​              fcIn.read(b);</p>
<p>​              b.flip();</p>
<p>​              Charset cs = Charset.defaultCharset();       </p>
<p>​              CharBuffer cb = cs.decode(b);</p>
<p>​              String cbD1 = cb.toString().replace(</p>
<p>​                     “.allocate(“, “.allocateDirect(“);</p>
<p>​              String cbD = cbD1.replace(f.getName().split(“\.”)[0], </p>
<p>​                     f.getName().split(“\.”)[0] + “Direct”);</p>
<p>​              CharBuffer cbNew = CharBuffer.wrap(cbD);</p>
<p>​              String ext = (f.getName().split(“\.”))[1];</p>
<p>​              String outFile = (f.getName().split(“\.”))[0] + </p>
<p>​                     “Direct.” + ext;</p>
<p>​              FileChannel fcOut = </p>
<p>​                     new FileOutputStream(</p>
<p>​                            new File(outFile)).getChannel();</p>
<p>​              fcOut.write(cs.encode(cbNew));          </p>
<p>​                           fcIn.close();</p>
<p>​              fcOut.close();</p>
<p>​              return new File(outFile);</p>
<p>​       }</p>
<p>​             public static void Tester(String s) {</p>
<p>​              try {                     Class c = Class.forName(s);</p>
<p>​                     String name = c.getSimpleName();</p>
<p>​                     print(“Testing: “ + name);</p>
<p>​                     @SuppressWarnings(“unchecked”)</p>
<p>​                     Method m = c.getMethod(“main”, String[].class);</p>
<p>​                                                             String[] sa = new String[]{“ChannelCopy.java”, “Test.txt”};</p>
<p>​                     long startRun = System.nanoTime(); </p>
<p>​                     m.invoke(c.newInstance(), (Object)sa);</p>
<p>​                     long duration = System.nanoTime() - startRun;</p>
<p>​                     print(“\nTime to run “ + name + “ = “ </p>
<p>​                            + duration + “ nanoseconds”);                         </p>
<p>​              } catch(Exception e) {</p>
<p>​                     e.printStackTrace(System.err);</p>
<p>​              }</p>
<p>​       }</p>
<p>​       public static long allocationTime(int i) { </p>
<p>​              long start = System.nanoTime();</p>
<p>​              ByteBuffer bb = ByteBuffer.allocate(i);</p>
<p>​              return System.nanoTime() - start;</p>
<p>​       }      </p>
<p>​       public static long directAllocationTime(int i) { </p>
<p>​              long start = System.nanoTime();</p>
<p>​              ByteBuffer bb = ByteBuffer.allocateDirect(i);</p>
<p>​              return System.nanoTime() - start;</p>
<p>​       }</p>
<p>​       </p>
<p>​       public static void main(final String[] args) throws IOException {</p>
<p>​                           print(“Time to allocate 1024 bytes = “ </p>
<p>​                     + allocationTime(1024) + “ nanoseconds”);</p>
<p>​              print(“Time to allocateDirect 1024 bytes = “ </p>
<p>​                     + directAllocationTime(1024) + “ nanoseconds”);</p>
<p>​              print(“Time to allocate 48 bytes = “ </p>
<p>​                     + allocationTime(48) + “ nanoseconds”);</p>
<p>​              print(“Time to allocateDirect 48 bytes = “ </p>
<p>​                     + directAllocationTime(48) + “ nanoseconds”);</p>
<p>​              print(“Time to allocate 1 byte = “ </p>
<p>​                     + allocationTime(1) + “ nanoseconds”);</p>
<p>​              print(“Time to allocateDirect 1 byte = “ </p>
<p>​                     + directAllocationTime(1) + “ nanoseconds”);</p>
<p>​              Tester(“GetChannel”);</p>
<p>​              toDirect(new File(“GetChannel.java”));</p>
<p>​                           Tester(“GetChannelDirect”);</p>
<p>​              Tester(“BufferToText”);</p>
<p>​              toDirect(new File(“BufferToText.java”));</p>
<p>​                           Tester(“BufferToTextDirect”);</p>
<p>​              Tester(“ChannelCopy”);</p>
<p>​              toDirect(new File(“ChannelCopy.java”));</p>
<p>​                           Tester(“ChannelCopyDirect”);</p>
<p>​              Tester(“GetData”);</p>
<p>​              toDirect(new File(“GetData.java”));</p>
<p>​                           Tester(“GetDataDirect”);</p>
<p>​              Tester(“IntBufferDemo”);</p>
<p>​              toDirect(new File(“IntBufferDemo.java”));</p>
<p>​                           Tester(“IntBufferDemoDirect”);</p>
<p>​              Tester(“UsingBuffers”);</p>
<p>​              toDirect(new File(“UsingBuffers.java”));</p>
<p>​                           Tester(“UsingBuffersDirect”);</p>
<p>​       }</p>
<p>}</p>
<p>public class JGrep26  {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​              if(args.length &lt; 2) {</p>
<p>​                     System.out.println(“Usage: java JGrep26 file regex”);</p>
<p>​                     System.exit(0);</p>
<p>​              }</p>
<p>​              FileChannel fc = new FileInputStream(args[0]).getChannel();          </p>
<p>​              MappedByteBuffer in = </p>
<p>​                     fc.map(FileChannel.MapMode.READ_ONLY, 0, </p>
<p>​                            new File(args[0]).length());</p>
<p>​                           String[] sa = Charset.forName(System.getProperty(“file.encoding”))</p>
<p>​                     .decode(in).toString().split(“\n”);</p>
<p>​              Pattern p = Pattern.compile(args[1]);         </p>
<p>​              Matcher m = p.matcher(“”);              int index = 0;</p>
<p>​              for(String line : sa) {</p>
<p>​                     m.reset(line);</p>
<p>​                     while(m.find())</p>
<p>​                            System.out.println(index++ + “: “ + </p>
<p>​                                   m.group() + “: “ + m.start());</p>
<p>​              }</p>
<p>​              fc.close();</p>
<p>​       }</p>
<p>}</p>
<p>class A implements Serializable { </p>
<p>​       private int i;    </p>
<p>​       A(int i) { this.i = i; }</p>
<p>​       public String toString() { return “A:” + i; }</p>
<p>} </p>
<p>class B implements Serializable {</p>
<p>​       private char c;</p>
<p>​       private A a;</p>
<p>​       B(char c, A a) {</p>
<p>​              this.c = c;</p>
<p>​              this.a = a;</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              return “B:” + c + “ “ + a;</p>
<p>​       }      </p>
<p>}</p>
<p>public class SerializationTest implements Serializable {</p>
<p>​       private static Random rand = new Random();</p>
<p>​       public static void main(String[] args) </p>
<p>​       throws ClassNotFoundException, IOException {</p>
<p>​              B b = new B(‘x’, new A(rand.nextInt(100)));</p>
<p>​              System.out.println(“b: “ + b);</p>
<p>​              ObjectOutputStream out = new ObjectOutputStream(</p>
<p>​                     new FileOutputStream(“STest.out”));</p>
<p>​              out.writeObject(b);</p>
<p>​              out.close();</p>
<p>​              ObjectInputStream in = new ObjectInputStream(</p>
<p>​                     new FileInputStream(“STest.out”));</p>
<p>​              B b2 = (B)in.readObject();</p>
<p>​              System.out.println(“b2: “ + b2);          </p>
<p>​       }</p>
<p>}</p>
<p>class Blip1 implements Externalizable {</p>
<p>​       public Blip1() {</p>
<p>​              print(“Blip1 Constructor”);</p>
<p>​       }</p>
<p>​       public void writeExternal(ObjectOutput out) </p>
<p>​       throws  IOException {</p>
<p>​              print(“Blip1.writeExternal”);</p>
<p>​       }</p>
<p>​       public void readExternal(ObjectInput in) </p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Blip1.readExternal”);</p>
<p>​       }</p>
<p>}</p>
<p>public class BlipCheck implements Externalizable {</p>
<p>​                                     public void writeExternal(ObjectOutput out) </p>
<p>​       throws IOException {</p>
<p>​              print(“BlipCheck writeExternal”);</p>
<p>​       }</p>
<p>​       public void readExternal(ObjectInput in) </p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“BlipCheck readExternal”);</p>
<p>​       }</p>
<p>}</p>
<p>class Blips {</p>
<p>​       public static void main(String[] args) </p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Constructing objects:”);</p>
<p>​              Blip1 b1 = new Blip1();</p>
<p>​              Blip2 b2 = new Blip2();</p>
<p>​              BlipCheck bc = new BlipCheck();</p>
<p>​              ObjectOutputStream o = new ObjectOutputStream(</p>
<p>​                     new FileOutputStream(“Blips.out”));</p>
<p>​              print(“Saving objects:”);</p>
<p>​              o.writeObject(b1);</p>
<p>​              o.writeObject(b2);</p>
<p>​              o.writeObject(bc);</p>
<p>​              o.close();</p>
<p>​                           ObjectInputStream in = new ObjectInputStream(</p>
<p>​                     new FileInputStream(“Blips.out”));</p>
<p>​              print(“Recovering b1:”);</p>
<p>​              b1 = (Blip1)in.readObject();</p>
<p>​              print(“Recovering b2:”);</p>
<p>​              b2 = (Blip2)in.readObject();</p>
<p>​              print(“Recovering bc:”);</p>
<p>​              bc = (BlipCheck)in.readObject();</p>
<p>​       }</p>
<p>}</p>
<p>public class Blip29 implements Externalizable {</p>
<p>​       private int i;</p>
<p>​       private String s;   public Blip29() {</p>
<p>​              print(“Blip29 Contstructor”);</p>
<p>​                    }</p>
<p>​       public Blip29(String x, int a) {</p>
<p>​              print(“Blip29(String x, int a)”);</p>
<p>​              s = x;</p>
<p>​              i = a;</p>
<p>​                    }</p>
<p>​       public String toString() { return s + i; }</p>
<p>​       public void writeExternal(ObjectOutput out) </p>
<p>​       throws IOException {</p>
<p>​              print(“Blip29.writeExternal”);</p>
<p>​                                                                                     }</p>
<p>​       public void readExternal(ObjectInput in)</p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Blip29.readExternal”);</p>
<p>​                                                                                     }</p>
<p>​       public static void main(String[] args)</p>
<p>​       throws IOException, ClassNotFoundException {</p>
<p>​              print(“Constructing objects:”);</p>
<p>​              Blip29 b29 = new Blip29(“A String “, 47);</p>
<p>​              print(b29);</p>
<p>​              ObjectOutputStream o = new ObjectOutputStream(</p>
<p>​                     new FileOutputStream(“Blip29.out”));</p>
<p>​              print(“Saving object:”);</p>
<p>​              o.writeObject(b29);</p>
<p>​              o.close();</p>
<p>​                           ObjectInputStream in = new ObjectInputStream(</p>
<p>​                     new FileInputStream(“Blip29.out”));</p>
<p>​              print(“Recovering b29:”);</p>
<p>​              b29 = (Blip29)in.readObject();</p>
<p>​              print(b29);</p>
<p>​       }</p>
<p>}</p>
<p>abstract class Shape implements Serializable {</p>
<p>​       public static final int RED = 1, BLUE = 2, GREEN = 3;</p>
<p>​       private int xPos, yPos, dimension;</p>
<p>​       private static Random rand = new Random(47);</p>
<p>​       private static int counter = 0;</p>
<p>​       public abstract void setColor(int newColor);</p>
<p>​       public abstract int getColor();</p>
<p>​       public Shape(int xVal, int yVal, int dim) {</p>
<p>​              xPos = xVal;</p>
<p>​              yPos = yVal;</p>
<p>​              dimension = dim;</p>
<p>​       }</p>
<p>​       public String toString() {</p>
<p>​              return getClass() + </p>
<p>​                     “ color[“ + getColor() + “] xPos[“ + xPos +</p>
<p>​                     “] yPos[“ + yPos + “] dim[“ + dimension + “]\n”; </p>
<p>​       }</p>
<p>​       public static Shape randomFactory() {</p>
<p>​              int xVal = rand.nextInt(100);</p>
<p>​              int yVal = rand.nextInt(100);</p>
<p>​              int dim = rand.nextInt(100);</p>
<p>​              switch(counter++ % 3) {</p>
<p>​                     default:</p>
<p>​                     case 0: return new Circle(xVal, yVal, dim);</p>
<p>​                     case 1: return new Square(xVal, yVal, dim);</p>
<p>​                     case 2: return new Line(xVal, yVal, dim);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>class Circle extends Shape {</p>
<p>​       private static int color = RED;</p>
<p>​       public static void serializeStaticState(ObjectOutputStream os)</p>
<p>​       throws IOException { os.writeInt(color); }</p>
<p>​       public static void deserializeStaticState(ObjectInputStream os) </p>
<p>​       throws IOException { color = os.readInt(); }</p>
<p>​       public Circle(int xVal, int yVal, int dim) {</p>
<p>​              super(xVal, yVal, dim);</p>
<p>​       }</p>
<p>​       public void setColor(int newColor) { color = newColor; }</p>
<p>​       public int getColor() { return color; }</p>
<p>} </p>
<p>class Square extends Shape {</p>
<p>​       private static int color;</p>
<p>​       public static void serializeStaticState(ObjectOutputStream os)</p>
<p>​       throws IOException { os.writeInt(color); }</p>
<p>​       public static void deserializeStaticState(ObjectInputStream os) </p>
<p>​       throws IOException { color = os.readInt(); }</p>
<p>​       public Square(int xVal, int yVal, int dim) {</p>
<p>​              super(xVal, yVal, dim);</p>
<p>​              color = RED;</p>
<p>​       }</p>
<p>​       public void setColor(int newColor) { color = newColor; }</p>
<p>​       public int getColor() { return color; }</p>
<p>}</p>
<p>class Line extends Shape {</p>
<p>​       private static int color = RED;</p>
<p>​       public static void serializeStaticState(ObjectOutputStream os)</p>
<p>​       throws IOException { os.writeInt(color); }</p>
<p>​       public static void deserializeStaticState(ObjectInputStream os) </p>
<p>​       throws IOException { color = os.readInt(); }</p>
<p>​       public Line(int xVal, int yVal, int dim) {</p>
<p>​              super(xVal, yVal, dim);</p>
<p>​       }</p>
<p>​       public void setColor(int newColor) { color = newColor; }</p>
<p>​       public int getColor() { return color; }</p>
<p>}</p>
<p>public class StoreCADState30 {</p>
<p>​       public static void main(String[] args) throws Exception {</p>
<p>​       List<shape> shapes = new ArrayList<shape>();</shape></shape></p>
<p>​             for(int i = 0; i &lt; 10; i++)</p>
<p>​              shapes.add(Shape.randomFactory());</p>
<p>​             for(int i = 0; i &lt; 10; i++)</p>
<p>​              ((Shape)shapes.get(i)).setColor(Shape.GREEN);</p>
<p>​             ObjectOutputStream out = new ObjectOutputStream(</p>
<p>​              new FileOutputStream(“CADState.out”));</p>
<p>​       Circle.serializeStaticState(out);</p>
<p>​       Square.serializeStaticState(out);</p>
<p>​       Line.serializeStaticState(out);</p>
<p>​       out.writeObject(shapes);</p>
<p>​             System.out.println(shapes);</p>
<p>​       }</p>
<p>}</p>
<p>public class WordCountXML {</p>
<p>​       public static void format(OutputStream os, Document doc) </p>
<p>​       throws Exception {</p>
<p>​              Serializer serializer = new Serializer(os, “ISO-8859-1”);</p>
<p>​              serializer.setIndent(4);</p>
<p>​              serializer.setMaxLength(64);</p>
<p>​              serializer.write(doc);</p>
<p>​              serializer.flush();</p>
<p>​       }</p>
<p>​       public static void main(String[] args) {</p>
<p>​                           String fileName = “WordCountXML.java”;</p>
<p>​                           Set<string> uniqueWords = </string></p>
<p>​                     new TreeSet<string>(new TextFile(fileName, “\W+”));</string></p>
<p>​                           ArrayList<string> allWords = new TextFile(fileName, “\W+”);</string></p>
<p>​              Map&lt;String,Integer&gt; wordCount = new TreeMap&lt;String,Integer&gt;();    </p>
<p>​                           for(String s : uniqueWords) {</p>
<p>​                     int count = 0;</p>
<p>​                     for(String t : allWords) {</p>
<p>​                            if(t.equals(s)) count++;</p>
<p>​                     }</p>
<p>​                     wordCount.put(s, count);</p>
<p>​              }</p>
<p>​              Element root = new Element(“words”);                        Iterator it = wordCount.entrySet().iterator();</p>
<p>​              while(it.hasNext()) {</p>
<p>​                     @SuppressWarnings(“unchecked”)</p>
<p>​                     Map.Entry&lt;String,Integer&gt; me = </p>
<p>​                            (Map.Entry&lt;String,Integer&gt;)it.next();</p>
<p>​                     Element word = new Element(“word”);</p>
<p>​                     word.appendChild(me.getKey() + “: “);</p>
<p>​                     word.appendChild(Integer.toString(me.getValue()));</p>
<p>​                     root.appendChild(word);</p>
<p>​              }             </p>
<p>​              Document doc = new Document(root);</p>
<p>​                           try {        </p>
<p>​                     format(System.out, doc);</p>
<p>​                     format(new BufferedOutputStream(</p>
<p>​                            new FileOutputStream(“WordCount.xml”)), doc); </p>
<p>​              } catch(Exception e) {</p>
<p>​                     System.err.println(e);</p>
<p>​              }</p>
<p>​       }</p>
<p>}</p>
<p>public class PreferencesDemo33 {</p>
<p>​       public static void main(String[] args) throws Exception {         </p>
<p>​              Preferences prefs = Preferences</p>
<p>​                     .userNodeForPackage(PreferencesDemo33.class);</p>
<p>​              int value = prefs.getInt(“base directory”, 0);</p>
<p>​              System.out.print(“Base directory value = “ + value +</p>
<p>​                     “\nEnter new base directory value (integer): “);</p>
<p>​              BufferedReader br = new BufferedReader(</p>
<p>​                     new InputStreamReader(System.in));</p>
<p>​              try {</p>
<p>​                     value = Integer.parseInt(br.readLine());</p>
<p>​                 } catch (Exception e) {</p>
<p>​                     System.err.println(e);</p>
<p>​                     System.exit(1);</p>
<p>​                 }</p>
<p>​              prefs.putInt(“base directory”, value);          </p>
<p>​       }</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">193</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
