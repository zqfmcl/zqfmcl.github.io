<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Fey&#39;s blog">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/page/10/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fey&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/page/10/">





  <title>Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Java对象容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Java对象容器/" itemprop="url">Java对象容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

<ul>
<li><a href="#对象容器">对象容器</a><ul>
<li><a href="#容器类">容器类</a></li>
<li><a href="#对象数组">对象数组</a></li>
<li><a href="#hash表">hash表</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->

<h1 id="对象容器"><a href="#对象容器" class="headerlink" title="对象容器"></a>对象容器</h1><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p>容器类有两个类型：</p>
<ul>
<li>容器的类型</li>
<li>元素的类型</li>
</ul>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><pre><code class="java">String[] a=new String[10];
for (int i=0; i&lt;a.length;i++ ) {
    a[i]=&quot;&quot;+i;
}
System.out.println(a[0].length());//1</code></pre>
<p>对象数组中的每个元素都是对象的管理者而非对象的本身。</p>
<pre><code class="java">for(int k : ia){
    k++;//不会改变原数组，k只是原数组的复制值
}</code></pre>
<pre><code class="java">class Value {
    private int i;
    public void set(int i){
        this.i=i;
    }
    public int get() {
        return i;
    }
}

// ---------------------/
//十个指向Value的管理者
Value [] arr=new Value[10];
for(int i=0;i&lt;arr.length;i++){
    System.out.println(arr[i]);//null *10
    arr[i]=new Value();
    arr[i].set(i);
}
for(Value v:arr){
    System.out.println(v.get());//0~9
    v.set(0);//会改变原始值
}
for(Value v:arr){
    System.out.println(v.get());//0 *10
}</code></pre>
<h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><pre><code class="java">public class Coin{
    private HashMap&lt;Integer, String&gt; coinnames = new HashMap&lt;Integer,String&gt;();
    public Coin(){
        coinnames.put(1, &quot;penny&quot;);
        coinnames.put(10, &quot;dime&quot;);
        coinnames.put(25, &quot;quarter&quot;);
        coinnames.put(50, &quot;half-dolar&quot;);
    }

    public String getName(int amount){
        return coinnames.get(amount);
    }
    public static void main(String[] args){
        Scanner in =new Scanner(System.in);
        int amount = in.nextInt();
        Coin coin =new Coin();
        String name =coin.getName(amount);
        System.out.println(name);
    }
}</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Json/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Json/" itemprop="url">Json</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>在<code>JSON</code>中，一共就这么几种数据类型：</p>
<ul>
<li>number：和JavaScript的<code>number</code>完全一致；</li>
<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>
<li>string：就是JavaScript的<code>string</code>；</li>
<li>null：就是JavaScript的<code>null</code>；</li>
<li>array：就是JavaScript的Array表示方式——<code>[]</code>；</li>
<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><pre><code class="js">JSON.stringify(value [, replacer] [, space])</code></pre>
<pre><code class="js">var xiaoming = {
    name: &#39;小明&#39;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,
    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;]
};

JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;  &#39;);</code></pre>
<p>结果：</p>
<pre><code class="js">{
  &quot;name&quot;: &quot;小明&quot;,
  &quot;skills&quot;: [
    &quot;JavaScript&quot;,
    &quot;Java&quot;,
    &quot;Python&quot;,
    &quot;Lisp&quot;
  ]
}</code></pre>
<p><strong>参数</strong></p>
<p><strong>value</strong>：必需。要转换的 JavaScript 值（通常为对象或数组）。   </p>
<p><strong>replacer</strong>:可选。用于转换结果的函数或数组。</p>
<p><strong>space</strong>：可选，向返回值 JSON 文本添加缩进、空格和换行符以使其更易于读取。   </p>
<p>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</p>
<pre><code class="js">var xiaoming = {
    name: &#39;小明&#39;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,
    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            &#39;Name&#39;: this.name,
            &#39;Age&#39;: this.age
        };
    }
};

JSON.stringify(xiaoming); // &#39;{&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14}&#39;</code></pre>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p>
<pre><code class="js">JSON.parse(&#39;[1,2,3,true]&#39;); // [1, 2, 3, true]
JSON.parse(&#39;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&#39;); // Object {name: &#39;小明&#39;, age: 14}
JSON.parse(&#39;true&#39;); // true
JSON.parse(&#39;123.45&#39;); // 123.45

JSON.parse(&#39;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&#39;, function (key, value) {
    // 把number * 2:
    if (key === &#39;name&#39;) {
        return value + &#39;同学&#39;;
    }
    return value;
}); // Object {name: &#39;小明同学&#39;, age: 14}</code></pre>
<blockquote>
<p>参考资料：</p>
<blockquote>
<p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499490767fe5a0e31e17e44b69dcd1196f7ec6fc6000" target="_blank" rel="noopener">廖学峰</a><br><a href="https://technet.microsoft.com/zh-cn/sysinternals/cc836459" target="_blank" rel="noopener">TechNet</a></p>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Java高频名词/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Java高频名词/" itemprop="url">Java高频名词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java高频词汇</p>
<p>Generators.fill();</p>
<p>File.listFiles();</p>
<p>list.pollLast()</p>
<p>list.peekLast()</p>
<p><strong>FIle.list()</strong>;</p>
<p><strong>Arrays.sort</strong>(list,String.CASE_INSENSITIVE_ORDER);</p>
<p>File file = new File(“.”);   .当前目录    /根目录</p>
<p><strong>Collections.disjoint</strong></p>
<p><strong>pattern.matcher</strong>(name).matches()</p>
<p>Generator<t> gen</t></p>
<p>Generator&lt;Pair&lt;K,V&gt; gen</p>
<p>Iterable<k> genK</k></p>
<p>Entry(int index)</p>
<p>Map.Entry&lt;String,String&gt;</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; set</p>
<p>for(File file:<strong>Directory.local</strong>(“.”,”T.<em>))</em></p>
<p><em>for(File file:*</em>Directory.walk*<em>(“.”,”T.</em>\.java”))</p>
<p>ByteBuffer</p>
<p>FileChannel fc = new FileOutputStream(“data.txt”).<strong>getChannel()</strong>;</p>
<p>fc.write(<strong>ByteBuffer.wrap</strong>(“Some tetx”.getBytes()));</p>
<p>ByteBuffer buffer=<strong>ByteBuffer.allocate</strong>(BSIZE);</p>
<p>while(in.read(buffer)!=-1</p>
<p><strong>buffer.flip()</strong>;</p>
<p>out.write(buffer);</p>
<p><strong>buffer.clear()</strong>;</p>
<p>asCharBuffer()</p>
<p>SotedMap&lt;String,CharSet&gt; <strong>charset.availableCharsets()</strong>;</p>
<p>Iterator<string> it =<strong>charsets.keySet().iterator()</strong>;</string></p>
<p>Iterator aliases =<strong>charsets.get(csName).aliases().iterator()</strong>;</p>
<p><strong>rewind()</strong></p>
<p>ByteBuffer out = new RandomAccessFile(“text.dat”,”rw”).getChannel().<strong>map(FileChannel.MapMode,READ_WRITE,0,length)</strong>;</p>
<p><strong>seek()</strong></p>
<p>DataoutputStream out = </p>
<p>new DataOutputStream(new BufferedOutputStream(new FileOutputStream(“Data.txt”)))</p>
<p>writeUTF()</p>
<p>readUTF()</p>
<p>Scanner</p>
<p>BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));</p>
<p>Iterator<string> it =<strong>charSets.keySet().iterator()</strong>;</string></p>
<p>Document doc = <strong>new Builder().build(fileName)</strong>;</p>
<p>Elements elements = <strong>doc.getRootElement().getChildElements()</strong>;</p>
<p>SystemNodeForPackage()&lt;T extends Enum<t>&gt;getEnumConstants()ExecutorService exec =<strong>Executors.newCachedThreadPool()</strong>;</t></p>
<p>new <strong>SynchronousQueue&lt;</strong>Runnable&gt;()</p>
<p>new DaemonThreadFactory()</p>
<p>FileLock fl = fos.g<strong>etChannel().tryLock()</strong>;</p>
<p><strong>fl.release()</strong>;</p>
<p><strong>SocketChannel</strong></p>
<p>DatagramChannelServerSocketChannel</p>
<p><strong>tryLock(long position,long size,boolean shared)</strong></p>
<p><strong>lock(long position,long size,boolean shared)</strong> </p>
<p>ObjectOutputStream</p>
<p>System.out.println(<strong>file.getAbsolutePath()</strong> + “\n” + <strong>file.isDirectory()</strong>);</p>
<pre><code>list = path.list(new FilenameFilter() {
                private Pattern pattern = Pattern.compile(args[0]);
                public boolean accept(File dir, String name) {
                    return pattern.matcher(name).matches() &amp;&amp;
                    !(Collections.disjoint(
                        Arrays.asList(args).subList(1, args.length),
                        new TextFile(name, &quot;\\W+&quot;)
                    ));
                }
            });</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Leetcode/" itemprop="url">Leetcode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###<strong>思路3——提前停止操作</strong><br>如果当前的数已经&gt;INT_MAX/10 那么再做一次操作，必然溢出。</p>
<pre><code class="c++">class Solution
{
public:
int reverse(int n)
{
int result = 0;
while (n != 0)
{
if (result &gt; INT_MAX / 10
|| ((result == INT_MAX / 10) &amp;&amp; (n % 10 &gt; INT_MAX % 10)))
{
result = 0;
break;
}
if (result &lt; INT_MIN / 10
|| ((result == INT_MIN/ 10) &amp;&amp; (n % 10 &lt; INT_MIN % 10)))
{
result = 0;
break;
}
result = result * 10 + n % 10;
n = n / 10;
}
return result;
}
};
转置数字——解决溢出的思路[E]
69
008. String to Integer (atoi) [E]
[TOC]
题目
Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see
below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You
are responsible to gather all the input requirements up front.
思路
这题也比较好做，关键是要考虑挺多东西，我也是提交了好多次才发现有这么多要考虑的地
方。
开头的空格
正负符号的处理
溢出处理
非法输入
开头空格处理：
while(str[i] == &quot; &quot;) i++;
正负号的处理：我觉得yuruofeifei这个解决方案简直赞
if (str[i] == &#39;-&#39; || str[i] == &#39;+&#39;) {
sign = 1 - 2 * (str[i++] == &#39;-&#39;);
}
……
return base * sign;
溢出处理（可以参考上一道题）：
atoi——培养严谨的思路，正负号的处理技巧[E]
70
if (base &gt; INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - &#39;0&#39; &gt; INT_MAX%10)) {
if (sign == 1) return INT_MAX;
else return INT_MIN;
}
非法输入：其实只用过滤就行了
while (str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;) {
……
}
代码
我的代码，不够简洁，可以参考yuruofeifei的代码，在下面
class Solution {
public:
int myAtoi(string str) {
long tmp=0;
bool neg;
int i = 0;
while(str[i] == &#39; &#39;) i++; //读掉空格
neg = str[i] == &#39;-&#39;?1:0;
for(i = i+ (neg || str[i] == &#39;+&#39;);i &lt; str.length();i++) //如果是- 或 + i+1跳过
符号
{
if(str[i] - &#39;0&#39; &gt;= 0 &amp;&amp; str[i] - &#39;0&#39; &lt; 10) //过滤非法输入
{
tmp *= 10;
tmp += (str[i] - &#39;0&#39;);
if(tmp &gt;= INT_MAX &amp;&amp; !neg) //溢出判断
{
tmp = INT_MAX;
break;
}
if(tmp -1 &gt;= INT_MAX &amp;&amp; neg) //除了符号，INT_MAX和INT_MIN只差1
{
tmp = INT_MIN;
break;
}
}
else break;
}
if(neg) return -tmp;
return tmp;
}
};
atoi——培养严谨的思路，正负号的处理技巧[E]
71
yuruofeifei的代码
int myAtoi(string str) {
int sign = 1, base = 0, i = 0;
while (str[i] == &#39; &#39;) { i++; }
if (str[i] == &#39;-&#39; || str[i] == &#39;+&#39;) {
sign = 1 - 2 * (str[i++] == &#39;-&#39;);
}
while (str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;) {
if (base &gt; INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - &#39;0&#39; &gt; 7)) {
if (sign == 1) return INT_MAX;
else return INT_MIN;
}
base = 10 * base + (str[i++] - &#39;0&#39;);
}
return base * sign;
}
atoi——培养严谨的思路，正负号的处理技巧[E]
72
009. Palindrome Number[E]
问题：
Determine whether an integer is a palindrome. Do this without extra space.
思路
这里说不用额外的空间意思是不用O(n)的空间，O(1)的还是可以用的，不然循环都不好
写。。
思路1
简单的思路 就是把数字逆转，然后判断逆转后的数字跟原来数字是不是一样的。
class Solution {
public:
bool isPalindrome(int x) {
if(x &lt; 0) return false;
int r=0,t;
t = x;
while(t != 0)
{
r =r*10 + t%10;
t /=10;
}
return r == x;
}
};
思路2
但是其实，不用把数字逆转完再判断，因为如果是回文数字，那么只要逆转一半看是否满足
回文条件就行了。
设新数为r，原来数为x，每次：
回文数字巧解[E]
73
x = x/10，r = r*10 + x%10;
如何到一半停止？
如果x &lt;= r时可以停止了（至少到了一半）
如果是偶数长度，并且是回文，那么刚好可以到x == r
如果为奇数长度，并且是回文，那么x &lt; r，这时候r刚好比x多一位数
停止后判断是否是回文
如果是偶数长度，很简单判断 r == x
如果是奇数长度，要判断 r/10 == x
注意：这里有一些小问题。
当尾数为0的情况。尾数为0会导致r的增长少1位数（因为0*10 = 0）。 比如110不是回
文，最后停止r = 1 x =1 但是 r == x
当数字小于0的时候，也是不满足回文的条件的。
class Solution {
public:
bool isPalindrome(int x) {
if(x &lt; 0 || (x != 0 &amp;&amp; x %10 ==0)) return false;
int r = 0;
while(x &gt; r)
{
r =r*10 + x%10;
x /=10;
}
return (r == x) || (r/10 == x);
}
};
回文数字巧解[E]
74
029. Divide Two Integers[M]
问题
Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT.
思路
这道题难在不能使用乘除取余操作，所以我们只能手动的实现除法，我们来看看如何实现。
我们假设被除数为 D ，除数为 d
手动实现除法
首先，本能想到10 = 2*5 ，10/2 = 5，说明10中有5个2，这里可以用循环来做，看 D 中间有
多少个 d 就行了。
本能写出一个循环应该不难。
for(i = 0;dividend - divisor &gt;= 0 ;i+=1)
{
dividend = dividend - divisor;
}
符号
现在有另一个问题，正负数怎么办？我们知道，除法里，异号为负，同号为正，既然不能使
用乘除判断，那我们就只能写个判断，这个flag到时候就充当标志。
boolean flag = (dividend &gt; 0 &amp;&amp; divisor &lt; 0 || dividend &lt; 0 &amp;&amp; divisor &gt; 0);
当然还有更好的实现方式，既然不能用乘除，可以用位运算呀，这和异或操作的含义刚好一
样。
位运算实现除法[M]
75
boolean sign = ((dividend &lt; 0) ^ (divisor &lt; 0));
然后，把 D 和 d 同时取绝对值就好了。
long did = Math.abs((long)dividend);
long dis = Math.abs((long)divisor);
注意：这里除数一定要用long，因为如果最小值取绝对值会溢出
溢出
我们知道，除法可能产生溢出的情况就是 D 为0，或者 D 为 最小值 ， d 为-1
if (!divisor || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1))
return Integer.MAX_VALUE;
更快的方案
好了，我们可以测试下代码。发现超时，想想也是，上面的循环太慢了。其实我们稍微想一
下就可以提速，我们可以采用逐渐逼近的思路：
我们先看i = N个 d 可不可以
如果可以，我们看看i = 2N个 d 可以不可以
如果还可以就继续看i = 4N个 d 可以不可以
直到不可以减，我们让 D 减去i个 d
这里为什么使用2的倍数，因为可以用位运算呀~~
d &lt;&lt; 1 就相当与d*2
d &lt;&lt; 2 就相当与d*4
我们再用一个i来就记数 i = 0 开始
1 &lt;&lt; 0 就相当于1
1 &lt;&lt; 1 就相当于2
1 &lt;&lt; 2 就相当与4
这里我们用一个临时变量 mul_d 存 d 的左移操作，注意： mul_d 必须为long，因为左移操作
很可能溢出！！
位运算实现除法[M]
76
现在我们可以写出以下代码了。
public class Solution {
public int divide(int dividend, int divisor) {
if(divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1))
return Integer.MAX_VALUE;
int i,total = 0;
//判断正负号
boolean sign = ((dividend &lt; 0) ^ (divisor &lt; 0));
//这里必须要long,因为如果最小值取绝对值会溢出
long did = Math.abs((long)dividend);
long dis = Math.abs((long)divisor);
while(did &gt;= dis)
{
long mul_dis = dis;
i = 0;
//每次左移乘2，记录下来，直到不能减
while(did &gt;= (mul_dis&lt;&lt;1))
{
i++;
mul_dis &lt;&lt;= 1;
}
did -= mul_dis;
total += 1&lt;&lt;i;
}
//根据符号返回
return sign?-total:total;
}
}
位运算实现除法[M]
77
006.ZigZag Conversion[E]
题目
The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like
this: (you may want to display this pattern in a fixed font for better legibility)
And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and
make this conversion given a number of rows:
string convert(string text, int nRows);
convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;.
思路1——用字符串数组
我能说我一开始完全没看懂吗？我是根据Custom Testcase自己慢慢测试摸索出来的。 其
实，应该是这样的 2行： A C E B D F
3行： A E I B D F H J C G _ K
所以有个简单的思路：
每行弄个string。
对原始字符串进行扫描，从上往下，从下往上，依次加入每行的string
最后把所有的string拼接起来
ZigZag解码[E]
78
class Solution {
public:
string convert(string s, int numRows) {
string str[numRows],tmp;
if(numRows == 1)
return s;
int flag;
for(int i = 0,j = 0;i &lt; s.length(); i++)
{
if(j == 0)
flag = 1;
if(j == numRows-1)
flag = -1;
str[j] += s[i];
j += flag;
}
for(int i = 0; i &lt; numRows;i++){
tmp += str[i];
}
return tmp;
}
};
思路2——观察规律
2行： A C E B D F
3行：
A E I B D F H J C G _ K
4行：
A G B F H C E I K D _ J
观察规律后，以每行的元素作为轴，可以发现，下面的字母都是对称排列的 换成对应的index
后，规律更明显
0 4 8 1 3 5 7 9 2 6 _ 10
第2层的元素就是以第一行的元素为轴，+1,-1 第三层的元素就是以第一行的元素为轴，+2,-2
…… 但是最后一层的元素，由于其特殊性，我们可以只考虑+k
Ps.所有过界的元素都不考虑
轴也有规律：除了首尾两层，其他都是2个，所以第一层每隔2n-2出现一次。
ZigZag解码[E]
79
class Solution {
public:
string convert(string s, int numRows)
{
string tmp;
if(numRows == 1)
return s;
int inc = 2*numRows-2; //每次轴增加的步长
int len = s.length();
for(int i = 0; i &lt; numRows;i++)
{
for(int j = 0;j &lt; s.length()+numRows; j += inc)
{
if(j - i &gt; 0 &amp;&amp; j - i &lt; s.length()
&amp;&amp; i != 0 &amp;&amp; i != numRows -1) //首，尾只考虑+不考虑-
tmp+= s[j-i];
if(j + i &lt; s.length())
tmp += s[j+i];
}
}
return tmp;
}
};
ZigZag解码[E]
80
292. Nim Game[E]
题目
You are playing the following Nim Game with your friend: There is a heap of stones on the
table, each time one of you take turns to remove 1 to 3 stones. The one who removes the
last stone will be the winner. You will take the first turn to remove the stones.
Both of you are very clever and have optimal strategies for the game. Write a function to
determine whether you can win the game given the number of stones in the heap.
For example, if there are 4 stones in the heap, then you will never win the game: no matter
1, 2, or 3 stones you remove, the last stone will always be removed by your friend.
分析
1. 只要能被4整除，你就输了。因为不论你怎么拿，对方都会凑到4。
2. 如果不能被4整除，那你第一次把余数拿了，然后你模仿上面的策略，你就赢了。
代码
return bool(n%4)
Nim的游戏[E]
81
012. Integer to Roman[M]
问题
Given an integer, convert it to a roman numeral.
Input is guaranteed to be within the range from 1 to 3999.
思路
分析罗马数字的规律：
Symbol Value
I 1
V 5
X 10
L 50
C 100
D 500
M 1,000
上面是罗马数字所有的符号。 罗马数字的规则： 一般情况下，从左到右从大到小排，字母代
表的数字累加。 比如：
XII = 12
MDCCLXVI= 1000+500+100+100+50+10+5+1
但是有特殊情况，就是，如果数字的范围在大数减小数的范围内，则会出现小数在大数前面
的情况，代表（大数-小数）
IV = 5-1 IX= 10 - 1 = 9 XL = 50-10 = 40
拉丁数字转罗马数字[M]
82
Symbol Value
IV 4
IX 9
XL 40
XC 90
CD 400
CM 900
思路1——循环
一旦把所有可能的情况符号情况都列举出来了，就好做了。 我们现在拿到一个数N
1. 我们就去表里面找不超过它的最大的数x，
2. 然后把它入我们的输出字符串中，然后将数N-=x，
3. 继续执行这个操作，直到N=0
public class Solution {
public String intToRoman(int num) {
int list[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
String chars[] = {&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
int i = 0;
String out=&quot;&quot;;
while(num &gt; 0)
{
for(;i &lt; list.length;i++)
if(num &gt;= list[i])
break;
out+=chars[i];
num -= list[i];
}
return out;
}
}
思路2——查表
还有个更极端的方案，就是，把每位上可能出现的情况都列举出来，剩下的，只用查表就行
了。
拉丁数字转罗马数字[M]
83
public class Solution {
public static String intToRoman(int num) {
String M[] = {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};
String C[] = {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};
String X[] = {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
String I[] = {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
}
}
拉丁数字转罗马数字[M]
84
013. Roman to Integer
问题
Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
Subscribe to see which companies asked this question
思路
首先要知道罗马数字的规律：
Symbol Value
I 1
V 5
X 10
L 50
C 100
D 500
M 1,000
然后还有一个规则是，罗马数字从左自右相加，但是如果小数字A在大数字B之前，表示B-A
VI = 5+1 = 6 IV = 5-1 = 4
因此，利用2个变量保存当前数字和之前的数字就行了。因为这题很简单，用python比较方
便，我就用python做的
罗马数字转拉丁数字[E]
85
class Solution(object):
def romanToInt(self, s):
sum=0
pre = 2000
cur = 0
Map = {&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000}
for i in range(len(s)):
cur = Map[s[i]]
sum = sum+Map[s[i]]
if cur &gt; pre :
sum = sum-2*pre
pre = cur
return sum
罗马数字转拉丁数字[E]
86
题目
Given a set of distinct integers, nums, return all possible subsets.
Note: The solution set must not contain duplicate subsets.
For example, If nums = [1,2,3], a solution is:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
思路
1. 利用bitmap
这是一个非常巧妙的思路，因为对于子集来说，每个元素只有2种状态：在子集中，不在子集
中
这刚好符合2进制，可以考虑使用bitmap的方法。
我们对每个元素一个bit：
0：在当前子集中
1：不在当前子集中
对于n个元素，一共有2^n种取法，这和子集数也是一致的。
拿2个元素{1,2}举例：
00 ——&gt; [] //1不取，2不取
01 ——&gt; [1] //取1
10 ——&gt; [2] //取2
11 ——&gt; [1,2] //取1，2
求子集[M]
87
刚好可以取尽所有元素。
这个算法的复杂度是O(N^2)，一层循环从0到2^n种取法，二层循环看每个取法对应的2进制中
的1的个数
代码
public class Solution {
public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
List&lt;List&lt;Integer&gt;&gt; mylist = new ArrayList&lt;List&lt;Integer&gt;&gt;();
int len = 1&lt;&lt;nums.length;
//System.out.println(len);
for(int i = 0;i &lt; len;i++)
{
List&lt;Integer&gt; tmplist = new ArrayList&lt;Integer&gt;();
for(int j = 0;j &lt; nums.length;j++)
{
if(((1&lt;&lt;j) &amp; i) != 0)
{
tmplist.add(nums[j]);
}
}
mylist.add(tmplist);
}
return mylist;
}
}
递归，回溯
求子集[M]
88
用回溯法，因为是子集，[1,2]和[2,1]一样，所以我们的每次递归的停止条件都是到nums[]中的
最后一个元素。
代码
public class Solution {
public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
List&lt;List&lt;Integer&gt;&gt; mylist = new ArrayList&lt;List&lt;Integer&gt;&gt;();
getsubset(mylist,0,nums,new ArrayList&lt;Integer&gt;());
return mylist;
}
private void getsubset(List&lt;List&lt;Integer&gt;&gt; mylist, int cur, int[] nums, List&lt;I
nteger&gt; tmplist){
mylist.add(tmplist);
for(;cur &lt; nums.length;cur++) {
List&lt;Integer&gt; newlist = new ArrayList&lt;Integer&gt;(tmplist);
newlist.add(nums[cur]);
getsubset(mylist, cur + 1,nums,newlist);
}
}
}
求子集[M]
89
004. Median of Two Sorted Arrays[H]
题目
There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the
median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
分析
这个题目是非常的常见，而且有特别多的变形。特别是在当前大数据的环境下，如何快速查
找第i个元素有很现实的意义。
关注D&amp;C方法的，直接看思路2
思路1
很简单的思路：就是遍历两个数组，在里面找到第i个大元素，这个应该还是比较简单的，时
间复杂度O(m+n)。
用2个变量分别指向两个数组，每次取较小的一个，然后将其指针后移动。但是这里有个问
题，就是奇偶判断，如果是奇数，中位数是num[mid]，但是如果是偶数，是
(num[mid]+num[mid-1])/2。这里我的做法是把num[mid]看作(num[mid]+num[mid])/2。如果是
偶数-1,奇数-0。
*两个有序数组中的中位数和Top K问题[H]
90
class Solution {
public:
double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
if(nums1.size() == 0)
return MedofArray(nums2);
if(nums2.size() == 0)
return MedofArray(nums1);
vector&lt;int&gt; num3;
int size = (nums1.size()+nums2.size());
int mid = size/2;
int flag = !(size%2);
int i,m1,m2,cur;
double a,b;
for(i = m1 = m2 = 0;i &lt; size;i++)
{
a = m1 &lt; nums1.size()?nums1[m1]:INT_MAX;//过界处理
b = m2 &lt; nums2.size()?nums2[m2]:INT_MAX;//过界处理
//cout&lt;&lt;i&lt;&lt;&quot; a &quot;&lt;&lt;a&lt;&lt;&quot; b &quot;&lt;&lt;b&lt;&lt;endl;
if(a &lt; b)
{
num3.push_back(nums1[m1]);
m1++;
}
else
{
num3.push_back(nums2[m2]);
m2++;
}
if(i == mid)
break;
}
return (num3[mid]+num3[mid-flag])/2.0;
}
double MedofArray(vector&lt;int&gt;&amp; nums)
{
int mid = nums.size()/2;
int flag = !(nums.size()%2);
return (nums[mid]+nums[mid-flag])/2.0;
}
};
思路2
重点来了!!
这是一个很经典的Divide &amp; Conquer的题目，关键就在如何划分。这里引用stellari 的高分答
案，觉得他这个讲的特别好：
*两个有序数组中的中位数和Top K问题[H]
91
预备知识
先解释下“割”
我们通过切一刀，能够把有序数组分成左右两个部分，切的那一刀就被称为割(Cut)，割
的左右会有两个元素，分别是左边最大值和右边最小值。
我们定义L = Max(LeftPart)，R = Min(RightPart)
Ps. 割可以割在两个数中间，也可以割在1个数上，如果割在一个数上，那么这个数即属于左
边，也属于右边。（后面讲单数组中值问题的时候会说）
比如说[2 3 5 7]这个序列，割就在3和5之间
[2 3 / 5 7]
中值就是（3+5）/2 = 4
如果[2 3 4 5 6]这个序列，割在4上，我们可以把4分成2个
[2 3 (4/4) 5 7]
中值就是（4+4）/2 = 4
这样可以保证不管中值是1个数还是2个数都能统一运算。
割和第k个元素
对于单数组，找其中的第k个元素特别好做，我们用割的思想就是：
常识1：如果在k的位置割一下，然后A[k]就是L。换言之，就是如果左侧有k个元素，A[k]
属于左边部分的最大值。（都是明显的事情，这个不用解释吧！）
双数组
*两个有序数组中的中位数和Top K问题[H]
92
我们设: C 为第i个数组的割。 L 为第i个数组割后的左元素. R 为第i个数组割后的右元素。
我们看如何从双数组里取出第k个元素
1. 首先L &lt;= R 是肯定的（因为数组有序，左边肯定小于右边）
2. 如果我们让L &lt;= R &amp;&amp; L &lt;= R
3. 那么左半边 全小于右半边，如果左边的元素个数相加刚好等于k，那么第k个元素就是
Max(L1,L2)，参考上面常识1。
4. 如果 L1&gt;R2，说明数组1的左边元素太大（多），我们把C1减小，把C2增大。L2&gt;R1同
理，把C1增大，C2减小。
假设k=3
对于
[1 4 7 9]
i i i
i i
1 2 2 1
*两个有序数组中的中位数和Top K问题[H]
93
[2 3 5]
设C1 = 2，那么C2 = k-C1 = 1
[1 4/7 9]
[2/3 5]
这时候，L1(4)&gt;R2(3)，说明C1要减小，C2要增大，C1 = 1，C2=k-C1 = 2
[1/4 7 9]
[2 3/5]
这时候，满足了L &lt;= R &amp;&amp; L &lt;= R ，第3个元素就是Max(1,3) = 3。
如果对于上面的例子，把k改成4就恰好是中值。
下面具体来看特殊情况的中值问题。
双数组的奇偶
中值的关键在于，如何处理奇偶性，单数组的情况，我们已经讨论过了，那双数组的奇偶问
题怎么办，m+n为奇偶处理方案都不同，
让数组恒为奇数
有没有办法让两个数组长度相加一定为奇数或偶数呢？
其实有的，虚拟加入‘#&#39;(这个trick在manacher算法中也有应用)，让数组长度恒为奇数（2n+1
恒为奇数）。
Ps.注意是虚拟加，其实根本没这一步，因为通过下面的转换，我们可以保证虚拟加后每个元
素跟原来的元素一一对应
映射关系
这有什么好处呢，为什么这么加?因为这么加完之后，每个位置可以通过/2得到原来元素的位
置。
1 2 2 1
*两个有序数组中的中位数和Top K问题[H]
94
在虚拟数组里表示“割”
不仅如此，割更容易，如果割在‘#&#39;上等于割在2个元素之间，割在数字上等于把数字划到2个
部分。
奇妙的是不管哪种情况：
Li = (Ci-1)/2
Ri = Ci/2
例：
1. 割在4/7之间‘#&#39;，C = 4，L=(4-1)/2=1 ，R=4/2=2 刚好是4和7的原来位置！
2. 割在3上，C = 3，L=(3-1)/2=1，R=3/2 =1，刚好都是3的位置！
剩下的事情就好办了，把2个数组看做一个虚拟的数组A，目前有2m+2n+2个元素，割在
m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。(在数组中是
[m+n]和[m+n+1])
左边：A[m+n] = Max(L1+L2)
右边：A[m+n+1] = Min(R1+R2)
Mid = (A[m+n]+A[m+n+1])/2 = (Max(L1+L2) + Min(R1+R2) )/2
至于在两个数组里找割的方案，就是上面的方案。
分治的思路
有了上面的知识后，现在的问题就是如何利用分治的思想。
怎么分？
最快的分的方案是二分，有2个数组，我们对哪个做二分呢？ 根据之前的分析，我们知道了，
只要C1或C2确定，另外一个也就确定了。这里，为了效率，我们肯定是选长度较短的做二
分，假设为C1。
怎么治？
*两个有序数组中的中位数和Top K问题[H]
95
也比较简单，我们之前分析了：就是比较L1,L2和R1,R2。
L1&gt;R2，把C1减小，C2增大。—&gt; C1向左二分
L2&gt;R1，把C1增大，C2减小。—&gt; C1向右二分
越界问题
如果C1或C2已经到头了怎么办？ 这种情况出现在：如果有个数组完全小于或大于中值。可能
有4种情况：
C1 = 0 —— 数组1整体都比中值大，L1 &gt;R2，中值在2中
C2 = 0 —— 数组1整体都比中值小，L1 &lt;R2，中值在1中
C1 = n*2 —— 数组1整体都比中值小，L1 &lt;R2，中位数在2中
C2 = m*2 —— 数组1整体都比中值大，L1 &gt;R2，中位数在1中
其实，如果我已经确定了数组1是最短的数组，那只有两种情况了，比较好处理：
如果C1 = 0 —&gt; 那么我们缩小L1，L1 = INT_MIN，保证判断正确。
如果C1 = n*2 —&gt; 那么我们增大R1，R1 = INT_MAX，保证判断正确。
代码
*两个有序数组中的中位数和Top K问题[H]
96
class Solution {
public:
double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
if(nums1.size() == 0)
return MedofArray(nums2);
if(nums2.size() == 0)
return MedofArray(nums1);
int n = nums1.size();
int m = nums2.size();
if(n &gt; m) //保证数组1一定最短
return findMedianSortedArrays(nums2,nums1);
int L1,L2,R1,R2,c1,c2,lo = 0, hi = 2*n; //我们目前是虚拟加了&#39;#&#39;所以数组1是2*n+1长度
while(lo &lt;= hi) //二分
{
c1 = (lo+hi)/2; //c1是二分的结果
c2 = m+n- c1;
L1 = (c1 == 0)?INT_MIN:nums1[(c1-1)/2]; //map to original element
R1 = (c1 == 2*n)?INT_MAX:nums1[c1/2];
L2 = (c2 == 0)?INT_MIN:nums2[(c2-1)/2];
R2 = (c2 == 2*m)?INT_MAX:nums2[c2/2];
if(L1 &gt; R2)
hi = c1-1;
else if(L2 &gt; R1)
lo = c1+1;
else
break;
}
return (max(L1,L2)+ min(R1,R2))/2.0;
}
double MedofArray(vector&lt;int&gt;&amp; nums)
{
if(nums.size() == 0) return -1;
return (nums[nums.size()/2]+nums[(nums.size()-1)/2])/2.0;
}
};
*两个有序数组中的中位数和Top K问题[H]
97
010. Regular Expression Matching
@(leetcode解题思路)[DP]
问题
Implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.
&#39;.&#39; Matches any single character. &#39;*&#39; Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).
The function prototype should be: bool isMatch(const char s, const char p)
Some examples: isMatch(&quot;aa&quot;,&quot;a&quot;) → false isMatch(&quot;aa&quot;,&quot;aa&quot;) → true
isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false isMatch(&quot;aa&quot;, &quot;a&quot;) → true isMatch(&quot;aa&quot;, &quot;.&quot;) → true
isMatch(&quot;ab&quot;, &quot;.&quot;) → true isMatch(&quot;aab&quot;, &quot;ca*b&quot;) → true
思路
这里面最复杂的操作是&quot;*&quot;，这是个很可恶的操作，因为你永远不知道它多长。但是有一
点，&quot;*&quot;不会单独出现，它一定是和前面一个字母或&quot;.&quot;配成一对。看成一对后&quot;X*&quot;，它的性质就
是：要不匹配0个，要不匹配连续的“X”
题目的关键就是如何把这一对放到适合的位置。
考虑一个特殊的问题： 情况1： “aaaaaaaaaaaaaaaa&quot;
&quot;aaa&quot;
情况2： “aaaaaaaaaaaaaaaa&quot;
&quot;aab&quot;
在不知道后面的情况的时候，我如何匹配a*？
最长匹配 显然不合适，这样后面的a就无法匹配上了
匹配到和后面长度一样的位置，比如情况1，就是留3个a不匹配，让后面3个字母尝试去
匹配。 这样看似合适，但是遇到情况2就不行了。
回溯，每种&quot;*&quot;的情况我都匹配一次，看哪种情况能成功，如果其中出现了问题，马上回
溯，换下一种情况
*正则匹配问题[H]
98
思路1——回溯
如果“*”不好判断，那我大不了就来个暴力的算法，把“”的所有可能性都测试一遍看是否有满足
的，用两个指针i,j来表明当前s和p的字符。 我们采用从后往前匹配，为什么这么匹配，因为
如果我们从前往后匹配，每个字符我们都得判断是否后面跟着“”，而且还要考虑越界的问题。
但是从后往前没这个问题，一旦遇到“*”，前面必然有个字符。&lt;/font&gt;
如果j遇到&quot;*&quot;，我们判断s[i] 和 p[j-1]是否相同，
如果相同我们可以先尝试匹配掉s的这个字符，i--，然后看之后能不能满足条件，满
足条件，太棒了！我们就结束了，如果中间出现了一个不满足的情况，马上回溯到
不匹配这个字符的状态。
不管相同不相同，都不匹配s的这个字符，j-=2 (跳过“*”前面的字符)
if(p[j-1] == &#39;.&#39; || p[j-1] == s[i])
if(myMatch(s,i-1,p,j))
return true;
return myMatch(s,i,p,j-2);
如果j遇到的不是“*”，那么我们就直接看s[i]和p[j]是否相等，不相等就说明错了，返回。
if(p[j] == &#39;.&#39; || p[j] == s[i])
return myMatch(s,i-1,p,j-1);
else return false;
再考虑退出的情况
如果j已经&lt;0了说明p已经匹配完了，这时候，如果s匹配完了，说明正确，如果s没匹
配完，说明错误。
如果i已经&lt;0了说明s已经匹配完，这时候，s可以没匹配完，只要它还有&quot;*&quot;存在，我
们继续执行代码。
所以代码应该是这样的：
*正则匹配问题[H]
99
class Solution {
public:
static const int FRONT=-1;
bool isMatch(string s, string p) {
return myMatch(s,s.length()-1,p,p.length()-1);
}
bool myMatch(string s, int i, string p,int j)
{
if(j == FRONT)
if(i == FRONT) return true;
else return false;
if(p[j] == &#39;*&#39;)
{
if(i &gt; FRONT &amp;&amp; (p[j-1] == &#39;.&#39; || p[j-1] == s[i]))
if(myMatch(s,i-1,p,j))
return true;
return myMatch(s,i,p,j-2);
}
if(p[j] == &#39;.&#39; || p[j] == s[i])
return myMatch(s,i-1,p,j-1);
return false;
}
};
思路2——DP
DP的话，肯定要用空间换时间了，这里用 monkeyGoCrazy 的思路：用2维布尔数组，dp[i][j]
的含义是s[0-i] 与 s[0-j]是否匹配。
1. p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]
2. If p.charAt(j) == &#39;.&#39; : dp[i][j] = dp[i-1][j-1];
3. If p.charAt(j) == &#39;*&#39;: here are two sub conditions:
- if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a*
only counts as empty
- if p.charAt(j-1) == s.charAt(i) or p.charAt(i-1) == &#39;.&#39;:
dp[i][j] = dp[i-1][j] //in this case, a* counts as multip
le a
dp[i][j] = dp[i][j-1] // in this case, a* counts as single
a
dp[i][j] = dp[i][j-2] // in this case, a* counts as empty
这里用的bool数组比较巧妙，初始化为true。前两种情况好理解，如果匹配成功就维持之前的
真假值。程序的目的是看真值能不能传递下去。如果遇到三种情况，我们就看哪种情况有真
值可以传递，就继续传递下去。
*正则匹配问题[H]
100
初始化
dp[0][0] = true;
//初始化第0行,除了[0][0]全为false，毋庸置疑，因为空串p只能匹配空串，其他都无能匹配
for (int i = 1; i &lt;= m; i++)
dp[i][0] = false;
//初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号）
for (int j = 1; j &lt;= n; j++)
dp[0][j] = j &gt; 1 &amp;&amp; &#39;*&#39; == p[j - 1] &amp;&amp; dp[0][j - 2];
图示
我用excel自己跑了下代码，画了一下示意图，下面橘黄色表示正常匹配了，蓝色表示“*”匹配
空串。可以看出真值是如何传递下去的。
例1：&quot;aaa&quot; 和 正则式&quot;aa&quot;
例2：&quot;aabc&quot; 和 正则式&quot;a*bc&quot;
*正则匹配问题[H]
101
例3：&quot;aaaa&quot; 和 正则式&quot;a*b*&quot;
*正则匹配问题[H]
102
代码执行
for(int i = 1;i &lt;= n;i++)
{
for(int j = 1;j &lt;= m;j++)
{
//这里j-1才是正常字符串中的字符位置
//要不*当空，要不就只有当前字符匹配了*之前的字符，才有资格传递dp[i-1][j]真值
if(p[j-1] == &#39;*&#39;)
dp[i][j] = dp[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == &#39;.&#39;) &amp;&amp; dp[i-1][j]
;
else
//只有当前字符完全匹配，才有资格传递dp[i-1][j-1] 真值
dp[i][j] = (p[j-1] == &#39;.&#39; || s[i-1] == p[j-1]) &amp;&amp; dp[i-1][j-1];
}
}
返回值
return dp[n][m]
完整代码
*正则匹配问题[H]
103
class Solution
{
public:
static const int FRONT=-1;
bool isMatch(string s, string p)
{
int m = s.length(),n = p.length();
bool dp[m+1][n+1];
dp[0][0] = true;
//初始化第0行,除了[0][0]全为false，毋庸置疑，因为空串p只能匹配空串，其他都无能匹配
for (int i = 1; i &lt;= m; i++)
dp[i][0] = false;
//初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号）
for (int j = 1; j &lt;= n; j++)
dp[0][j] = j &gt; 1 &amp;&amp; &#39;*&#39; == p[j - 1] &amp;&amp; dp[0][j - 2];
for (int i = 1; i &lt;= m; i++)
{
for (int j = 1; j &lt;= n; j++)
{
//由于表格中是从1开始的，而字符串中是以0开始的，所以i-1和j-1才对应字符串中的字符。
if (p[j - 1] == &#39;*&#39;)
{
dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;
) &amp;&amp; dp[i - 1][j];
}
else //只有当前字符完全匹配，才有资格传递dp[i-1][j-1] 真值
{
dp[i][j] = (p[j - 1] == &#39;.&#39; || s[i - 1] == p[j - 1]) &amp;&amp; dp[i - 1][
j - 1];
}
}
}
return dp[m][n];
}
};
*正则匹配问题[H]
104
120. Triangle[M]
题目
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to
adjacent numbers on the row below.
For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path
sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total
number of rows in the triangle.
思路
如图分析： $d(0,1) = Path[0,1] + min(d(1,1)，d(1,2))$&lt;/br&gt; $d(1,1) = Path[1,1] +
min(d(2,1),d(2,2))$&lt;/br&gt; $d(1,2) = Path[1,2] + min(d(2,2),d(2,3))$&lt;/br&gt; $……$&lt;/br&gt; $d(3,1)
= 4$&lt;/br&gt; $d(3,2) = 1$&lt;/br&gt; $d(3,3) = 8$&lt;/br&gt; $d(3,4) = 3$&lt;/br&gt; 我们从底层往上走，每走一
层，都是到这一层的最短路径距离。所以，我们每次只用保存到这一层每个元素的最短路径
距离即可。也就是说，对于n层，我们最多只需要n个额外空间。
最底层: $[4,1,8,3]$&lt;/br&gt;
向上走:$[6+1,5+1,7+3] = [7,6,10]$&lt;/br&gt;
继续:$[3+6,4+6] = [9,10]$&lt;/br&gt;
最后:$[2+9] = [11]$&lt;/br&gt;
代码
三角形问题[M]
105
class Solution {
public:
int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
vector &lt;int&gt; min_path(triangle.back());
for(int i = triangle.size()-2;i&gt;=0; i--)
{
for(int j = 0;j &lt; triangle[i].size();j++)
{
min_path[j] = min(min_path[j],min_path[j+1]) + triangle[i][j];
}
}
return min_path[0];
}
};
三角形问题[M]
106
338. Counting Bits [M]
题目
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num
calculate the number of 1&#39;s in their binary representation and return them as an array.
Example: For num = 5 you should return [0,1,1,2,1,2].
Follow up:
1. It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you
do it in linear time O(n) /possibly in a single pass
2. Space complexity should be O(n).
3. Can you do it like a boss? Do it without using any builtin function like __builtin_popcount
in c++ or in any other language.
思路
这是一个比较简单的动规题目，就是统计二进制数的1个个数，通过观察可以发现二进制数有
很多规律在里面
十进制二进制
1 1
2 10
3 11
4 100
8 1000
9 10001
可以看见，当二进制位数多1位的时候，高位为1，剩下的和之前的是一样的。
计算二进制数中1的个数[M]
107
list[i] = list[i%n]+1 //n = floor(log(i))
list[2] = list[2%2]+1
list[5] = list[5%4]+1
list[12] =list[12%8]+1
代码
class Solution {
public:
vector&lt;int&gt; countBits(int num) {
vector&lt;int&gt; ones(num+1,0);
int base = 1;
for(int i = 1; i &lt;= num; i++)
{
if(i &lt; base * 2)
ones[i] = ones[i%base]+1;
else{
base *= 2;
ones[i] = ones[i%base]+1;
}
}
return ones;
}
};
更巧妙的代码
最高分代码：f[i] = f[i/2] + i%2
思想：和我的差不多，我是不看最高位，这个巧妙巧妙在不看最低位，直接右移1位，这个数
在数组中肯定已经存在了，然后加上移走那位是0还是1（i%2 或者 i &amp; 1）
其实整体思想都是把新的二进制模式映射到之前出现的二进制模式上去。
public int[] countBits(int num) {
int[] f = new int[num + 1];
for (int i=1; i&lt;=num; i++) f[i] = f[i &gt;&gt; 1] + (i &amp; 1);
return f;
}
计算二进制数中1的个数[M]
108
计算二进制数中1的个数[M]
109
22. Generate Parentheses[M]
问题
Given n pairs of parentheses, write a function to generate all combinations of well-formed
parentheses.
For example, given n = 3, a solution set is:
&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;
思路1——DP
设：P[i]表示当n=i的时候括号组合串。 观察规律：我们知道，要形成一个括号的组合，肯定
不是凭空产生的，产生一个P[3]的组合，那肯定是把&quot;(&quot;和&quot;)&quot;分别插在P[2]中间的。
我们假设产生P[3]组合的时候，之前的组合都是正确的，那么通过插入&quot;(&quot;，&quot;)&quot;肯定会把P[2]分
成两个部分（括号内一个，括号外一个）
看似好像有很多插入的方法，但是，其实仔细想想，反正&quot;(&quot;得增加一个，由于括号组合的第
一一定是&quot;(&quot;，为什么不把新增的&quot;(&quot;放在开头呢？这样我们就只用考虑&quot;)&quot;了
会怎么把P[2]切割就好了，我们知道P[2]的组合有P[0]+P[2]，P[1]+P[1]，P[2]+P[0]，
*括号匹配问题[M]
110
通过写出前几个可以观察到下面的规律 P[0]= [&quot;&quot;] P[1] = [()] = &quot;(&quot;+P[0]+&quot;)&quot;+P[0] P[2] = [()(),(())]
= &quot;(&quot;+P[0]+&quot;)&quot;+P[1] , &quot;(&quot;+P[1]+&quot;)&quot; +P[0] P[3] = [()()(),()(()),(())(),(()()),((()))] = &quot;(&quot;+P[0]+&quot;)&quot;+P[2] ,
&quot;(&quot;+P[1]+&quot;)&quot;+P[1], &quot;(&quot;+P[2]+&quot;)&quot; +P[0]
我们可以知道了组合方式：
P[i] = &quot;(&quot;+P[i-j-1]+&quot;)&quot;+P[j] ($j \in [0,n-1]$)
*括号匹配问题[M]
111
public class Solution {
public List&lt;String&gt; generateParenthesis(int n) {
List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;();
//初始化P[0] = &quot;&quot;
result.add((List&lt;String&gt;)Arrays.asList(new String []{&quot;&quot;}));
for(int i=1;i &lt;= n;i++)
{
result.add(new ArrayList&lt;&gt;());
for(int j = 0; j &lt; i;j++)
{
//获取P[k]
for (String s1 : result.get(j)) {
//获取P[i-j-1]
for(String s2 : result.get(i-j-1))
{
result.get(i).add(&quot;(&quot; + s1 + &quot;)&quot; + s2);
}
}
}
}
return result.get(n);
}
}
思路2：回溯
假设我能枚举所有的情况，我们考虑合理的括号组合是什么样的：
1. 左括号数==右括号数
2. 左括号一定要先于右括号
所以我们可以用一个大数组来表示字符串，2个指针left，right来表示左右括号，我们递归遍历
所有情况，把满足条件的情况加入list就行了。
*括号匹配问题[M]
112
public class Solution {
public List&lt;String&gt; generateParenthesis(int n) {
LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;();
if(n== 0) return result;
backtracing(result,0,0,&quot;&quot;,n);
return result;
}
void backtracing(LinkedList&lt;String&gt; result, int left, int right, String par, int m
ax)
{
if(par.length() == 2*max)
{
result.add(par);
return;
}
if(left &lt; max)
backtracing(result,left+1,right,par+&#39;(&#39;,max);
if(right &lt; left)
backtracing(result,left,right+1,par+&#39;)&#39;,max);
}
}
*括号匹配问题[M]
113
064. Minimum Path Sum[M]
题目
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom
right which minimizes the sum of all numbers along its path. Note: You can only move
either down or right at any point in time.
思路
DP
这应该是很容易想到的，因为每次只能往下或右走，所以对于每个格，就两种可能：
从上面走下来
从左边走过来 那么很容易写出表达式：dp(i,j) = min(dp(i-1,j) , dp(i,j-1)) + path(i,j) 然后要
做一个处理，就是对于第0行，和第0列只能从左边或上面走。这样判断很麻烦，其实有
一个很简单的办法： 增加一行和一列，让这一行和这一列都为一个很大的值，这样，不
管是第0行还是0列，都可以用统一的算法。 （这里有个小注意点，就是我对minpath[0]
[1]赋值为0，这是为了更改原来minpath[0][0]位置的值）
最短路径和[M]
114
public class Solution {
public int minPathSum(int[][] grid) {
int m = grid.length;
if(0 == m)
return 0;
int n = grid[0].length;
int [][] minpath = new int[m+1][n+1];
//init 0th row and 0th column to Max
for(int i = 0;i &lt;= m;i ++)
minpath[i][0] = Integer.MAX_VALUE;
for(int j = 0;j &lt;= n;j ++)
minpath[0][j] = Integer.MAX_VALUE;
minpath[0][1] = 0;
for(int i = 1;i &lt;= m;i ++)
for(int j = 1;j &lt;= n;j++)
minpath[i][j] = Math.min(minpath[i-1][j],minpath[i][j-1]) + grid
[i-1][j-1];
return minpath[m][n];
}
}
　一维数组
当然，上面的算法还可以改进，就是把二维数组换成一维数组，因为我们实际运行的时候发
现，我们每次计算只和当前行的grid和之前行的minpath有关。 这个一维数组一直会更新，而
更新条件就是 : dp[j] = min(dp(j),dp(j-1)) + grid(i,j) 这里同样为了避免第0列出问题（j-1越
界），加入了1格，实际j从1开始
最短路径和[M]
115
public class Solution {
public int minPathSum(int[][] grid) {
int m = grid.length;
if(0 == m)
return 0;
int n = grid[0].length;
int [] minpath = new int[n+1];
for(int i = 0;i &lt;= n;i ++)
minpath[i] = Integer.MAX_VALUE;
minpath[1] = 0;
for(int i = 0;i &lt; m;i ++)
for(int j = 1;j &lt;= n;j++)
minpath[j] = Math.min(minpath[j-1],minpath[j]) + grid[i][j-1];
return minpath[n];
}
}
最短路径和[M]
116
014. Longest Common Prefix[E]
问题
Write a function to find the longest common prefix string amongst an array of strings.
Subscribe to see which companies asked this question
思路
这个没啥思路的，怎么都要两重循环，因为是最长公共子串，随便找一个(一般是第一个作为
基准)，然后拿拿的首部慢慢去匹配后面的字符串就行了。
public class Solution {
public String longestCommonPrefix(String[] strs) {
String s = &quot;&quot;;
if(strs.length == 0)
return &quot;&quot;;
for(int i = 0; i &lt; strs[0].length();i++)
{
char c = strs[0].charAt(i);
for(int j = 1;j &lt; strs.length;j++)
{
if(i &gt;= strs[j].length() || strs[j].charAt(i) != c)
return s;
}
s += c;
}
return s;
}
}
014. Longest Common Prefix[E]
117
20. Valid Parentheses
问题
Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string
is valid.
The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are
not.
思路
这道题很简单，就是一个经典的栈的例子——表达式中的括号符号匹配。
遇见了左括号就进栈
遇见了右括号就出栈
如果栈为空，出错
如果出栈元素不是匹配的括号，出错
这里解决出括号匹配用了一个小tick，就是利用ASCII码，匹配的括号的ascii码都不会相差太
远
&#39;(&#39; &#39;)&#39; 相差1
&#39;[&#39; &#39;]&#39; &#39;{&#39; &#39;}&#39; 相差2
020. Valid Parentheses[E]
118
public class Solution {
public boolean isValid(String s) {
if(s.length() == 0)
return false;
Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // 创建堆栈对象
for(int i = 0;i &lt; s.length(); i++)
{
if(s.charAt(i) == &#39;(&#39; || s.charAt(i) == &#39;[&#39; || s.charAt(i) == &#39;{&#39;)
stack.push(s.charAt(i));
if(s.charAt(i) == &#39;)&#39; || s.charAt(i) == &#39;]&#39; || s.charAt(i) == &#39;}&#39;)
{
if(stack.empty()) return false;
char out = stack.pop();
if(out - s.charAt(i) &gt; 2)
return false;
}
}
if(stack.empty())
return true;
return false;
}
}
020. Valid Parentheses[E]
119</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Longest-Common-Prefix[E]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Longest-Common-Prefix[E]/" itemprop="url">Longest Common Prefix[E]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Longest Common Prefix[E]</li>
</ol>
<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>Subscribe to see which companies asked this question</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个没啥思路的，怎么都要两重循环，因为是最长公共子串，随便找一个(一般是第一个作为基准)，然后拿拿的首部慢慢去匹配后面的字符串就行了。</p>
<pre><code class="java">public class Solution {
    public String longestCommonPrefix(String[] strs) {
        String s = &quot;&quot;;
        if(strs.length == 0)
            return &quot;&quot;;
        for(int i = 0; i &lt; strs[0].length();i++)
        {
            char c = strs[0].charAt(i);
            for(int j = 1;j &lt; strs.length;j++)
            {
                if(i &gt;= strs[j].length() || strs[j].charAt(i) != c)
                    return s;
            }
            s += c;
        }
        return s;
    }
}</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Letter-Combinations-of-a-Phone-Number[M]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Letter-Combinations-of-a-Phone-Number[M]/" itemprop="url">Letter Combinations of a Phone Number[M]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Letter Combinations of a Phone Number[M]</li>
</ol>
<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br><img src="C:/Users/Administrator/Desktop/leetbook-master/%E6%95%B0%E7%BB%84/017.%20Letter%20Combinations%20of%20a%20Phone%20Number%5BM%5D/1461570562032.png" alt="Alt text"></p>
<blockquote>
<p>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这题其实含义是是枚举所有可能的组合方式。如果题目要求是枚举“23”的所有可能字母组合，我们很好做，2重循环对吧？但是现在难就难在，一开始你不知道输入是什么，你没办法确定组合长度，组合个数，也没办法确定循环层数，这时候怎么办？？？</p>
<p>这里有两个思路，也是很常用的思路：递归，队列。</p>
<h1 id="思路1：递归"><a href="#思路1：递归" class="headerlink" title="思路1：递归"></a>思路1：递归</h1><p>递归一般是解决一些整体不好求的问题。它通过把大问题划小，然后找到一种特定的规律，然后求解。</p>
<p>递归的思路我们很好理解，我们没办法确定整体，我可以先从入手。</p>
<p>假定有个数字串“23456”</p>
<ul>
<li>假定除了数字’2’的组合已经求出来了，准备求’3’，那我只要把‘3’所代表的’def’加到之前字符串他们每一个的后面就好。</li>
<li>假定除了数字’2’的组合已经求出来了，准备求’4’，那我只要把‘4’所代表的’hij’加到之前字符串他们每一个的后面就好。<br>……</li>
<li>一直这样推下去，直到发现6’后面是空的了，那将当前这个字符串加入列表就好了。</li>
</ul>
<pre><code class="java">     public class Solution {
        private char[][] dict = { {},{ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; }, { &#39;d&#39;, &#39;e&#39;, &#39;f&#39; }, { &#39;g&#39;, &#39;h&#39;, &#39;i&#39; }, { &#39;j&#39;, &#39;k&#39;, &#39;l&#39; }, { &#39;m&#39;, &#39;n&#39;, &#39;o&#39; },
                { &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39; }, { &#39;t&#39;, &#39;u&#39;, &#39;v&#39; }, { &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39; } };
        public List&lt;String&gt; letterCombinations(String digits) {
            LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;();
            if(digits.length() == 0)
                return result;
            addNumber(result,0,&quot;&quot;,digits);
            return result;
        }
        public void addNumber(List&lt;String&gt; list, int i, String curstr, String digits) 
        {
            if (i == digits.length()) {
                list.add(curstr);
                return;
            }
            char[] candidates = dict[digits.charAt(i) - &#39;1&#39;];
            for (char c : candidates)
                addNumber(list, i+1, curstr + c, digits);
        }
    }</code></pre>
<h1 id="思路2：用队列"><a href="#思路2：用队列" class="headerlink" title="思路2：用队列"></a>思路2：用队列</h1><p>队列的思路也不算太难理解。如果递归算纵向求解的话，队列就是横向求解。每加入一个新的数字的时候，就把当前队列的元素全都扩充一遍。使得队列不仅在长度上，也在宽度上增加了。这就像一个装配流水线。半成品每流过一个工人，工人就把之前的产品拿出来，往上安装一个零件，然后放到传送带上，让它继续传到下个工人那。</p>
<ol>
<li>一共需要的工人数，就是数字串长度，它决定了产品需要经过几道加工</li>
</ol>
<pre><code> for(int i = 0;i &lt; digits.length(); i++)
 {
 }</code></pre><ol>
<li>然后我们看目前有多少个不同的半成品需要加工</li>
</ol>
<pre><code> int pos = digits.charAt(i) - &#39;0&#39;;
 int size = result.size();
 for(int j = 0;j &lt; size;j++)
 {
 }</code></pre><ol>
<li>然后就开始加工了，我们获取每个数字对应的字符串长度，这就是工人需要加工的零件个数。这里加工是把每个半成品拿出来，复制多份，然后按上新的零件</li>
</ol>
<pre><code>  String tmp = result.remove();
  for(int k = 0;k &lt; map[pos].length();k++)
        result.add(tmp+map[pos].charAt(k));</code></pre><h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><pre><code class="java">public class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;();
        if(digits.length() == 0)
            return result;
        String[] map = new String[] {&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
        result.add(&quot;&quot;);
        for(int i = 0;i &lt; digits.length(); i++)
        {
            int pos = digits.charAt(i) - &#39;0&#39;;
            String s = map[pos];
            int size = result.size();
            for(int j = 0;j &lt; size;j++)
            {
                String tmp = result.poll();
                for(int k = 0;k &lt; s.length();k++)
                    result.add(tmp+s.charAt(k));
            }
        }
        return result;
    }
}</code></pre>
<p>这里，我用了size变量来存之前加工好的半成品个数（因为队列会在加工后扩充，size会变化），</p>
<pre><code>int size = result.size();
for(int j = 0;j &lt; size;j++)</code></pre><p>但是，高分答案中有个思路，我觉得很赞。（要是想不到这个，就用我上面的写就好了，多一行代码而已）</p>
<pre><code>while(ans.peek().length()==i)</code></pre><p>这里ans.peek().length()是取出第一个元素的长度，当长度等于i的时候，说明是当前需要加工的半成品，而加工完后，队列中的每个元素长度都会增加1，所以，这时候循环就会停止。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">190</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
