<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Fey&#39;s blog">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/page/23/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fey&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/page/23/">





  <title>Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-堆排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-堆排序/" itemprop="url">堆排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><hr>
<blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“<a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第4版）</a>”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。</p>
<p><strong>通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解。</strong></p>
</blockquote>
<h2 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h2><p>堆排序的思想很简单，就是利用了堆的优点，不断的找最大值，然后删除最大值，重复操作。</p>
<ul>
<li>首先，要构造一个二叉堆出来，我们采用自底向上的思想。</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-01-084744.jpg" alt></p>
<ul>
<li>做删除root的操作（但是不是真删除，只是把root元素放到最后了）</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-01-084752.jpg" alt></p>
<ul>
<li>循环直到数组有序。</li>
</ul>
<p>我们可以发现加入的代码非常少！！</p>
<h2 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h2><pre><code class="java">public class Heap
{
   public static void sort(Comparable[] a)
   {
      int N = a.length;
      for (int k = N/2; k &gt;= 1; k--)
         sink(a, k, N);
      while (N &gt; 1)
      {
         exch(a, 1, N);
         sink(a, 1, --N);
      }
   }
   private static void sink(Comparable[] a, int k, int N)
   {  
/* as before */
  }
   private static boolean less(Comparable[] a, int i, int j)
   {  
/* as before */
  }
   private static void exch(Comparable[] a, int i, int j)
   {  
/* as before */
  }
}</code></pre>
<p><strong>注意:</strong> 我们之前操作堆都是从1开始的，但是排序的时候，需要排序的元素是从0开始的，我们需要在交换的时候，做一些变化（减1）。</p>
<h2 id="堆排序的性能"><a href="#堆排序的性能" class="headerlink" title="堆排序的性能"></a>堆排序的性能</h2><blockquote>
<p>堆排序是我们目前接触的<strong>第一个</strong> <code>in-place</code> 的并且时间复杂度为NlogN的算法（快排最坏情况下会有$N^2$的复杂度）</p>
</blockquote>
<p><img src="http://img.hksite.cn/2019-03-01-084805.jpg" alt></p>
<p>但是它有一些缺点，导致实际用的不多：</p>
<ul>
<li>内部循环代码过多（多次比较）</li>
<li>很少能用到cache，因为它的比较是跳跃的，用不到附近的元素。（快排是跟附近的元素比较）</li>
<li>不稳定</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-字符编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-字符编码/" itemprop="url">字符编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- toc orderedList:0 -->

<ul>
<li><a href="#字符编码">字符编码</a><ul>
<li><a href="#ascii码">ASCII码</a></li>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#utf-8-utf-16-utf-32">UTF-8 UTF-16 UTF-32</a><ul>
<li><a href="#unicode与utf-8之间的转换">Unicode与UTF-8之间的转换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>计算机内所有信息会转化成二进制(<code>bit</code>)，有<code>0</code>和<code>1</code>两种状态。</p>
<p><strong>ASCII码</strong> 是美国定制的字符编码规范，有256个符号，从<code>0000000</code>到<code>11111111</code>。</p>
<p>但第一位默认为<code>0</code>，共128个字符。所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<blockquote>
<p>ascii码中，A的二进制编码为01000001，如果用十进制表示是65，用十六进制表示就是41H。</p>
<blockquote>
<p><a href="http://www.cnblogs.com/xmxu/archive/2012/07/10/2584032.html" target="_blank" rel="noopener">ASCII码表查询</a><br><a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
</blockquote>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p><code>Unicode</code>码包括世界上所有的符号，每个符号都有独立的编码。</p>
<p>每个字符编码都不一样，，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字”<code>严</code>“。</p>
<h2 id="UTF-8-UTF-16-UTF-32"><a href="#UTF-8-UTF-16-UTF-32" class="headerlink" title="UTF-8 UTF-16 UTF-32"></a>UTF-8 UTF-16 UTF-32</h2><p>三个编码方式所需的字节长度：</p>
<table>
<thead>
<tr>
<th>UTF-8</th>
<th>UTF-16</th>
<th>UTF-32</th>
</tr>
</thead>
<tbody><tr>
<td>1~4个字节</td>
<td>2个或4个字节</td>
<td>4个字节</td>
</tr>
</tbody></table>
<p>UTF-8编码规则：</p>
<ol>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的<code>unicode</code>码。因此对于英语字母，<code>UTF-8</code>编码和<code>ASCII</code>码是相同的。</li>
<li>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的<code>unicode</code>码。</li>
</ol>
<table>
<thead>
<tr>
<th>Unicode符号范围</th>
<th>UTF-8编码方式</th>
</tr>
</thead>
<tbody><tr>
<td>(十六进制)</td>
<td>（二进制）</td>
</tr>
<tr>
<td>0000 0000 - 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 - 0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 - 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 - 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<blockquote>
<p>字母x表示可用编码的位。</p>
</blockquote>
<p>跟据上表，解读<code>UTF-8</code>编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<h3 id="Unicode与UTF-8之间的转换"><a href="#Unicode与UTF-8之间的转换" class="headerlink" title="Unicode与UTF-8之间的转换"></a>Unicode与UTF-8之间的转换</h3><p>从上表可知，<code>严</code>的Unicode码为<code>4E25</code>(<code>100111000100101</code>)，从上表可知道位于第三行范围内，因此UTF-8编码格式为<code>&quot;1110xxxx 10xxxxxx 10xxxxxx&quot;</code>，然后<code>严</code>从最后一个二进制开始，依次填入格式中的<code>x</code>，多出补<code>0</code>，最后结果是<code>E4B8A5</code>。</p>
<blockquote>
<p><a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字编码查询</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">资料参考</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-排序洗牌/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-排序洗牌/" itemprop="url">排序洗牌</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“<a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第4版）</a>”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。</p>
<p><strong>通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解。</strong></p>
</blockquote>
<h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><blockquote>
<p>洗牌的思想很简单，就是像洗扑克牌一样，对一组数据进行随机打乱，这个算法在很多应用里都非常有用，特别是对于后面需要介绍的快排来说，这个算法直接影响了快排的效率。</p>
</blockquote>
<p>洗牌的算法这里提了2种 </p>
<h2 id="排序洗牌"><a href="#排序洗牌" class="headerlink" title="排序洗牌"></a>排序洗牌</h2><ul>
<li>思想很简单，先对<strong>每个元素生成一个随机数，然后对这些随机数进行排序</strong></li>
</ul>
<p>排序前</p>
<p><img src="http://img.hksite.cn/2019-03-02-032420.png" alt></p>
<p>排序后</p>
<p><img src="http://img.hksite.cn/2019-03-02-032432.png" alt></p>
<h2 id="Knuth洗牌"><a href="#Knuth洗牌" class="headerlink" title="Knuth洗牌"></a>Knuth洗牌</h2><ul>
<li>一个更简单的算法，不用sort，每次产生一个[0,i]的随机数r，然后交换a[i]和a[r]，这个是个线性时间算法。</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-01-20160406233330434.gif" alt></p>
<h3 id="Knuth洗牌代码"><a href="#Knuth洗牌代码" class="headerlink" title="Knuth洗牌代码"></a>Knuth洗牌代码</h3><pre><code class="java">public class StdRandom
{
   ...
   public static void shuffle(Object[] a)
   {
      int N = a.length;
      for (int i = 0; i &lt; N; i++)
      {
         int r = StdRandom.uniform(i + 1);  //&lt;&lt;--[0,i]
         exch(a, i, r);
      }
   }
}</code></pre>
<p><strong>注：</strong>洗牌的最佳算法是用硬件随机数生成器</p>
<p><strong>基本观点：</strong>洗一副牌是复杂的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-归并排序介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-归并排序介绍/" itemprop="url">归并排序介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“算法（第4版）”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。<br>通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解。</p>
</blockquote>
<h1 id="1-归并排序介绍"><a href="#1-归并排序介绍" class="headerlink" title="1.归并排序介绍"></a>1.归并排序介绍</h1><h2 id="1介绍"><a href="#1介绍" class="headerlink" title="1介绍"></a>1介绍</h2><p><img src="http://img.hksite.cn/1473422339157" alt></p>
<h3 id="1-2归并排序步骤："><a href="#1-2归并排序步骤：" class="headerlink" title="1.2归并排序步骤："></a>1.2归并排序步骤：</h3><blockquote>
<p>它的思想就是简单的分治（D&amp;C）。</p>
</blockquote>
<ul>
<li>Divide : 分（把数组成2部分）</li>
<li>循环分（直到不能分）</li>
<li>Conquer : 治（合并，将每2个部分合到一起）</li>
</ul>
<p>分很简单，其中最关键的部分就是如何合并(Merge)，这也是这个算法的来历。<br>分两种情况讨论： 1. 当数组元素为1的时候，很简单，小的放前，大的放后。 2. 当数组元素大与2的时候，我们可以用一个新的数组和2个指针快速解决这个问题：</p>
<ul>
<li>复制到新数组，指针i,j分别指向2个部分的开头</li>
</ul>
<p><img src="http://img.hksite.cn/1473422352881" alt></p>
<ul>
<li>如果aux[i] &lt; aux[j] 则把aux[i]的元素放到a[k]，然后i 和 k向后移动，反之同理，直到遍历完所有元素。</li>
</ul>
<p><img src="http://img.hksite.cn/1473422366674" alt></p>
<p>可以发现，每次Merge的时间复杂度是O(n)，加上一共合并log2N次，可以说是非常不错。</p>
<h2 id="1-3-归并排序代码"><a href="#1-3-归并排序代码" class="headerlink" title="1.3 归并排序代码"></a>1.3 归并排序代码</h2><pre><code class="java">private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi)
{
   assert isSorted(a, lo, mid);    // precondition: a[lo..mid]   sorted
   assert isSorted(a, mid+1, hi);  // precondition: a[mid+1..hi] sorted
   for (int k = lo; k &lt;= hi; k++)
      aux[k] = a[k];
   int i = lo, j = mid+1;
   for (int k = lo; k &lt;= hi; k++) 
   {
      if (i &gt; mid)              
          a[k] = aux[j++];
      else if (j &gt; hi)               
          a[k] = aux[i++];
      else if (less(aux[j], aux[i])) 
          a[k] = aux[j++];
      else                           
          a[k] = aux[i++];
   }
   assert isSorted(a, lo, hi);     
// postcondition: a[lo..hi] sorted
}</code></pre>
<p>上面3处assert的好处是： </p>
<ul>
<li>帮助发现逻辑上的错误 </li>
<li>可以说明代码是做什么用的</li>
</ul>
<p><img src="http://img.hksite.cn/1473422732796" alt></p>
<pre><code class="java">public class Merge
{
   private static void merge(...)
   {  
/* as before */
  }
   private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi)
   {
      if (hi &lt;= lo) return;
      int mid = lo + (hi - lo) / 2;
      sort(a, aux, lo, mid);
      sort(a, aux, mid+1, hi);
      merge(a, aux, lo, mid, hi);
   }
   public static void sort(Comparable[] a)
   {
      aux = new Comparable[a.length];
      sort(a, aux, 0, a.length - 1);
   }
}</code></pre>
<p>注意： </p>
<ol>
<li>上面两处sort，一个是提供对外的接口，一个是对内的递归调用使用的。 </li>
<li>在对外接口中创建aux数组，而不要在内部调用的sort中创建aux数组，否则会出现bug。</li>
</ol>
<h2 id="1-4-实际运行步骤："><a href="#1-4-实际运行步骤：" class="headerlink" title="1.4 实际运行步骤："></a>1.4 实际运行步骤：</h2><p><img src="http://img.hksite.cn/1473422724077" alt></p>
<h2 id="1-5-算法性能："><a href="#1-5-算法性能：" class="headerlink" title="1.5 算法性能："></a>1.5 算法性能：</h2><h3 id="1-5-1-比较次数和数组访问次数"><a href="#1-5-1-比较次数和数组访问次数" class="headerlink" title="1.5.1 比较次数和数组访问次数"></a>1.5.1 比较次数和数组访问次数</h3><p><img src="http://img.hksite.cn/1473422696570" alt></p>
<h3 id="1-5-2-运行时间"><a href="#1-5-2-运行时间" class="headerlink" title="1.5.2 运行时间"></a>1.5.2 运行时间</h3><p><img src="http://img.hksite.cn/1473422690905" alt></p>
<h3 id="1-5-3-内存占用"><a href="#1-5-3-内存占用" class="headerlink" title="1.5.3 内存占用"></a>1.5.3 内存占用</h3><p><img src="http://img.hksite.cn/1473422656837" alt></p>
<h2 id="1-6-改进"><a href="#1-6-改进" class="headerlink" title="1.6 改进"></a>1.6 改进</h2><blockquote>
<p>归并排序的速度很快，唯一的不足就是内存占用很大（目前有可以不用额外空间的归并排序，这里不涉及）特别是小子串的开销很大，有一些改进的方案，可以减少对内存的占用。</p>
</blockquote>
<h3 id="1-6-1-对小子串使用插入排序-可以提升20-左右-：（设定一个Cutoff，-一般是7个元素）"><a href="#1-6-1-对小子串使用插入排序-可以提升20-左右-：（设定一个Cutoff，-一般是7个元素）" class="headerlink" title="1.6.1 对小子串使用插入排序 (可以提升20%左右) ：（设定一个Cutoff， 一般是7个元素）"></a>1.6.1 对小子串使用插入排序 (可以提升20%左右) ：（设定一个Cutoff， 一般是7个元素）</h3><pre><code class="java">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi)
{
   if (hi &lt;= lo + CUTOFF - 1)
   {
      Insertion.sort(a, lo, hi);
      return;
   }
   int mid = lo + (hi - lo) / 2;
   sort (a, aux, lo, mid);
   sort (a, aux, mid+1, hi);
   merge(a, aux, lo, mid, hi);
}</code></pre>
<h3 id="1-6-2-对已经排序好的2个子串直接跳过Merge阶段。（对部分有序的数组有用）"><a href="#1-6-2-对已经排序好的2个子串直接跳过Merge阶段。（对部分有序的数组有用）" class="headerlink" title="1.6.2 对已经排序好的2个子串直接跳过Merge阶段。（对部分有序的数组有用）"></a>1.6.2 对已经排序好的2个子串直接跳过Merge阶段。（对部分有序的数组有用）</h3><p><img src="http://img.hksite.cn/1473422648359" alt></p>
<h3 id="1-6-3-不用全复制（节约时间但是不节约空间）"><a href="#1-6-3-不用全复制（节约时间但是不节约空间）" class="headerlink" title="1.6.3 不用全复制（节约时间但是不节约空间）"></a>1.6.3 不用全复制（节约时间但是不节约空间）</h3><p>把aux和a的位置交换，每次只用在Merge的时候从一个数组移动到另一个数组就行了，减少了复制的过程。</p>
<p><img src="http://img.hksite.cn/1473422642285" alt></p>
<h1 id="2-非递归的merge-sort"><a href="#2-非递归的merge-sort" class="headerlink" title="2.非递归的merge sort"></a>2.非递归的merge sort</h1><p>之前讲的mergesort是一个递归版本，这个是一个非递归的版本。 思想也很简单，就是依次对每隔1,2,4,8的子串进行merge。 比如： 第一次是[0]+[1][2]+[3][3]+[4] …… 第二次是[0-1] + [2-3] …… 第三次是[0-3] + [4-7] …… 直到排序完毕</p>
<p><img src="http://img.hksite.cn/1473422632623" alt></p>
<h1 id="3-Comparator接口"><a href="#3-Comparator接口" class="headerlink" title="3.Comparator接口"></a>3.Comparator接口</h1><blockquote>
<p>如果你需要对一个对象的多个键值进行排序（比如一首歌的歌名，作者，日期等），可以考虑用Comparator。</p>
</blockquote>
<p>在class中间，可以申明几个Comparator接口，并实现比较函数</p>
<p><img src="http://img.hksite.cn/1473422614628" alt></p>
<p>然后在使用的时候，改sort函数，把Comparator作为一个参数传入（注意要更改之前的数组的变量类型为object）</p>
<p><img src="http://img.hksite.cn/1473422606287" alt></p>
<p>使用的时候，加入比较参数就行了</p>
<p><img src="http://img.hksite.cn/1473422596525" alt></p>
<h1 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h1><blockquote>
<p>一个排序算法还有一个衡量指标就是，它是否是稳定的，稳定的如何衡量呢？就是对于有同样排序等级的元素B1B2，原本B1在前面的，结果排序后它到后面去了变成B2B1了。这就是不稳定的。在现实生活中，这个性质还是很重要的。</p>
</blockquote>
<p>比如，我们已经按名字排好序的一个名单，我们按第二项排序，我们期望的是第二项相同的情况下，名字在前面的依然在前面，结果，发现并不是这样，这就是不稳定排序。</p>
<p><img src="http://img.hksite.cn/1473422439850" alt></p>
<p>很容易知道，我们之前学的算法，插入排序是稳定的，因为它每当比较到一个相同的元素时，就停止了，不会继续比较了。</p>
<p><img src="http://img.hksite.cn/1473422429621" alt></p>
<p>插入排序是不稳定的，因为涉及到长距离的交换</p>
<p><img src="http://img.hksite.cn/1473422423610" alt></p>
<p>同理，希尔排序也是不稳定的</p>
<p><img src="http://img.hksite.cn/1473422412476" alt></p>
<p>归并排序是稳定的，因为我们在编程的时候可以规定。</p>
<p><img src="http://img.hksite.cn/1473422407058" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-快速排序介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-快速排序介绍/" itemprop="url">快速排序介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“算法（第4版）”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。<br>通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解</p>
</blockquote>
<h1 id="1-快速排序介绍"><a href="#1-快速排序介绍" class="headerlink" title="1.快速排序介绍"></a>1.快速排序介绍</h1><blockquote>
<p>快速排序是20世纪Top10算法之一。足以看出它的重要性。并且它不需要额外的空间，这是它比MergeSort厉害的地方。</p>
</blockquote>
<h2 id="1-1-基本步骤"><a href="#1-1-基本步骤" class="headerlink" title="1.1 基本步骤"></a>1.1 基本步骤</h2><ul>
<li>随机对数组进行洗牌操作（重要，直接影响性能），参考<a href="./sort3.md">洗牌算法</a></li>
<li>对数组进行分组，保证对于元素a[i]<ul>
<li>a[i]左边的元素全都小于a[i]</li>
<li>a[i]右边的元素全都大于a[i]</li>
</ul>
</li>
<li>对子数组循环操作，只到完全有序</li>
</ul>
<p><img src="http://img.hksite.cn/1473832416418" alt></p>
<h2 id="2-1-划分操作"><a href="#2-1-划分操作" class="headerlink" title="2.1 划分操作"></a>2.1 划分操作</h2><ul>
<li>i从左到右扫描直到发现一个a[i] &gt; a[lo]</li>
<li>j从右到左扫描，直到发现一个a[j] &lt; a[lo]</li>
<li>然后交换a[i]和a[j]</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-02-044031.png" alt="image-20190302124030890"></p>
<ul>
<li>直到i和j交叉</li>
<li>交换a[lo]和a[j]</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-02-044056.png" alt></p>
<pre><code class="java">private static int partition(Comparable[] a, int lo, int hi)
{
    int i = lo, j = hi;
    while(true)
    {
        while(less(a[++i],a[lo]) &amp;&amp; i &lt; hi)
            if(i == hi)    break;
        while(less(a[lo],a[--j]))
            if(j == lo)    break;  //可以省略
        if(i &gt; j)
            break;
        exch(a,i,j);
    }
    exch(a,lo,j);
    return j;
}</code></pre>
<p>注意这里的代码看上去很简单，但是实际上很多trick</p>
<ul>
<li>第一是在if(j == lo)那里 判断可以<code>省略</code>，因为a[lo]不可能小于本身</li>
<li>第二个是把循环的退出条件写在循环内部</li>
</ul>
<p>下面是我一开始写的代码。这里明显有一个问题，就是当j &lt; i之后，这里应该立马退出循环，不然exch发生后，就出bug了。</p>
<pre><code class="java">while(i &lt; j)
{
        while(less(a[i],a[lo]) &amp;&amp; i &lt; hi)
            i++;
        while(less(a[lo],a[j]))  //这里不用做边界判断因为a[lo]不会小于本身
            j--;
        exch(a[i],a[j]);
  }</code></pre>
<p>然后是完整的快排算法：</p>
<pre><code class="java">public class Quick
{
  private static int partition(Comparable[] a, int lo, int hi)
  {
/* see previous slide */
  }
  public static void sort(Comparable[] a)
  {
      StdRandom.shuffle(a);  //Important
      sort(a, 0, a.length - 1);
  }
  private static void sort(Comparable[] a, int lo, int hi)
  {
      if (hi &lt;= lo) return;
      int j = partition(a, lo, hi);
      sort(a, lo, j-1);
      sort(a, j+1, hi);
  }
}</code></pre>
<p><strong>注意：</strong>算法开始的随机<strong><code>洗牌</code></strong>是非常重要的，可以保证算法性能最佳（很多算法书中都没提这一点）</p>
<h2 id="1-3-快排性能分析"><a href="#1-3-快排性能分析" class="headerlink" title="1.3 快排性能分析"></a>1.3 快排性能分析</h2><ul>
<li>平均比较次数 CN=(N+1)+(C0+CN−1N)+(C1+CN−2N)+…+(CN−1+C0N)</li>
</ul>
<p>其中N2<br>表示划分概率，C0=C1=0</p>
<p>(下面的计算大家看看就行了，不用推……)</p>
<p><img src="http://img.hksite.cn/1473832729166" alt></p>
<p><img src="http://img.hksite.cn/1473832736541" alt></p>
<p>计算得出来CN=1.39NlgN</p>
<p>实际是比MergeSort的平均比较次数多39%的，但是，快排依然快于Mergesort，因为他很多时候都是比较，但是Mergesort每一次比较都移动了元素，浪费了时间。</p>
<p><strong>注意：快排的代码很容易写错，而且目前很多工具书或者网上的代码都是O(N2)</strong>的性能：</p>
<ul>
<li><p>当数组有序或逆序的时候（没随机洗牌）</p>
</li>
<li><p>如果有很多重复键的时候（即使很随机）</p>
<p><img src="http://img.hksite.cn/1473832795729" alt></p>
</li>
</ul>
<h2 id="1-4-快排的特性"><a href="#1-4-快排的特性" class="headerlink" title="1.4 快排的特性"></a>1.4 快排的特性</h2><ul>
<li>快排是就地排序算法(没有额外空间费用)</li>
<li>快排是<strong><em>不稳定</em></strong>算法</li>
</ul>
<h2 id="1-5-快排改进"><a href="#1-5-快排改进" class="headerlink" title="1.5 快排改进"></a>1.5 快排改进</h2><h3 id="1-5-1-用插入排序提高在小数组中排序性能"><a href="#1-5-1-用插入排序提高在小数组中排序性能" class="headerlink" title="1.5.1 用插入排序提高在小数组中排序性能"></a>1.5.1 用插入排序提高在小数组中排序性能</h3><p>即使是快排，在小数组的时候，开销也是很大的，依然可以用MergeSort中的改进方案，在小数组的时候，采用InsertionSort来提高排序速度。通常取10个元素</p>
<p><img src="http://img.hksite.cn/1473832864733" alt></p>
<h3 id="1-5-2-选择支点（pivot）"><a href="#1-5-2-选择支点（pivot）" class="headerlink" title="1.5.2 选择支点（pivot）"></a>1.5.2 选择支点（pivot）</h3><p>通常pivot我们选的是数组的第一个元素，但是理论上最好的piovt是刚好中间的元素，这样可以将数组二分（但是实际上对与大数据量来说，不值得在这里开销），所以一般采用 Median-of-3</p>
<p><img src="http://img.hksite.cn/1473832875231" alt></p>
<h1 id="2-快速选择算法"><a href="#2-快速选择算法" class="headerlink" title="2 快速选择算法"></a>2 快速选择算法</h1><blockquote>
<p>快速选择算法的目标就是给定一组数，找其中大的元素，这个在实际生活中运用广泛，比如</p>
</blockquote>
<h2 id="2-1首先可以估计下这个算法的大致性能"><a href="#2-1首先可以估计下这个算法的大致性能" class="headerlink" title="2.1首先可以估计下这个算法的大致性能"></a>2.1首先可以估计下这个算法的大致性能</h2><ul>
<li>性能上界：NlgN，这个很容易想到，只要排序好，取第几个元素都是简单的</li>
<li>性能下界：N 至少要循环一遍</li>
</ul>
<p>所以问题就在于能不能找到一个算法是线性时间的。</p>
<h2 id="2-2-快速选择算法"><a href="#2-2-快速选择算法" class="headerlink" title="2.2 快速选择算法"></a>2.2 快速选择算法</h2><blockquote>
<p>快速选择算法用了快排的划分思想。</p>
</blockquote>
<ul>
<li>首先找个元素作为pivot</li>
<li>然后使得它左边元素全小于它</li>
<li>右边元素全大于它</li>
<li>然后对其中<strong>一个划分</strong>继续找（取决于j是第几个元素），直到j = k</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-02-044444.png" alt="image-20190302124443910"></p>
<h2 id="2-3-快速选择算法性能分析"><a href="#2-3-快速选择算法性能分析" class="headerlink" title="2.3 快速选择算法性能分析"></a>2.3 快速选择算法性能分析</h2><blockquote>
<p>快速选择算法是线性的</p>
</blockquote>
<p>首先，如果每次划分的刚好是差不多一半的话，比较次数是线性的。如果每次不是一般的话，可以通过等概率求出来，也是平均线性的</p>
<p><img src="http://img.hksite.cn/1473833988273" alt></p>
<h1 id="3-重复值问题"><a href="#3-重复值问题" class="headerlink" title="3.重复值问题"></a>3.重复值问题</h1><blockquote>
<p>快速排序有个问题，就是当它遇到重复键值的时候，性能会退化到，MergeSort没这个问题，这个问题直到1990年c的标准库中的qsort使用的快排都还有这个缺陷，而且基本所有工具书中的实现都有这个问题。</p>
</blockquote>
<h2 id="3-1-问题出现原因"><a href="#3-1-问题出现原因" class="headerlink" title="3.1 问题出现原因"></a>3.1 问题出现原因</h2><p>把所有相等的元素都放在一边了，这样，当数组中有很多重复元素的时候，划分算法基本就失灵了。</p>
<p>我们的代码解决方案是不管i和j只要碰到了相同元素就停下来（为什么？还记得我们代码里面全是用的<code>less</code>吗？相等的话不就不满足了嘛）这样基本可以保证哪怕在重复值很多的情况下，也基本是对半划分。</p>
<p>能不能有一个理想的算法，把所有相同的元素直接放一起呢？</p>
<h2 id="3-2-三路划分"><a href="#3-2-三路划分" class="headerlink" title="3.2  三路划分"></a>3.2  三路划分</h2><blockquote>
<p>思想很简单，原来是划分成两个部分，现在改成三个部分了，是不是很像荷兰国旗？ 直到1990年中叶，传统观点都认为荷兰国旗问题不值得去做，不过现在的c的qsort和java的sort都加入了这种改进</p>
</blockquote>
<p>三路划分的步骤比传统的快排划分会稍微麻烦一点点，它多了2个变量lt和gt，用来维持中间的边界。</p>
<ul>
<li>元素大于gt边界的，都是大于V的值，</li>
<li>元素小于lt边界的，都是小于V的值</li>
<li>元素在lt和gt中间的，都是等于V的值</li>
</ul>
<p><img src="http://img.hksite.cn/1473833058644" alt></p>
<h3 id="3-2-1算法步骤"><a href="#3-2-1算法步骤" class="headerlink" title="3.2.1算法步骤"></a>3.2.1算法步骤</h3><ul>
<li>设v = a[lo]</li>
<li>i 从左到右扫描，遇到hi停止<ul>
<li>当a[i] &lt; v 时，交换a[i]和a[lo]，然后lo和i同时+1 （放左边，lo还是指向v）</li>
<li>当a[i] &gt; v 时，交换a[i]和a[hi]，然后hi-1 （放右边，lo还是指向v,i不动，因为这个时候i指向的元素变了，还要判断呢）</li>
<li>当a[i] = v 时，i+1 （拉大i和lt的距离，扩大lt和hi的空间）</li>
</ul>
</li>
</ul>
<p><img src="http://img.hksite.cn/1473833066275" alt></p>
<h3 id="3-2-2代码"><a href="#3-2-2代码" class="headerlink" title="3.2.2代码"></a>3.2.2代码</h3><p>你可以发现其实这个代码很精巧</p>
<pre><code class="java">private static void sort(Comparable[] a, int lo, int hi)
{
  if (hi &lt;= lo) return;
  int lt = lo, gt = hi;
  Comparable v = a[lo];
  int i = lo;
  while (i &lt;= gt)
  {
      int cmp = a[i].compareTo(v);
      if      (cmp &lt; 0) exch(a, lt++, i++);
      else if (cmp &gt; 0) exch(a, i, gt--);
      else              i++;
  }
  sort(a, lo, lt - 1);
  sort(a, gt + 1, hi);
}</code></pre>
<h3 id="3-3-3-三路划分的快排性能"><a href="#3-3-3-三路划分的快排性能" class="headerlink" title="3.3.3 三路划分的快排性能"></a>3.3.3 三路划分的快排性能</h3><p>总而言之一句话，它在实际应用中性能很棒，效率很高，是熵最优的。</p>
<p><img src="http://img.hksite.cn/1473833097721" alt></p>
<h1 id="系统排序"><a href="#系统排序" class="headerlink" title="系统排序"></a>系统排序</h1><blockquote>
<p>排序在实际的应用中十分广泛</p>
</blockquote>
<p><img src="http://img.hksite.cn/1473424992761" alt></p>
<p>java中使用的主要是快排处理<code>基础类型</code>，<code>mergesort</code>处理<code>对象类型</code></p>
<p><img src="http://img.hksite.cn/1473424982979" alt></p>
<p>我们之前说过了，快排有一定的缺陷，所以有人花了大功夫改进了快排算法，也是现在C，C++, java中广泛使用的</p>
<p><img src="http://img.hksite.cn/1473424925243" alt></p>
<p><img src="http://img.hksite.cn/1473424942628" alt></p>
<p>但是尽管这样，快排还是有缺陷</p>
<p><img src="http://img.hksite.cn/1473424915044" alt></p>
<p>目前在不同领域有不同的适用的算法</p>
<p><img src="http://img.hksite.cn/1473424898416" alt></p>
<p>但是没有一种算法能覆盖所有应用，也许快排在大多数排序应用中都是很好的选择，但是它毕竟是不稳定的，而且在一些特殊情况下，性能不会特别好，还可能会出现一些致命的错误。</p>
<p><img src="http://img.hksite.cn/1473424881943" alt></p>
<p>所以要学会去评价一个算法的优劣和是否适合自己的应用，以及如何能够改进算法使得它更好的适应自己的应用。</p>
<p><img src="http://img.hksite.cn/1473424876881" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-希尔排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-希尔排序/" itemprop="url">希尔排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“<a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第4版）</a>”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。</p>
<p><strong>通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解。</strong></p>
</blockquote>
<p>希尔排序是这是本课程中出现的第一个<strong>非平凡</strong>的排序算法。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote>
<p>希尔的思想也很简单就是一个<strong>h-sort</strong>的<strong>插入算法</strong>——每相邻h个元素进行插入排序 </p>
</blockquote>
<p><img src="http://img.hksite.cn/2019-03-01-20160406225900247.gif" alt></p>
<h2 id="为什么是插入排序？"><a href="#为什么是插入排序？" class="headerlink" title="为什么是插入排序？"></a>为什么是插入排序？</h2><ul>
<li>如果h比较大，那么子数组会很小，用插入效率高</li>
<li>如果h很小，这时候数组基本有序，插入效率高</li>
</ul>
<h2 id="h的确定方法"><a href="#h的确定方法" class="headerlink" title="h的确定方法"></a>h的确定方法</h2><p>一般常用的是 : <strong>h=3h+1</strong>——兼顾奇偶</p>
<h1 id="希尔排序的特点"><a href="#希尔排序的特点" class="headerlink" title="希尔排序的特点"></a>希尔排序的特点</h1><p><strong>简单的想法却导致巨大的性能收益</strong>！</p>
<ul>
<li>在实际使用中，对于不是特别大的数组，排序速度快。</li>
<li>代码量小（可用于嵌入式中）</li>
<li>硬件类算法原型</li>
<li>通过找更好的递增数列可以有更好的性能提升（这是一个新的课题）</li>
</ul>
<p><img src="http://img.hksite.cn/2019-03-01-072342.jpg" alt></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="java">public class Shell{
    public static sort(Comparable[] a)
    {
        int N = a.length();
        int h = 1;
        while(h &lt; N/3)   //找比n小的最大h
            h = 3*h+1;
        do{
            for(i = h;i &lt; N; i++)
            {
                for(j = i;j &gt;= h &amp;&amp; less(a[j],a[j-h]);j -= h)  
                exch(a,a[j],a[j-h]);
            }
            h = h/3;  //由于是取整操作所以h/3 == (h-1)/3
        }while(h &gt; 1)
    }
}</code></pre>
<p><strong>注意：</strong> 这里的循环 </p>
<pre><code class="java">    for(i = h;i &lt; N; i++) 
      for(j = i;j &gt;= h &amp;&amp; less(a[j],a[j-h]);j -= h)</code></pre>
<p>是用的i从前往后，j从后往前。j也可以用从前往后 </p>
<pre><code class="java">    for(i = 0;i &lt; N-h; i++) 
      for(j = i;j + h &lt; N &amp;&amp; less(a[j+h],a[j]);j += h)</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">190</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
