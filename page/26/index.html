<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Fey&#39;s blog">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/page/26/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fey&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/page/26/">





  <title>Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-移动端事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-移动端事件/" itemprop="url">移动端事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- toc orderedList:0 depthFrom:1 depthTo:6 -->

<ul>
<li><a href="#移动端事件">移动端事件</a><ul>
<li><a href="#移动端触摸事件">移动端触摸事件</a><ul>
<li><a href="#触摸事件顺序">触摸事件顺序</a></li>
<li><a href="#点击穿透">点击穿透</a></li>
</ul>
</li>
<li><a href="#手势事件">手势事件</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1 id="移动端事件"><a href="#移动端事件" class="headerlink" title="移动端事件"></a>移动端事件</h1><h2 id="移动端触摸事件"><a href="#移动端触摸事件" class="headerlink" title="移动端触摸事件"></a>移动端触摸事件</h2><ul>
<li>touchstart<ul>
<li>当手指放在屏幕上出发</li>
</ul>
</li>
<li>touchmove<ul>
<li>当手指在屏幕上滑动时，连续触发</li>
</ul>
</li>
<li>touchend<ul>
<li>当手指从屏幕离开时触摸</li>
</ul>
</li>
<li>touchcancel<ul>
<li>当系统停止跟踪时触发(在拖动中断时候触发)，系统什么时候取消，文档没有明确的说明。</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于触摸会导致屏幕动来动去，所以可以会在这些事件的事件处理函数内使用<code>event.preventDefault()</code>，来阻止屏幕的默认滚动。</p>
</blockquote>
<p>触摸事件还包含下列三个用于跟踪触摸的属性：</p>
<ul>
<li>touches：表示当前跟踪的触摸操作的touch对象的数组。</li>
</ul>
<p>当一个手指在触屏上时，event.touches.length=1,<br>当两个手指在触屏上时，event.touches.length=2，以此类推。</p>
<ul>
<li>targetTouches：特定于事件目标的touch对象数组。</li>
</ul>
<p>因为touch事件是会冒泡的，所以利用这个属性指出目标对象。</p>
<ul>
<li><p>changedTouches：表示自上次触摸以来发生了什么改变的touch对象的数组。</p>
</li>
<li><p>每个touch对象都包含下列几个属性：</p>
<ul>
<li>clientX：触摸目标在视口中的x坐标。</li>
<li>clientY：触摸目标在视口中的y坐标。<ul>
<li>clientX/clientY不包括对象滚动而隐藏的偏移量</li>
</ul>
</li>
<li>identifier：标识触摸的唯一ID。</li>
<li>pageX：触摸目标在页面中的x坐标。</li>
<li>pageY：触摸目标在页面中的y坐标。<ul>
<li>pageX/pageY包括对象滚动而隐藏的偏移量。</li>
</ul>
</li>
<li>screenX：触摸目标在屏幕中的x坐标。</li>
<li>screenY：触摸目标在屏幕中的y坐标。<ul>
<li>screenX/screenY代表事件发生的位置对于屏幕的偏移量</li>
</ul>
</li>
<li>target：触摸的DOM节点目标。</li>
<li>offsetX/offsetY<ul>
<li>触摸目标相对与这个DOM元素左上角的定位，不要边框，在边框上会是负数。</li>
<li>layerX/Y是兼容FF的写法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">    EventUtil.addHandler(div,&quot;touchstart&quot;,function(event){
        div.innerHTML=event.touches[0].clientX+&#39;,&#39;+event.touches[0].clientY;
    });
    EventUtil.addHandler(div,&quot;touchmove&quot;,function(event){
        event.preventDefault();
        div.innerHTML=event.touches[0].clientX;
    });
    EventUtil.addHandler(div,&quot;touchend&quot;,function(event){
        div.innerHTML=event.changedTouches[0].clientY;
    });</code></pre>
<p>使用<code>clientX……</code>时，必须要指明具体的touch对象，而不要直接指明数组。</p>
<p><code>event.touches[0]</code>在touchend事件处理函数中，当该事件发生时，touches里面已经没有任何的touch对象了，此时，就要使用changeTouches集合。</p>
<blockquote>
<p>参考：<a href="http://www.jianshu.com/p/832f36531df9" target="_blank" rel="noopener">http://www.jianshu.com/p/832f36531df9</a> ，<a href="http://www.th7.cn/Design/idea/201305/153435.shtml" target="_blank" rel="noopener">http://www.th7.cn/Design/idea/201305/153435.shtml</a></p>
</blockquote>
<h3 id="触摸事件顺序"><a href="#触摸事件顺序" class="headerlink" title="触摸事件顺序"></a>触摸事件顺序</h3><p>事件的触发过程为：<strong>mousedown</strong> -&gt; <strong>mouseup</strong> -&gt; <strong>click</strong> 三步。</p>
<p>手机上响应 <code>click</code> 事件会有300ms的延迟，但可以添加一下<code>meta</code>标签去除：</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code></pre>
<h3 id="点击穿透"><a href="#点击穿透" class="headerlink" title="点击穿透"></a>点击穿透</h3><p>而由于click事件的滞后性（300ms），在这300ms内上层元素隐藏或消失了，下层同样位置的DOM元素触发了click事件（如果是input框则会触发focus事件），看起来就像点击的target“穿透”到下层去了。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><strong>遮挡</strong></li>
</ul>
<p>元素消失可以使用<code>fade</code>效果。</p>
<p>或者在点击处生成一个透明的元素，在一定时间后移除。</p>
<ul>
<li><p><strong>pointer-events</strong></p>
<p>当时属性值为<code>none</code>， 元素不再是鼠标事件的目标。</p>
</li>
<li><p>fastclick</p>
<p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a>是一个开源库，其思路是取消<code>click</code>事件，用<code>touchend</code>模拟快速点击行为。</p>
</li>
</ul>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000003848737" target="_blank" rel="noopener">也来说说touch事件与点击穿透问题</a></p>
</blockquote>
<h2 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h2><ul>
<li>gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。</li>
<li>gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。</li>
<li>gestureend：当任何一个手指从屏幕上面移开时触发。</li>
</ul>
<blockquote>
<p>【注意】只有两个手指都触摸到事件的接收容器时才触发这些手势事件。</p>
</blockquote>
<p>1、当一个手指放在屏幕上时，会触发touchstart事件，如果另一个手指又放在了屏幕上，则会触发gesturestart事件，随后触发基于该手指的touchstart事件。</p>
<p>2、如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件，但只要有一个手指移开，则会触发gestureend事件，紧接着又会触发toucheend事件。</p>
<h3 id="手势的专有属性"><a href="#手势的专有属性" class="headerlink" title="手势的专有属性:"></a>手势的专有属性:</h3><ul>
<li>rotation：表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从零开始。</li>
<li>scale：表示两个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始，并随距离拉大而增长。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-移动端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-移动端/" itemprop="url">移动端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2016年5月4日"><a href="#2016年5月4日" class="headerlink" title="2016年5月4日"></a>2016年5月4日</h1><h2 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h2><pre><code>alert(document.documentElement.clientWidth);//文档屏幕宽度

window.screen.width//设备屏幕宽度

alert(window.devicePixelRatio);//设备物理像素与设备独立像素的比值</code></pre><ul>
<li><strong>事件</strong></li>
</ul>
<ol>
<li>touchstart  手指按上</li>
<li>touchmove  手指按着移动</li>
<li>touchend  手指移开 </li>
</ol>
<ul>
<li><strong>touchEvent</strong></li>
</ul>
<ol>
<li>touches  当前位于屏幕上的所有手指的一个列表</li>
<li>targetTouches  位于当前DOM元素上的手指的一个列表</li>
<li>changedTouches   涉及当前事件的手指的一个列表 </li>
</ol>
<pre><code class="js">box.ontouchend=function(ev){
    console.log(&quot;3...&quot;);
    console.log(ev.touches);
    console.log(ev.targetTouches);
    console.log(ev.changedTouches);
}</code></pre>
<ul>
<li><strong>自定义属性</strong></li>
</ul>
<p>使用JavaScript操作dataset：</p>
<ol>
<li>我们在添加或读取属性的时候需要去掉前缀data-*，像上面的例子我们没有使用test.dataset.data-my = ‘Byron’;的形式。</li>
<li>如果属性名称中还包含连字符(-)，需要转成驼峰命名方式，但如果在CSS中使用选择器，我们需要使用连字符格式</li>
</ol>
<pre><code class="css">        div[data-birth-date]
        {
            background-color: #0f0;
            width:100px;
            margin:20px;
        }</code></pre>
<p>使用getAttribute/setAttribute操作</p>
<pre><code class="js">var test = document.getElementById(&#39;test&#39;);
test.dataset.birthDate = &#39;19890615&#39;;
test.setAttribute(&#39;age&#39;, 25);
test.setAttribute(&#39;data-sex&#39;, &#39;male&#39;);

console.log(test.getAttribute(&#39;data-age&#39;)); //24
console.log(test.getAttribute(&#39;data-birth-date&#39;)); //19890516
console.log(test.dataset.age); //24
console.log(test.dataset.sex); //male</code></pre>
<p>所有自定义属性在dataset对象中统一管理,方便调用遍历。</p>
<pre><code class="html">&lt;a data-href=&quot;http://www.qq.com&quot; ontouchmove=&quot;this.s=1&quot; ontouchend=&quot;this.s||window.open(this.dataset.href),this.s=0&quot;&gt;
        &lt;img src=&quot;1.jpg&quot;&gt;
&lt;/a&gt;
</code></pre>
<p>[TOC]</p>
<h1 id="2016年5月5日"><a href="#2016年5月5日" class="headerlink" title="2016年5月5日"></a>2016年5月5日</h1><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><ul>
<li><strong>window.open</strong></li>
</ul>
<p>语法：</p>
<pre><code>window = object.open([URL ][, name ][, features ][, replace]) </code></pre><ul>
<li>URL：新窗口的URL地址 </li>
<li>name：新窗口的名称，可以为空 </li>
<li>featurse：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。 </li>
<li>fullscreen= { yes/no/1/0 } 是否全屏，默认no </li>
<li>channelmode= { yes/no/1/0 } 是否显示频道栏，默认no </li>
<li>toolbar= { yes/no/1/0 } 是否显示工具条，默认no </li>
<li>location= { yes/no/1/0 } 是否显示地址栏，默认no </li>
<li>directories = { yes/no/1/0 } 是否显示转向按钮，默认no </li>
<li>status= { yes/no/1/0 } 是否显示窗口状态条，默认no </li>
<li>menubar= { yes/no/1/0 } 是否显示菜单，默认no </li>
<li>scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes </li>
<li>resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no </li>
<li>width=number 窗口宽度（像素单位） </li>
<li>height=number 窗口高度（像素单位） </li>
<li>top=number 窗口离屏幕顶部距离（像素单位） </li>
<li>left=number 窗口离屏幕左边距离（像素单位）</li>
</ul>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><ul>
<li>shift()，unshift()</li>
</ul>
<p>shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<pre><code class="js">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

a.shift() // &#39;a&#39;
a // [&#39;b&#39;, &#39;c&#39;]</code></pre>
<p>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<pre><code class="js">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

a.unshift(&#39;x&#39;); // 4
a // [&#39;x&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<ul>
<li>reverse()</li>
</ul>
<p>reverse方法用于颠倒数组中元素的顺序，使用这个方法以后，返回改变后的原数组。</p>
<pre><code class="js">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 
a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]    </code></pre>
<ul>
<li>slice()</li>
</ul>
<p>slice方法用于提取原数组的一部分，返回一个新数组，原数组不变。<br>它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。</p>
<pre><code class="js">// 格式
arr.slice(start_index, upto_index);

// 用法
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.slice(1) // [&quot;b&quot;, &quot;c&quot;]
a.slice(1, 2) // [&quot;b&quot;]
a.slice(2, 6) // [&quot;c&quot;]</code></pre>
<ul>
<li>splice()</li>
</ul>
<p>splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<pre><code class="javascript">// 格式
arr.splice(index, count_to_remove, addElement1, addElement2, ...);

// 用法
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]
a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</code></pre>
<ul>
<li>sort()</li>
</ul>
<p>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
<pre><code class="javascript">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort()
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]

[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

[11, 101].sort()
// [101, 11]

[10111,1101,111].sort()
// [10111, 1101, 111]</code></pre>
<p>[TOC]</p>
<h1 id="2016年5月6日"><a href="#2016年5月6日" class="headerlink" title="2016年5月6日"></a>2016年5月6日</h1><h2 id="javascript-1"><a href="#javascript-1" class="headerlink" title="javascript"></a>javascript</h2><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><p><strong>Date对象的静态方法：</strong></p>
<ul>
<li>Date.now()</li>
</ul>
<p>Date.now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数</p>
<p><strong>window.performance.now()</strong>提供页面加载到命令运行时的已经过去的时间，可以精确到千分之一毫秒。</p>
<ul>
<li>Date.parse()</li>
</ul>
<p>Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。</p>
<pre><code>Date.parse(&#39;Aug 9, 1995&#39;)
// 返回807897600000，以下省略返回值</code></pre><ul>
<li>Date.UTC()</li>
</ul>
<p>Date.UTC方法可以返回UTC时间（世界标准时间）。</p>
<pre><code class="js">// 格式
Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])

// 用法
Date.UTC(2011, 0, 1, 2, 3, 4, 567)
// 1293847384567</code></pre>
<p><strong>Date的实例对象分为以下三类:</strong></p>
<ul>
<li>to类：从Date对象返回一个字符串，表示指定的时间。</li>
<li>get类：获取Date对象的日期和时间。</li>
<li>set类：设置Date对象的日期和时间。</li>
</ul>
<p><strong>to类方法</strong></p>
<ul>
<li>Date.prototype.toString()</li>
</ul>
<p>toString方法返回一个完整的日期字符串。</p>
<pre><code class="js">var d = new Date(2013, 0, 1);

d.toString()
// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;

d
// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</code></pre>
<ul>
<li>Date.prototype.toUTCString()</li>
</ul>
<p>toUTCString方法返回对应的UTC时间，也就是比北京时间晚8个小时。</p>
<pre><code class="js">var d = new Date(2013, 0, 1);

d.toUTCString()
// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;

d.toString()
// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</code></pre>
<ul>
<li>Date.prototype.toISOString()</li>
</ul>
<p>toISOString方法返回对应时间的ISO8601写法。</p>
<pre><code class="js">var d = new Date(2013, 0, 1);

d.toString()
// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;

d.toISOString()
// &quot;2012-12-31T16:00:00.000Z&quot;</code></pre>
<ul>
<li>Date.prototype.toJSON()</li>
</ul>
<p>toJSON方法返回一个符合JSON格式的ISO格式的日期字符串，与toISOString方法的返回结果完全相同。</p>
<pre><code class="js">var d = new Date(2013, 0, 1);

d.toJSON()
// &quot;2012-12-31T16:00:00.000Z&quot;

d.toISOString()
// &quot;2012-12-31T16:00:00.000Z&quot;</code></pre>
<ul>
<li>Date.prototype.toDateString()</li>
</ul>
<p>toDateString方法返回日期字符串。</p>
<pre><code>var d = new Date(2013, 0, 1);
d.toDateString() // &quot;Tue Jan 01 2013&quot;</code></pre><ul>
<li>Date.prototype.toTimeString()</li>
</ul>
<p>toTimeString方法返回时间字符串。</p>
<pre><code class="js">var d = new Date(2013, 0, 1);
d.toTimeString() // &quot;00:00:00 GMT+0800 (CST)&quot;</code></pre>
<ul>
<li>Date.prototype.toLocalDateString()</li>
</ul>
<p>toLocalDateString方法返回一个字符串，代表日期的当地写法。</p>
<pre><code class="javascript">var d = new Date(2013, 0, 1);

d.toLocaleDateString()
// 中文版浏览器为&quot;2013年1月1日&quot;
// 英文版浏览器为&quot;1/1/2013&quot;</code></pre>
<p><strong>get类方法:</strong><br>Date对象提供了一系列get*方法，用来获取实例对象某个方面的值。</p>
<ul>
<li>getTime()：返回距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。</li>
<li>getDate()：返回实例对象对应每个月的几号（从1开始）。</li>
<li>getDay()：返回星期几，星期日为0，星期一为1，以此类推。</li>
<li>getYear()：返回距离1900的年数。</li>
<li>getFullYear()：返回四位的年份。</li>
<li>getMonth()：返回月份（0表示1月，11表示12月）。</li>
<li>getHours()：返回小时（0-23）。</li>
<li>getMilliseconds()：返回毫秒（0-999）。</li>
<li>getMinutes()：返回分钟（0-59）。</li>
<li>getSeconds()：返回秒（0-59）。</li>
<li>getTimezoneOffset()：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li>
</ul>
<p><strong>set类方法：</strong></p>
<ul>
<li><p>setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。</p>
</li>
<li><p>setYear(year): 设置距离1900年的年数。</p>
</li>
<li><p>setFullYear(year [, month, date])：设置四位年份。</p>
</li>
<li><p>setHours(hour [, min, sec, ms])：设置小时（0-23）。</p>
</li>
<li><p>setMilliseconds()：设置毫秒（0-999）。</p>
</li>
<li><p>setMinutes(min [, sec, ms])：设置分钟（0-59）。</p>
</li>
<li><p>setMonth(month [, date])：设置月份（0-11）。</p>
</li>
<li><p>setSeconds(sec [, ms])：设置秒（0-59）。</p>
</li>
<li><p>setTime(milliseconds)：设置毫秒时间戳。</p>
<p>目录 2016年5月7日javascriptMath对象Number对象自定义方法Object对象的方法</p>
</li>
</ul>
<h1 id="2016年5月7日"><a href="#2016年5月7日" class="headerlink" title="2016年5月7日"></a>2016年5月7日</h1><h2 id="javascript-2"><a href="#javascript-2" class="headerlink" title="javascript"></a>javascript</h2><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p><strong>属性</strong></p>
<ul>
<li>Math.E：常数e。</li>
<li>Math.LN2：2的自然对数。</li>
<li>Math.LN10：10的自然对数。</li>
<li>Math.LOG2E：以2为底的e的对数。</li>
<li>Math.LOG10E：以10为底的e的对数。</li>
<li>Math.PI：常数Pi。</li>
<li>Math.SQRT1_2：0.5的平方根。</li>
<li>Math.SQRT2：2的平方根。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>Math.abs()：绝对值</li>
<li>Math.ceil()：向上取整</li>
<li>Math.floor()：向下取整</li>
<li>Math.max()：最大值</li>
<li>Math.min()：最小值</li>
<li>Math.pow()：指数运算</li>
<li>Math.sqrt()：平方根</li>
<li>Math.log()：自然对数</li>
<li>Math.exp()：e的指数</li>
<li>Math.round()：四舍五入</li>
<li>Math.random()：随机数</li>
</ul>
<h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><p><strong>属性</strong></p>
<ul>
<li>Number.POSITIVE_INFINITY：正的无限，指向Infinity。</li>
<li>Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。</li>
<li>Number.NaN：表示非数值，指向NaN。</li>
<li>Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。</li>
<li>Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324） - ，相应的，最接近0的负数为-Number.MIN_VALUE。</li>
<li>Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。</li>
<li>Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</li>
</ul>
<p><strong>方法</strong></p>
<p>1.Number.prototype.toString()</p>
<p>Number对象部署了单独的toString方法，可以接受一个参数，表示将一个数字转化成某个进制的字符串。</p>
<pre><code class="js">(10).toString() // &quot;10&quot;
10[&#39;toString&#39;](2) // &quot;1010&quot;
(10).toString(2) // &quot;1010&quot;
(10).toString(8) // &quot;12&quot;
(10).toString(16) // &quot;a&quot;</code></pre>
<blockquote>
<p>将其他进制的数，转回十进制，需要使用parseInt方法。</p>
</blockquote>
<p>2.Number.prototype.toFixed()</p>
<p>toFixed方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。</p>
<pre><code class="js">(10).toFixed(2) // &quot;10.00&quot;
10.005.toFixed(2) // &quot;10.01&quot;</code></pre>
<p>3.Number.prototype.toExponential()</p>
<p>toExponential方法用于将一个数转为科学计数法形式。</p>
<pre><code class="js">(10).toExponential(1)
// &quot;1.0e+1&quot;

(1234).toExponential(1)
// &quot;1.2e+3&quot;</code></pre>
<p>4.Number.prototype.toPrecision()</p>
<p>toPrecision方法用于将一个数转为指定位数的有效数字。</p>
<pre><code class="js">(12.34).toPrecision(1) // &quot;1e+1&quot;
(12.34).toPrecision(2) // &quot;12&quot;
(12.34).toPrecision(3) // &quot;12.3&quot;
(12.34).toPrecision(4) // &quot;12.34&quot;
(12.34).toPrecision(5) // &quot;12.340&quot;</code></pre>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。</p>
<pre><code class="js">Number.prototype.add = function (x) {
  return this + x;
};

8[&#39;add&#39;](2)
// 10</code></pre>
<h3 id="Object对象的方法"><a href="#Object对象的方法" class="headerlink" title="Object对象的方法"></a>Object对象的方法</h3><ul>
<li>Object()</li>
</ul>
<p>Object本身当作工具方法使用时，可以将任意值转为对象。   </p>
<p>其中，原始类型的值转为对应的包装对象</p>
<pre><code class="js">Object() // 返回一个空对象
Object(undefined) // 返回一个空对象
Object(null) // 返回一个空对象

Object(1) // 等同于 new Number(1)
Object(&#39;foo&#39;) // 等同于 new String(&#39;foo&#39;)
Object(true) // 等同于 new Boolean(true)

Object([]) // 返回原数组
Object({}) // 返回原对象
Object(function(){}) // 返回原函数</code></pre>
<ul>
<li>Object.keys()，Object.getOwnPropertyNames()</li>
</ul>
<p>Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。</p>
<pre><code class="js">var o = {
    p1: 123,
    p2: 456
};

Object.keys(o)
// [&quot;p1&quot;, &quot;p2&quot;]

Object.getOwnPropertyNames(o)
// [&quot;p1&quot;, &quot;p2&quot;]
// 
var a = [&quot;Hello&quot;, &quot;World&quot;];

Object.keys(a)
// [&quot;0&quot;, &quot;1&quot;]

Object.getOwnPropertyNames(a)
// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]
// 
Object.keys(o).length
//一般使用这个方法计算属性个数。</code></pre>
<p>[TOC]</p>
<h1 id="2016年5月9日"><a href="#2016年5月9日" class="headerlink" title="2016年5月9日"></a>2016年5月9日</h1><h2 id="javascript-3"><a href="#javascript-3" class="headerlink" title="javascript"></a>javascript</h2><h3 id="对象的属性模型"><a href="#对象的属性模型" class="headerlink" title="对象的属性模型"></a>对象的属性模型</h3><ul>
<li>Object.getOwnPropertyDescriptor()</li>
</ul>
<p>在JavaScript内部，每个属性都有一个对应的attributes对象，保存该属性的一些元信息。</p>
<pre><code class="js">var o = { p: &#39;a&#39; };

Object.getOwnPropertyDescriptor(o, &#39;p&#39;)
// Object { value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }</code></pre>
<p>上面代码表示，使用Object.getOwnPropertyDescriptor方法，读取o对象的p属性的attributes对象。</p>
<p>attributes对象包含如下元信息:</p>
<ul>
<li><p>value：表示该属性的值，默认为undefined。</p>
</li>
<li><p>writable：表示该属性的值（value）是否可以改变，默认为true。</p>
</li>
<li><p>enumerable：表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for… - in循环、Object.keys()）跳过该属性。</p>
</li>
<li><p>configurable：表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属 - 性，比如，无法删除该属性，也不得改变该属性的attributes对象（value属性除外），也 - 就是说，configurable属性控制了attributes对象的可写性。</p>
</li>
<li><p>get：表示该属性的取值函数（getter），默认为undefined。</p>
</li>
<li><p>set：表示该属性的存值函数（setter），默认为undefined。</p>
</li>
<li><p>Object.defineProperty()，Object.defineProperties()</p>
</li>
</ul>
<p><strong>Object.defineProperty</strong>方法允许通过定义attributes对象，来定义或修改一个属性，然后返回修改后的对象。</p>
<pre><code>Object.defineProperty(object, propertyName, attributesObject)</code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><strong>新建</strong></p>
<pre><code class="js">var regex = /xyz/;

var regex = new RegExp(&#39;xyz&#39;);</code></pre>
<p>第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。</p>
<ul>
<li>修饰符属性</li>
<li>ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。</li>
<li>global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。</li>
<li>multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。</li>
</ul>
<pre><code class="js">var r = /abc/igm;

r.ignoreCase // true
r.global // true
r.multiline // true</code></pre>
<ul>
<li><p>与修饰符无关的属性</p>
</li>
<li><p>lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。</p>
</li>
<li><p>source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。 </p>
</li>
</ul>
<pre><code class="javascript">var r = /abc/igm;

r.lastIndex // 0
r.source // &quot;abc&quot;</code></pre>
<ul>
<li>test()</li>
</ul>
<p>正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>
<pre><code>/cat/.test(&#39;cats and dogs&#39;) // true</code></pre><ul>
<li>exec()</li>
</ul>
<p>正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，每个匹配成功的子字符串，就是数组成员，否则返回null。</p>
<pre><code class="js">var s = &#39;_x_x&#39;;
var r1 = /x/;
var r2 = /y/;

r1.exec(s) // [&quot;x&quot;]
r2.exec(s) // null</code></pre>
<ul>
<li>字符串对象的方法</li>
</ul>
<ol>
<li>match()：返回一个数组，成员是所有匹配的子字符串。</li>
<li>search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li>replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li>split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ol>
<ul>
<li>字面量字符和元字符</li>
</ul>
<p><strong>（1）点字符（.）</strong></p>
<p>点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</p>
<pre><code>/c.t/</code></pre><p>上面代码中，c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot。</p>
<p><strong>（2）位置字符</strong></p>
<ul>
<li>^ 表示字符串的开始位置</li>
<li>$ 表示字符串的结束位置</li>
</ul>
<pre><code class="js">// test必须出现在开始位置
/^test/.test(&#39;test123&#39;) // true

// test必须出现在结束位置
/test$/.test(&#39;new test&#39;) // true

// 从开始位置到结束位置只有test
/^test$/.test(&#39;test&#39;) // true
/^test$/.test(&#39;test test&#39;) // false</code></pre>
<p><strong>（3）选择符（/）</strong></p>
<ul>
<li>重复类</li>
</ul>
<p>使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p>
<pre><code>/lo{2}k/.test(&#39;look&#39;) // true
/lo{2, 5}k/.test(&#39;looook&#39;) // true</code></pre><ul>
<li>量词符<ul>
<li>? 问号表示某个模式出现0次或1次，等同于{0, 1}。</li>
<li><ul>
<li>星号表示某个模式出现0次或多次，等同于{0,}。</li>
</ul>
</li>
<li><ul>
<li>加号表示某个模式出现1次或多次，等同于{1,}。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">// t出现0次或1次
/t?est/.test(&#39;test&#39;) // true
/t?est/.test(&#39;est&#39;) // true

// t出现1次或多次
/t+est/.test(&#39;test&#39;) // true
/t+est/.test(&#39;ttest&#39;) // true
/t+est/.test(&#39;est&#39;) // false

// t出现0次或多次
/t*est/.test(&#39;test&#39;) // true
/t*est/.test(&#39;ttest&#39;) // true
/t*est/.test(&#39;tttest&#39;) // true
/t*est/.test(&#39;est&#39;) // true</code></pre>
<ul>
<li>贪婪模式</li>
</ul>
<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。</p>
<pre><code>var s = &#39;aaa&#39;;
s.match(/a+/) // [&quot;aaa&quot;] </code></pre><ul>
<li>字符类</li>
</ul>
<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。</p>
<pre><code class="js">    /[abc]/.test(&#39;hello world&#39;) // false
    /[abc]/.test(&#39;apple&#39;) // true</code></pre>
<p><strong>（1）脱字符（^）</strong></p>
<p>如果方括号内的第一个字符是[ ^ ]，则表示除了字符类之中的字符。</p>
<pre><code>/[^abc]/.test(&#39;hello world&#39;) // true</code></pre><p><strong>（2）连字符（-）</strong></p>
<p>[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</p>
<pre><code>/a-z/.test(&#39;b&#39;) // false</code></pre><p>连字符还可以用来指定Unicode字符的范围。</p>
<pre><code class="js">var str = &quot;\u0130\u0131\u0132&quot;;
/[\u0128-\uFFFF]/.test(str)
// true</code></pre>
<ul>
<li>转义符</li>
</ul>
<p>^、.、[、$、(、)、|、*、+、?、{和\。 </p>
<ul>
<li>预定义模式<ul>
<li>\d 匹配0-9之间的任一数字，相当于[0-9]。</li>
<li>\D 匹配所有0-9以外的字符，相当于[^0-9]。</li>
<li>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</li>
<li>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</li>
<li>\s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。</li>
<li>\S 匹配非空格的字符，相当于[^\t\r\n\v\f ]。</li>
<li>\b 匹配词的边界。</li>
<li>\B 匹配非词边界，即在词的内部。</li>
</ul>
</li>
<li>特殊字符<ul>
<li>\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li>[\b] 匹配退格键(U+0008)，不要与\b混淆。</li>
<li>\n 匹配换行键。</li>
<li>\r 匹配回车键。</li>
<li>\t 匹配制表符tab（U+0009）。</li>
<li>\v 匹配垂直制表符（U+000B）。</li>
<li>\f 匹配换页符（U+000C）。</li>
<li>\0 匹配null字符（U+0000）。</li>
<li>\xhh 匹配一个以两位十六进制数表示的字符。</li>
<li>\uhhhh 匹配一个以四位十六进制数表示的unicode字符。</li>
<li></li>
</ul>
</li>
</ul>
<p>[TOC]</p>
<h1 id="2016年5月23日"><a href="#2016年5月23日" class="headerlink" title="2016年5月23日"></a>2016年5月23日</h1><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><pre><code>document.body.scrollTop:获取页面滚动的高度。
someElement.scrollTop：元素滚动条内的顶部隐藏部分的高度。

document.body.offsetHeight:网页可见区域高
document.body.offsetWidth :网页可见区域宽

screen.availWidth - 可用的屏幕宽度
screen.availHeight - 可用的屏幕高度</code></pre><pre><code>obj.offsetLeft //元素相对于父元素的left
obj.offsetTop //元素相对于父元素的top
obj.offsetWidth //元素的宽度
obj.offsetHeight //元素的高度</code></pre><p>补充：</p>
<pre><code>obj.clientWidth //获取元素的宽度
obj.clientHeight //元素的高度

clientWidth = width + padding
clientHeight = height + padding
offsetWidth = width + padding + border
offsetHeight = width + padding + border</code></pre><p>[TOC]</p>
<h1 id="2016年5月26日"><a href="#2016年5月26日" class="headerlink" title="2016年5月26日"></a>2016年5月26日</h1><h2 id="jQuery-1"><a href="#jQuery-1" class="headerlink" title="jQuery"></a>jQuery</h2><p><strong>滚动监听</strong></p>
<pre><code class="js"> $(window).scroll(function () {
            var $currentWindow = $(window); 


            //当前窗口的高度  
            var windowHeight = $currentWindow.height();  
            console.log(&quot;current widow height is &quot; + windowHeight);  


            //当前滚动条从上往下滚动的距离  
            var scrollTop = $currentWindow.scrollTop();  
            console.log(&quot;current scrollOffset is &quot; + scrollTop);  


            //当前文档的高度  
            var docHeight = $(document).height();  
            console.log(&quot;current docHeight is &quot; + docHeight);  

            //当 滚动条距底部的距离 + 滚动条滚动的距离 &gt;= 文档的高度 - 窗口的高度  
            //换句话说：（滚动条滚动的距离 + 窗口的高度 = 文档的高度）  这个是基本的公式  
            if ((BOTTOM_OFFSET + scrollTop) &gt;= docHeight - windowHeight) {  
                createListItems();  
            }  
        });  </code></pre>
<p>window.innerHeight – 浏览器窗口的内部高度,包括滚动条<br>window.innerWidth – 浏览器窗口的内部宽度，包括滚动条</p>
<p>document.documentElement.clientHeight，根元素html的高度。<br>document.documentElement.clientWidth，根元素html的宽度。</p>
<blockquote>
<p>documentElement 是整个节点树的根节点root，即<html> 标签；</html></p>
</blockquote>
<p>document.body.clientHeight，body元素的高度，可有元素撑起，或者自定义。<br>document.body.clientWidth，body元素的宽度，可有元素撑起，或者自定义。</p>
<blockquote>
<p>clientTop实际上就是border的高度；</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-红黑树介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-红黑树介绍/" itemprop="url">红黑树介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“算法（第4版）”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。 通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解。</p>
</blockquote>
<hr>
<h1 id="红黑树介绍"><a href="#红黑树介绍" class="headerlink" title="红黑树介绍"></a>红黑树介绍</h1><blockquote>
<p>红黑树是一种简单的实现2-3树的数据结构，它方便的把我们之前实现的二叉搜索树改造成了一棵2-3树。它的核心思想是用一条左倾链（红链）作为“胶水”把二叉树的两个节点给粘起来，形成一个3节点。</p>
</blockquote>
<p><img src="http://img.hksite.cn/1464084199170" alt></p>
<p>把红链看成水平的，看是不是和2-3树就一样了</p>
<p><img src="http://img.hksite.cn/1464084302728" alt></p>
<p>BST改造成红黑树有一些约定：</p>
<ul>
<li>每个节点最多只有一个红链与之相连(连父亲和孩子)</li>
<li>每条从root到null的路径，都是同样的黑链数（绝对黑平衡）</li>
<li>红链都在左边</li>
</ul>
<p>这样做的好处是什么？就是之前写的代码很多基本可以不用改就可以直接用（比如get，floor，ceiling操作，因为这些操作是不需要考虑红黑链的）</p>
<h1 id="红黑树表示"><a href="#红黑树表示" class="headerlink" title="红黑树表示"></a>红黑树表示</h1><p>红黑树表示只用在BST中加入一个用来表明链的颜色的变量就行了。默认空链是黑色，我们把颜色加在node节点的属性中，通过查找孩子的node节点颜色，我们就知道指向这个节点的链的颜色了。</p>
<p><img src="http://img.hksite.cn/1464084309078" alt></p>
<pre><code class="java">private static final boolean RED   = true;
 private static final boolean BLACK = false;
 private class Node
 {
    Key key;
    Value val;
    Node left, right;
    boolean color;   
// color of parent link
 }
 private boolean isRed(Node x)
 {
    if (x == null) return false;
    return x.color == RED;
 }</code></pre>
<h1 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h1><h2 id="左旋操作"><a href="#左旋操作" class="headerlink" title="左旋操作"></a>左旋操作</h2><p>这个操作用来修正因任何情况导致红链出现在右边的情况。操作主要步骤：</p>
<ol>
<li>h的右孩子变成x的左孩子，h变成红色</li>
<li>x的左孩子变成h，x变成黑色</li>
<li>x作为新的子链返回</li>
</ol>
<p><img src="http://img.hksite.cn/1464084318192" alt></p>
<p><img src="http://img.hksite.cn/1464084323247" alt></p>
<pre><code class="java">public Node rotateLeft(Node h)
{
    assert isRed(h.right);
    Node x = h.right;
    h.right = x.left;   //step 1
    x.left = h;        //step 2
    x.color = h.color;
    h.color = RED;
    return x;     //setp 3
}</code></pre>
<h2 id="右旋操作"><a href="#右旋操作" class="headerlink" title="右旋操作"></a>右旋操作</h2><p>和左旋操作差不多，只是方向变了</p>
<ol>
<li>h的左孩子变成x的右孩子，h变成红色</li>
<li>x的右孩子变成h，x变成黑色</li>
<li>x作为新的子链返回</li>
</ol>
<pre><code class="java">    public Node rotateRight(Node h)
    {
        assert isRed(h.left);
        Node x = h.left;
        h.left = x.right;   //step 1
        x.right = h;        //step 2
        x.color = h.color;
        h.color = RED;
        return x;     //setp 3
    }</code></pre>
<h2 id="颜色翻转"><a href="#颜色翻转" class="headerlink" title="颜色翻转"></a>颜色翻转</h2><p>操作实现也比较简单，因为4节点的实现还是用的二叉树，我们只用把链的颜色改变就行了。</p>
<pre><code class="java">private void flipColors(Node h)
{
    assert !isRed(h);
    assert isRed(h.left);
    assert isRed(h.right);
    h.color = RED;
    h.left.color = h.right.color = BLACK;
}</code></pre>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><h3 id="插入只有1个节点的树"><a href="#插入只有1个节点的树" class="headerlink" title="插入只有1个节点的树"></a>插入只有1个节点的树</h3><ul>
<li>如果是插入左边，那么比较简单，直接是插入操作加上把节点改成红色就行了</li>
<li>如果是插入右边，那么需要做一个左旋操作。</li>
</ul>
<p><img src="http://img.hksite.cn/1464084738110" alt></p>
<h3 id="插入底部的一个2-节点"><a href="#插入底部的一个2-节点" class="headerlink" title="插入底部的一个2-节点"></a>插入底部的一个2-节点</h3><ul>
<li><p>和第一种情况一样</p>
<p><img src="http://img.hksite.cn/1464084743817" alt></p>
</li>
</ul>
<h3 id="插入只有2个节点的树"><a href="#插入只有2个节点的树" class="headerlink" title="插入只有2个节点的树"></a>插入只有2个节点的树</h3><ol>
<li>如果比它们都大，则插入最右边，形成4-节点，进行颜色翻转， 就行了</li>
<li>如果比它们都小，则插入最左边，这时候中间节点有2条红链，进行右旋操作， 和1就一样了</li>
<li>如果在它们之间，则插入左边节点的右侧，这时候，要进行左旋，就和2一样了。</li>
</ol>
<p><img src="http://img.hksite.cn/1464084748800" alt></p>
<h3 id="插入底部的一个3-节点"><a href="#插入底部的一个3-节点" class="headerlink" title="插入底部的一个3-节点"></a>插入底部的一个3-节点</h3><ul>
<li>和上面一样，颜色翻转后，在逐层往上检查是不是有需要调整的地方（旋转，颜色翻转）</li>
</ul>
<p><img src="http://img.hksite.cn/1464084768514" alt></p>
<p><img src="http://img.hksite.cn/1464084776157" alt></p>
<h2 id="插入总结"><a href="#插入总结" class="headerlink" title="插入总结"></a>插入总结</h2><p>其实所有的插入操作，可以归结为下面三种：</p>
<ol>
<li>右红，左黑：左旋</li>
<li>左红，左孩左红：右旋</li>
<li>双孩子红：颜色翻转</li>
</ol>
<h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><pre><code class="java">private Node put(Node h, Key key, Value val) 
 {
        /******原插入代码*******/
        if (h == null) 
            return new Node(key, val, RED);
        int cmp = key.compareTo(h.key);
        if (cmp &lt; 0) {
            h.left = put(h.left, key, val);
        } else if (cmp &gt; 0) {
            h.right = put(h.right, key, val);
        } else if (cmp == 0) {
            h.val = val;
        }
        h.count = 1 + size(h.left) + size(h.right);
        /******情形1*******/
        if (isRed(h.right) &amp;&amp; !isRed(h.left)) 
            h = rotateLeft(h);
        /******情形2*******/
        if (isRed(h.left) &amp;&amp; isRed(h.left.left))
            h = rotateRight(h);
        /******情形3*******/
        if (isRed(h.left) &amp;&amp; isRed(h.right))
            flipColors(h);
        return h;
   }</code></pre>
<h1 id="红黑树构造动画"><a href="#红黑树构造动画" class="headerlink" title="红黑树构造动画"></a>红黑树构造动画</h1><p>讲了这么多，我们来看看一棵红黑树到底如何构造出来的吧，通过通话来加深理解。</p>
<p><img src="http://img.hksite.cn/1464085260522" alt></p>
<h1 id="红黑树性能分析"><a href="#红黑树性能分析" class="headerlink" title="红黑树性能分析"></a>红黑树性能分析</h1><p>所有基于红黑树的符号表实现都保证操作的运行时间为对数级别！</p>
<p><img src="http://img.hksite.cn/1464084783174" alt></p>
<p>因为，不论插入的顺序如何，红黑树都几乎是完美平衡的</p>
<p>不管是在随机情况下</p>
<p><img src="http://img.hksite.cn/1464085919633" alt></p>
<p>还是在最坏的情况下，红黑树的深度也不会超过2logN</p>
<p><img src="http://img.hksite.cn/1464144485406" alt></p>
<p>红黑树更吸引人的一点在于，基本除了put和delete算法比较复杂，其他的代码，都可以直接使用二叉树的代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-符号表介绍和API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-符号表介绍和API/" itemprop="url">符号表介绍和API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本系列文章主要介绍常用的算法和数据结构的知识，记录的是《Algorithms I/II》课程的内容，采用的是“算法（第4版）”这本红宝书作为学习教材的，语言是java。这本书的名气我不用多说吧？豆瓣评分9.4，我自己也认为是极好的学习算法的书籍。通过这系列文章，可以加深对数据结构和基本算法的理解（个人认为比学校讲的清晰多了），并加深对java的理解。</p>
</blockquote>
<h1 id="1-符号表介绍和API"><a href="#1-符号表介绍和API" class="headerlink" title="1 符号表介绍和API"></a><strong>1 符号表介绍和API</strong></h1><h2 id="1-1-符号表介绍"><a href="#1-1-符号表介绍" class="headerlink" title="1.1 符号表介绍"></a><strong>1.1 符号表介绍</strong></h2><blockquote>
<p>符号表（Symbol Table）是一个非常常见的数据结构，在现实生活中应用很多。它是一个“键”—“值”对应的结构。在符号表中，存储的是键值对。通过输入键，查询对应的值。</p>
</blockquote>
<p>这个基础的数据结构，在现实生活中使用的特别多，比如字典。</p>
<p><img src="http://img.hksite.cn/2019-03-01-064437.jpg" alt></p>
<h2 id="1-2-符号表API"><a href="#1-2-符号表API" class="headerlink" title="1.2 符号表API"></a><strong>1.2 符号表API</strong></h2><p>其实符号表的操作，也无非就是增删改查之类的</p>
<table>
<thead>
<tr>
<th><strong>函数名</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ST()</strong></td>
<td>创建一个符号表对象</td>
</tr>
<tr>
<td><strong>void Put(Key key, Value val)</strong></td>
<td>往集合中插入一条键值对记录，如果value为空，不添加</td>
</tr>
<tr>
<td><strong>Value Get(Key key)</strong></td>
<td>根据key查找value，如果没找到返回null</td>
</tr>
<tr>
<td><strong>void Delete(Key key)</strong></td>
<td>删除键为key的记录</td>
</tr>
<tr>
<td><strong>boolean Contains(Key key)</strong></td>
<td>判断集合中是否存在键为key的记录</td>
</tr>
<tr>
<td><strong>boolean IsEmpty()</strong></td>
<td>判断查找表是否为空</td>
</tr>
<tr>
<td><strong>int Size()</strong></td>
<td>返回集合中键值对的个数</td>
</tr>
<tr>
<td><strong>Iterable Keys()</strong></td>
<td>返回集合中所有的键</td>
</tr>
</tbody></table>
<p>Ps.有一些约定要提前说一下</p>
<ul>
<li>值不为null - 如果key不存在，get()返回为null </li>
<li>put()会覆盖旧值</li>
</ul>
<p>通过这几个约定，我们可以把contain和delete函数简单实现。</p>
<pre><code>public boolean contains(Key key)
{  return get(key) != null;  }

public void delete(Key key)
{  put(key, null);  }</code></pre><h1 id="2-键和值的约定"><a href="#2-键和值的约定" class="headerlink" title="2 键和值的约定"></a><strong>2 键和值的约定</strong></h1><h2 id="2-1-值（value）"><a href="#2-1-值（value）" class="headerlink" title="2.1 值（value）"></a><strong>2.1 值（value）</strong></h2><p>在java中如果我们想要实现一个符号表，我们希望它是支持所有泛型的。</p>
<h2 id="2-2-键-Key"><a href="#2-2-键-Key" class="headerlink" title="2.2 键(Key)"></a><strong>2.2 键(Key)</strong></h2><p>对于键的，我们希望：</p>
<ul>
<li>Key是可比较的，即是<code>Comparable</code>的，并且使用<code>compareTo()</code>函数</li>
<li>Key是泛型的</li>
<li>能用<code>equals()</code>判断相等，能用<code>hashCode()</code>获取键（这两个函数都是java的内置函数）</li>
<li>对于Key最好是使用不可变的类型(Integer,Double, String之类的)</li>
</ul>
<h1 id="3-相等性测试"><a href="#3-相等性测试" class="headerlink" title="3 相等性测试"></a><strong>3 相等性测试</strong></h1><p>如果我们提到了</p>
<p><code>equals()</code></p>
<p>函数，就不得不提提java的相等性测试，Java要求</p>
<p><code>equals()</code></p>
<p>满足：</p>
<ul>
<li><strong>自反性：</strong> x.equals(x) is true</li>
<li><strong>对称性：</strong> x.equals(y) iff y.equals(x)</li>
<li><strong>传递性：</strong> if x.equals(y) and y.equals(z), then x.equals(z)</li>
<li><strong>不为null：</strong> x.equals(null) is false</li>
</ul>
<p>一般来说，我们做判断使用的( x == y ) 这个式子并不做类型检查。所以，我们在实现equals()的时候，要特别注意，它看起来很简单，但是想实现完美比较麻烦。</p>
<p>比如一个日期的class，你可能会这样实现<code>equals()</code></p>
<pre><code class="java">public class Date implements Comparable&lt;Date&gt;
{
   private final int month;
   private final int day;
   private final int year;
   ...
   public boolean equals(Date that)
   {
      if (this.day   != that.day  ) return false;
      if (this.month != that.month) return false;
      if (this.year  != that.year ) return false;
      return true;
   }
}</code></pre>
<p>但是你如果这样实现会更好：</p>
<ul>
<li>用<code>final</code>字段，不然可能会违反对称性（继承）</li>
<li>最好用<code>Object</code>,(不过这个专家们目前还在激烈争论中)</li>
<li>加入自反性，不为null的判断，并且验证类型一致性。</li>
<li>关于比较一个类中的不同变量：<ul>
<li>如果比较的是一个原始类型，用==</li>
<li>如果比较的是一个对象，用equals()</li>
<li>如果比较的是一个数组，对Arrays.equals(a, b)，而不是a.equals(b)</li>
</ul>
</li>
</ul>
<pre><code class="java">    public final class Date implements Comparable&lt;Date&gt;
    {
       private final int month;
       private final int day;
       private final int year;
       ...
       public boolean equals(Object y)
       {
          if (y == this) return true;
          if (y == null) return false;
          if (y.getClass() != this.getClass())
             return false;
          Date that = (Date) y;
          if (this.day   != that.day  ) return false;
          if (this.month != that.month) return false;
          if (this.year  != that.year ) return false;
          return true;
       }
    }</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-浏览器渲染/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-浏览器渲染/" itemprop="url">浏览器渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- toc orderedList:0 depthFrom:1 depthTo:6 -->

<ul>
<li><a href="#浏览器渲染">浏览器渲染</a><ul>
<li><a href="#谷歌开发者工具">谷歌开发者工具</a></li>
<li><a href="#浏览器加载-解析与渲染">浏览器加载、解析与渲染</a></li>
<li><a href="#关键渲染路径">关键渲染路径</a></li>
<li><a href="#javascript异步加载">javascript异步加载</a><ul>
<li><a href="#defer属性">defer属性</a></li>
<li><a href="#async">async</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h1><h2 id="谷歌开发者工具"><a href="#谷歌开发者工具" class="headerlink" title="谷歌开发者工具"></a>谷歌开发者工具</h2><p><img src="C:/Users/Administrator/Desktop/My-study-records-master/HTML5/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93.jpg" alt></p>
<p>Timeline</p>
<ol>
<li><p>控制条:<br>开始记录，停止记录<br>配置记录期间捕获的信息。</p>
</li>
<li><p>总览:<br>页面性能高级汇总</p>
</li>
<li><p>火焰图:<br>CPU 堆叠追踪的可视化</p>
</li>
<li><p>详情:<br>每个CPU任务的详细报告</p>
</li>
</ol>
<h2 id="浏览器加载、解析与渲染"><a href="#浏览器加载、解析与渲染" class="headerlink" title="浏览器加载、解析与渲染"></a>浏览器加载、解析与渲染</h2><ol>
<li>HTML代码转化为DOM,DOM是增量构建的，不需要等整个文档下载完才可以构建DOM树。</li>
<li>CSS代码转化成CSSOM（CSS Object Model）。</li>
<li>DOM 和 CSSOM 合并后生成 <code>Render Tree</code>(Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点）</li>
<li>Render Tree（渲染树）构建完毕之后，进入“布局（layout）”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。这就被称为<code>reflow</code>或者是<code>layout</code>又或者是<code>layouting</code>。</li>
<li>最后，浏览器会在屏幕上绘制（paint）节点。</li>
</ol>
<p>衍生的问题解析：</p>
<ol>
<li>HTML是解析一部分，显示一部分的。</li>
<li><code>&lt;script&gt;</code>标签会阻塞文档的解析，直到脚本执行完毕。如果脚本是外部的，需等到脚本下载并执行完成才继续往下解析。</li>
<li>css不会阻止HTML解析，但CSS还没有加载完时会阻碍HTML渲染与JavaScript脚本运行。</li>
<li>图片资源是异步请求的，图片既不阻塞解析，也不阻塞渲染。</li>
<li>屏幕的变化称为<code>repaint</code>或者<code>redraw</code>。</li>
</ol>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000007766425#articleHeader4" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007766425#articleHeader4</a></li>
<li><a href="https://segmentfault.com/a/1190000006917754" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006917754</a></li>
</ol>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/HTML5/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93_2.jpg" alt></p>
<p>文档的渲染还是要等待顶层css加载完毕。</p>
<h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h2><pre><code class="html">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Understanding the Critical Rendering Path&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;header&gt;
      &lt;h1&gt;Understanding the Critical Rendering Path&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
      &lt;h2&gt;Introduction&lt;/h2&gt;
      &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
      &lt;small&gt;Copyright 2017&lt;/small&gt;
  &lt;/footer&gt;
  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/HTML5/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93_3.jpg" alt></p>
<ol>
<li>发送请求：发送GET请求index.html</li>
<li>解析HTML然后发送请求：开始解析HTML并构建DOM，然后发送GET请求style.css和main.js。</li>
<li>解析样式表：根据style.css生成CSSOM</li>
<li>执行计算脚本：执行main.js</li>
<li>布局：基于HTML的元视窗标签，生成布局</li>
<li>绘制页面：绘制网页</li>
</ol>
<blockquote>
<p>参考：<br><a href="https://github.com/lx7575000/Translation/blob/master/%EF%BC%88%E8%AF%91%EF%BC%89%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84/%EF%BC%88%E8%AF%91%EF%BC%89%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84.md" target="_blank" rel="noopener">理解浏览器的关键渲染路径</a></p>
</blockquote>
<h2 id="javascript异步加载"><a href="#javascript异步加载" class="headerlink" title="javascript异步加载"></a>javascript异步加载</h2><h3 id="defer属性"><a href="#defer属性" class="headerlink" title="defer属性"></a>defer属性</h3><ul>
<li>当script标签拥有defer属性时，该脚本会被推迟到整个HTML文档解析完后，再开始执行</li>
<li>被defer的脚本，在执行时会严格按照在HTML文档中出现的顺序执行</li>
</ul>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><ul>
<li>当script标签拥有async属性时，该脚本不会再阻塞HTML parser。且不会被CSS阻塞。</li>
<li>脚本<strong>只要加载完成</strong>，便可开始执行。</li>
<li>被async的脚本，在执行时<strong>不会</strong>严格按照在HTML文档中出现的顺序执行</li>
<li>async适用于无依赖的独立资源</li>
</ul>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/HTML5/img/asyncAndDefer.jpg" alt="asyncAndDefer"></p>
<blockquote>
<p><a href="https://ppt.baomitu.com/d/258e0812#/57" target="_blank" rel="noopener">https://ppt.baomitu.com/d/258e0812#/57</a></p>
</blockquote>
<h2 id="浏览器重绘与回流"><a href="#浏览器重绘与回流" class="headerlink" title="浏览器重绘与回流"></a>浏览器重绘与回流</h2><p>当<code>render tree</code>中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建，称为<strong>回流(reflow)</strong> 。<br>当页面布局和集合属性改变，会出发回流。</p>
<p>当<code>render tree</code>中的一些元素需要重新更新属性，而这些属性只是影响元素外观、风格，不会影响布局的修改(如background-color)，称为<strong>重绘(repaint)</strong>。</p>
<h2 id="渲染的名词"><a href="#渲染的名词" class="headerlink" title="渲染的名词"></a>渲染的名词</h2><h3 id="Parse-Html"><a href="#Parse-Html" class="headerlink" title="Parse Html"></a>Parse Html</h3><p>发送一个http请求，获取请求的内容，然后解析HTML的过程。</p>
<h3 id="Recalculate-Style"><a href="#Recalculate-Style" class="headerlink" title="Recalculate Style"></a>Recalculate Style</h3><p>此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 <code>&lt;body&gt;</code> 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</p>
<blockquote>
<p>Layout后一般存在一个<code>Update Layer Tree</code>的过程。</p>
</blockquote>
<h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>页面上显示东西有任何变动都会触发Paint。本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。<code>Paint</code>一般是在多个层上完成的。</p>
<h3 id="Composite-Layers"><a href="#Composite-Layers" class="headerlink" title="Composite Layers"></a>Composite Layers</h3><p>最后合并图层，输出页面到屏幕。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-算法排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-算法排序/" itemprop="url">算法排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- @import "[TOC]" {cmd:"toc", depthFrom:1, depthTo:6, orderedList:false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#算法排序">算法排序</a><ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#插入排序">插入排序</a><ul>
<li><a href="#直接插入排序">直接插入排序</a></li>
<li><a href="#二分插入排序">二分插入排序</a></li>
<li><a href="#希尔排序">希尔排序</a></li>
</ul>
</li>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#快速排序">快速排序</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->

<h1 id="算法排序"><a href="#算法排序" class="headerlink" title="算法排序"></a>算法排序</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>空间分类：</p>
<ul>
<li>原地排序：辅助空间用量为O(l)的排序方法；</li>
<li>非原地排序：辅助空间用量超过O(l)的排序方法；</li>
</ul>
<p>按稳定性分类：</p>
<ul>
<li>稳定排序：能够使任何数值相等的元素，排序以后次序不变的方法；</li>
<li>非稳定排序：不是稳定排序的方法；</li>
</ul>
<blockquote>
<p>稳定性只对结构类型数据排序有意义。</p>
</blockquote>
<p>按自然性分类：</p>
<ul>
<li>自然排序：输入的数据越有序，排序的速度越快的排序方法；</li>
<li>非自然排序：不是自然排序的方法；</li>
</ul>
<p>按数据存储介质：内部排序和外部排序；<br>按比较器个数：串行排序和并行排序<br>按主要操作：比较排序和基数排序</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序种类：</p>
<ol>
<li>直接插入排序</li>
<li>二分插入排序</li>
<li>希尔排序</li>
</ol>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul>
<li>原始数据越接近有序，排序速度越快</li>
<li>最坏情况下（输入数据是逆有序的）TW(n)=O(n2)</li>
<li>平均情况下，耗时差不多是最坏情况的一半TE(n)=(n2)</li>
<li>为提高排序速度，要<ul>
<li>减少元素的比较次数</li>
<li>减少元素的移动次数直接插入排序</li>
</ul>
</li>
</ul>
<h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><p>在有序部分使用二分定位的方法比较</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul>
<li>缩小增量</li>
<li>多遍插入排序</li>
</ul>
<blockquote>
<p>例如选用增量序列（9，5，3，1），进行4遍插入排序</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/shell-1.jpg" alt="希尔排序"><br><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/shell-2.jpg" alt="希尔排序"><br><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/shell-3.jpg" alt="希尔排序"><br><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/shell-4.jpg" alt="希尔排序"><br><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/shell-5.jpg" alt="希尔排序"></p>
<blockquote>
<p>图片来自<a href="http://www.icourse163.org/course/UST-1001660013#/info" target="_blank" rel="noopener">解放军理工大学慕课</a></p>
</blockquote>
<p>这种算法先比较部分的先后次序，再比较整体。<br>算法的时间复杂度与增量序列有关，计算公式为：</p>
<pre><code class="js">O(n3/2),O(n(logn)2)</code></pre>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本原理：反复扫描待排序列，若相邻元素构成逆序，则交换它们，直至无逆序为止。</p>
<p>所以一次扫描，可以令最大的数或者最小的数排在最前或者最后。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/maopao.jpg" alt="maopao.jpg"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>也称划分交换排序，原理是反复进行有序划分。<br>一般先选定一个数（一般为第一个），以后的数，比它大的放一边，比它小的放另一边。然后递归排序，完成排序</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/MOOC/img/kuaisu.jpg" alt="kuaisu.jpg"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>算法思想：</p>
<ul>
<li>把元素按照接近平均的方式拆分成最少的单元</li>
<li>相邻的两个元素比较大小，并归并成一个元素</li>
<li>直到长度为n的有序表</li>
</ul>
<p>动画效果：</p>
<p><img src="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md#3-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA" alt="动画效果"></p>
<p>javascript实现代码</p>
<pre><code class="js">function mergeSort(arr) {  // 采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];

    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}</code></pre>
<blockquote>
<p>参考：<a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">190</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
