<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Fey&#39;s blog">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/page/31/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fey&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/page/31/">





  <title>Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Cookie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Cookie/" itemprop="url">Cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="cookie使用函数"><a href="#cookie使用函数" class="headerlink" title="cookie使用函数"></a>cookie使用函数</h1><pre><code class="js">function setCookie(name, value, iDay)
{
    var oDate=new Date();
    oDate.setDate(oDate.getDate()+iDay);

    document.cookie=name+&#39;=&#39;+value+&#39;;expires=&#39;+oDate;
}

function getCookie(name)
{
    var arr=document.cookie.split(&#39;; &#39;);

    for(var i=0;i&lt;arr.length;i++)
    {
        var arr2=arr[i].split(&#39;=&#39;);

        if(arr2[0]==name)
        {
            return arr2[1];
        }
    }

    return &#39;&#39;;
}

function removeCookie(name)
{
    setCookie(name, 1, -1);
}</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-CommonJs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-CommonJs/" itemprop="url">CommonJs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>CommonJS</strong>规范中，每个模块可以是一个文件，一个文件也可以就是一个函数。<br>所以每个模块就是一个单独的作用域。</p>
<pre><code class="js">// example.js
var x = 5;
var addX = function(value) {
  return value + x;
};</code></pre>
<pre><code>global.warning = true;</code></pre><p><strong>global</strong>对象可以在多个文件分享，但不建议使用。</p>
<p><strong>CommonJS</strong>规定，每个文件的对外接口是<strong>module.exports</strong>对象。</p>
<pre><code class="js">var x = 5;
var addX = function(value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;</code></pre>
<p>在另一个文件，可以利用<code>require</code>对象加载这个文件，</p>
<pre><code class="js">var example = require(&#39;./example.js&#39;);

console.log(example.x); // 5
console.log(example.addX(1)); // 6</code></pre>
<p><strong>CommonJS</strong>的特点：</p>
<ul>
<li>所有模块都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就会被缓存，以后再加载都是读取缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<p><strong>CommonJS</strong>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>内置的<code>require</code>命令用于加载模块文件。</p>
<p><code>require</code>命令的基本功能是，读入并执行一个<code>JavaScript</code>文件，然后返回该模块的exports对象。</p>
<p>如果模块输出的是一个函数，那就不能定义在<code>exports</code>对象上面，而要定义在<code>module.exports</code>变量上面。</p>
<pre><code class="js">module.exports = function () {
  console.log(&quot;hello world&quot;)
}
//如何module.exports还有其他子对象，将会给覆盖，不建议这样使用。


//另一个文件
require(&#39;./example2.js&#39;)()</code></pre>
<blockquote>
<p><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html</a>  </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-CSS2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-CSS2/" itemprop="url">CSS2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2016年4月1日"><a href="#2016年4月1日" class="headerlink" title="2016年4月1日"></a>2016年4月1日</h1><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>对象的<code>constructor</code>属性用于返回创建该对象的函数，也就是我们常说的<strong>构造函数</strong>。</p>
<pre><code class="js">// 字符串：String()
var str = &quot;张三&quot;;
document.writeln(str.constructor); // function String() { [native code] }
document.writeln(str.constructor === String); // true

// 数组：Array()
var arr = [1, 2, 3];
document.writeln(arr.constructor); // function Array() { [native code] }
document.writeln(arr.constructor === Array); // true

// 数字：Number()
var num = 5;
document.writeln(num.constructor); // function Number() { [native code] }
document.writeln(num.constructor === Number); // true

// 自定义对象：Person()
function Person(){
    this.name = &quot;CodePlayer&quot;;
}
var p = new Person();
document.writeln(p.constructor); // function Person(){ this.name = &quot;CodePlayer&quot;; }
document.writeln(p.constructor === Person); // true

// JSON对象：Object()
var o = { &quot;name&quot; : &quot;张三&quot;};
document.writeln(o.constructor); // function Object() { [native code] }
document.writeln(o.constructor === Object); // true

// 自定义函数：Function()
function foo(){
    alert(&quot;CodePlayer&quot;);
}
document.writeln(foo.constructor); // function Function() { [native code] }
document.writeln(foo.constructor === Function); // true

// 函数的原型：bar()
function bar(){
    alert(&quot;CodePlayer&quot;);
}
document.writeln(bar.prototype.constructor); // function bar(){ alert(&quot;CodePlayer&quot;); }
document.writeln(bar.prototype.constructor === bar); // true</code></pre>
<blockquote>
<p>代码中的<code>[native code]</code>这是JavaScript的底层内部代码实现，无法显示代码细节。</p>
</blockquote>
<p>[TOC]</p>
<h1 id="2016年4月4日"><a href="#2016年4月4日" class="headerlink" title="2016年4月4日"></a>2016年4月4日</h1><h2 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h2><pre><code class="js">$scope.$watch($scope.sum,function(newVal,oldVal){
        //console.log(newVal);
        //console.log(oldVal);

        $scope.iphone.fre = newVal &gt;= 100 ? 0 : 10;

    });</code></pre>
<p>三个参数：<br>第一个是监听的参数，第二个触发时执行的函数，有两个参数，旧值以及新值；第三个是为<strong>true</strong>时整体监听。</p>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,function($scope){
    $scope.name = &#39;hello&#39;;
});

//上下意思一样
var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($s){
    $s.name = &#39;hello&#39;;
}]);</code></pre>
<ul>
<li>angular.bind()</li>
</ul>
<p>改变this的指向。</p>
<ul>
<li>angular.copy()</li>
</ul>
<p>拷贝对象。</p>
<pre><code>var c=angular.copy(a,b);</code></pre><p>a全部拷贝覆盖b；</p>
<ul>
<li>angular.extend()</li>
</ul>
<p>拷贝继承，不覆盖。</p>
<ul>
<li>angular.equals()</li>
</ul>
<p>判读两个变量是否相等。</p>
<ul>
<li>angular.forEach</li>
</ul>
<p>遍历循环</p>
<pre><code class="js">var values = {&#39;name&#39;:&#39;hello&#39;,&#39;age&#39;:&#39;20&#39;};
var result = [];
angular.forEach(values,function(value,i){
    //console.log(value);
    //console.log(i);
    this.push( value + i );
},result);
console.log(result);</code></pre>
<ul>
<li>angular.identity/noop()</li>
</ul>
<p>返回调用的参数。</p>
<pre><code class="js">var str = &#39;hello&#39;;
console.log(angular.identity(str));  //hello</code></pre>
<ul>
<li>angular.lowercase/uppercase()</li>
</ul>
<p>字符串转成大写或者小写。</p>
<ul>
<li>angular.element()</li>
</ul>
<pre><code class="js">var oDiv = document.getElementById(&#39;div1&#39;);

angular.element(&#39;#div1&#39;).css(&#39;background&#39;,&#39;red&#39;);</code></pre>
<p>可以进一步使用jQuery的方式调用。</p>
<ul>
<li>动态初始化</li>
</ul>
<pre><code class="js">var m1=angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){
    $scope.name = &#39;hello&#39;;
}]);

document.onclick=function(){
    angular.bootstrap(document,[&#39;myApp&#39;]);
}

&lt;div ng-controller=&quot;Aaa&quot;&gt;
    &lt;div&gt;{{name}}&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>点击后显示。</p>
<ul>
<li>angular.injector()</li>
</ul>
<p>注册器，内部使用。</p>
<p>低分段</p>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>使用语义化方式为CSS命名可以像这样:</p>
<pre>
    container{…}
/*—- Top section —-*/
    #header{…}
    #navbar{…}
    /*—- Main —-*/
    #menu{…}
    #main{…}
    #sidebar{…}
    /*—- Footer —-*/
    #footer{…}

</pre>

<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/css-01.jpg" alt></p>
<blockquote>
<p><a href="http://blog.bingo929.com/CSS-coding-semantic-naming.html" target="_blank" rel="noopener">http://blog.bingo929.com/CSS-coding-semantic-naming.html</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="2016年4月5日"><a href="#2016年4月5日" class="headerlink" title="2016年4月5日"></a>2016年4月5日</h1><h2 id="angularjs-1"><a href="#angularjs-1" class="headerlink" title="angularjs"></a>angularjs</h2><ul>
<li>$scope.$apply()</li>
</ul>
<pre><code class="js">function Aaa($scope){
    $scope.name = &#39;hello&#39;;
    setTimeout(function(){
        $scope.$apply(function(){
            $scope.name = &#39;hi&#39;;
        });
    },2000);

    //另一种写法
    //
    setTimeout(function(){
        $scope.name = &#39;BBR&#39;;
        $scope.$apply();        
    },2000);
}</code></pre>
<p>这个方法监听数据有没有变化，当数据发生变化，就会影响视图。</p>
<ul>
<li>angular.module<ul>
<li>controller //方法</li>
<li>run<ul>
<li>不引入控制器，挂载全局变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);

m1.run([&#39;$rootScope&#39;,function($rootScope){
    $rootScope.name = &#39;hello&#39;;
}]);</code></pre>
<blockquote>
<p>只能挂载全局作用域变量，不能调用局部变量。</p>
</blockquote>
<ul>
<li>过滤器/ currency</li>
</ul>
<pre><code class="js">&lt;script&gt;

var m1 = angular.module(&#39;myApp&#39;,[]);

/*自定义过滤器*/
/*m1.filter(&#39;firstUpper&#39;,function(){
    return function(str,num){//通过return返回过滤后的结果
        //console.log(num);//传参
        return str.charAt(0).toUpperCase() + str.substring(1);
    }
});*/

m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,&#39;$filter&#39;,function($scope,$filter){

    $scope.name = &#39;723894734.7489545&#39;;
    //$scope.name = &#39;hello&#39;;
    //$scope.name = {&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:&quot;20&quot;};
    //$scope.name = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];
    //$scope.name = &#39;3748935795&#39;;

    /*$scope.name = [
        {color:&quot;red&quot;,age:&quot;20&quot;},
        {color:&quot;yellow&quot;,age:&quot;30&quot;},
        {color:&quot;blue&quot;,age:&quot;40&quot;},
        {color:&quot;green&quot;,age:&quot;10&quot;}
    ];*/

    //$scope.name = $filter(&#39;uppercase&#39;)(&#39;hello&#39;);
    //$scope.name = $filter(&#39;number&#39;)(&#39;236478234.3647348&#39;,1);//转数字，限制一位。
    // $scope.name = $filter(&#39;date&#39;)(&#39;2364782342&#39;);//Jan 28, 1970

    // $scope.name = &#39;hello&#39;;
    // 
    //$scope.name = $filter(&#39;firstUpper&#39;)(&#39;hello&#39;);


}]);



&lt;/script&gt;
&lt;/head&gt;</code></pre>
<pre><code class="html">&lt;div ng-controller=&quot;Aaa&quot;&gt;

    &lt;!-- 前面调价符号 --&gt;
    &lt;!-- &lt;p&gt;{{name | currency:"￥"}}&lt;/p&gt; --&gt;

    &lt;!-- 保留一定长度的小数 --&gt;
    &lt;p&gt;{{ name | number : 3}}&lt;/p&gt;

    &lt;!-- 全部大写 --&gt;
    &lt;!--&lt;p&gt;{{ name | uppercase }}&lt;/p&gt;--&gt;

    &lt;!-- 以JSON格式展示数据 --&gt;
    &lt;!--&lt;pre&gt;{{ name | json }}&lt;/pre&gt;--&gt;

    &lt;!-- 截取前两位 --&gt;
    &lt;!--&lt;p&gt;{{ name | limitTo : 2 }}&lt;/p&gt;--&gt;

    &lt;!-- 日期展示格式 --&gt;
    &lt;!--&lt;p&gt;{{ name | date : 'yyyy' }}&lt;/p&gt;--&gt;

    &lt;!-- 排序,或者倒序 --&gt;
    &lt;!--&lt;p&gt;{{ name | orderBy : 'age' : true }}&lt;/p&gt;--&gt;

    &lt;!-- 过滤其他元素，只保留包含参数的字符串。 --&gt;
    &lt;!-- &lt;p&gt;{{ name | filter : 'l' }}&lt;/p&gt; --&gt;

    &lt;!-- &lt;p&gt;{{ name | limitTo : 2 | uppercase }}&lt;/p&gt; --&gt;
    &lt;!-- 截取一定长度数组或者字符串。 --&gt;

    &lt;!-- 自定义过滤器 --&gt;
    &lt;!--&lt;p&gt;{{ name | firstUpper : 2 }}&lt;/p&gt;--&gt;
    &lt;!-- &lt;p&gt;{{ name }}&lt;/p&gt; --&gt;
&lt;/div&gt;
</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月6日"><a href="#2016年4月6日" class="headerlink" title="2016年4月6日"></a>2016年4月6日</h1><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>每隔一个字母就变成大写。</p>
<pre><code class="js">function (str){
        var len=str.length;
        var arr=[];
        var newStr=&quot;&quot;;
        var cc=&quot;&quot;;
        for(var i=0;i&lt;len;i++){
            if(i%2==0){
                //str[i]=str[i].toUpperCase()
                cc+=newStr.concat(str[i].toUpperCase());
                //arr.push(str[i].toUpperCase());
            }else{
                //arr.push(str[i]);
                cc+=newStr.concat(str[i]);
            }
        }
        //strs=arr.join(&quot;&quot;);
        return cc;
    }</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月7日"><a href="#2016年4月7日" class="headerlink" title="2016年4月7日"></a>2016年4月7日</h1><h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><p>一下是一段流程图的语句，显示成代码形式的代表不支持markdown流程图解释。</p>
<pre><code class="flow">st=&gt;start: Start
e=&gt;end
op=&gt;operation: My Operation
cond=&gt;condition: Yes or No?

st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月11日"><a href="#2016年4月11日" class="headerlink" title="2016年4月11日"></a>2016年4月11日</h1><h2 id="angularjs-2"><a href="#angularjs-2" class="headerlink" title="angularjs"></a>angularjs</h2><p><strong>angularJs的指令</strong></p>
<ul>
<li>ng-disabled<ul>
<li>服务 $interval</li>
</ul>
</li>
<li>ng-readonly</li>
<li>ng-checked<ul>
<li>是否选中。</li>
</ul>
</li>
<li>ng-value<ul>
<li>input的value值，ng-value在没有加载数据，内容为空。</li>
</ul>
</li>
</ul>
<p><strong>数据加载显示指令</strong></p>
<ul>
<li>ng-bind</li>
</ul>
<pre><code class="html">&lt;div ng-bind=&quot;text&quot;&gt;&lt;/div&gt;
</code></pre>
<p>数据加载完再加载视图，但只支持一个表达式。</p>
<ul>
<li>ng-bind-template</li>
</ul>
<p>可以添加多表达式。</p>
<pre><code>&lt;div ng-bind-template=&quot;{{text}},{{text}}&quot;&gt;&lt;/div&gt;</code></pre><ul>
<li>ng-bind-html</li>
</ul>
<pre><code>//使用这个功能需要添加额外的插件。
    $scope.text = &#39;&lt;h1&gt;hello&lt;/h1&gt;&#39;;

//把字符串当做html文本来解释。
    &lt;div ng-bind-html=&quot;text&quot;&gt;&lt;/div&gt;</code></pre><ul>
<li>ng-cloak</li>
</ul>
<p>当这个指令还没有解释完成，就会隐藏，当解释完成才会显示出来。</p>
<pre><code>&lt; div ng-cloak &gt;{{text}}&lt; /div &gt;</code></pre><ul>
<li>ng-non-bindable</li>
</ul>
<p>不去解释这个表达式。</p>
<pre><code>&lt;div ng-non-bindable&gt;{{text}}&lt;/div&gt;</code></pre><p><strong>样式属性相关指令</strong></p>
<ul>
<li>ng-class</li>
<li>ng-style</li>
<li>ng-href</li>
<li>ng-src</li>
<li>ng-attr-(suffix)</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){
    $scope.text = &#39;hello&#39;;
    $scope.style = &quot;{color:&#39;red&#39;,background:&#39;yellow&#39;}&quot;;
    $scope.sClass = &quot;{red:true,yellow:true}&quot;;
    $scope.url = &quot;http://www.baidu.com&quot;;
}]);
</code></pre>
<pre><code class="html">&lt;style&gt;
.red{ background:red;}
.yellow{ background:yellow;}
&lt;/style&gt;

&lt;div ng-controller=&quot;Aaa&quot;&gt;
    &lt;div ng-class=&quot;{red:true}&quot;&gt;{{text}}&lt;/div&gt;
    &lt;div ng-class=&quot;{{sClass}}&quot;&gt;{{text}}&lt;/div&gt;

    &lt;div ng-style=&quot;{color:&#39;red&#39;,background:&#39;yellow&#39;}&quot;&gt;{{text}}&lt;/div&gt;
    &lt;div ng-style=&quot;{{style}}&quot;&gt;{{text}}&lt;/div&gt;

    &lt;a ng-href=&quot;{{url}}&quot;&gt;aaaaaaa&lt;/a&gt;
    &lt;a ng-href=&quot;{{'http://www.baidu.com'}}&quot;&gt;Baidu&lt;/a&gt;

    &lt;!-- 自定义属性前缀 --&gt;
    &lt;a ng-attr-href=&quot;{{url}}&quot; ng-attr-title=&quot;{{text}}&quot; ng-attr-class=&quot;&quot; ng-attr-style=&quot;&quot;&gt;aaaaaaa&lt;/a&gt;
    &lt;a ng-attr-href=&quot;{{url}}&quot; ng-attr-title=&quot;{{text}}&quot; ng-attr-class=&quot;&quot; ng-attr-style=&quot;&quot;&gt;aaaaaaa&lt;/a&gt;
&lt;/div&gt;</code></pre>
<p><strong>DOM相关操作指令</strong></p>
<ul>
<li>ng-show<ul>
<li>true为显示。</li>
</ul>
</li>
<li>ng-hide<ul>
<li>true为隐藏</li>
</ul>
</li>
<li>ng-if<ul>
<li>通过DOM添加或者删除这个标签。</li>
</ul>
</li>
<li>ng-swtich<ul>
<li>on</li>
<li>default<ul>
<li>首先显示默认的。</li>
</ul>
</li>
<li>when<ul>
<li>然后根据默认值变化切换。</li>
</ul>
</li>
</ul>
</li>
<li>ng-open<ul>
<li>针对details标签，</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){

    $scope.bBtn = true;

}]);
</code></pre>
<pre><code class="html">&lt;div ng-controller=&quot;Aaa&quot;&gt;
    &lt;input type=&quot;checkbox&quot; ng-model=&quot;bBtn&quot;&gt;
    &lt;div ng-show=&quot;bBtn&quot;&gt;aaaaaaaaaaaa&lt;/div&gt;
    &lt;div ng-if=&quot;bBtn&quot;&gt;aaaaaaaaaaaa&lt;/div&gt;
    &lt;div ng-switch on=&quot;bBtn&quot;&gt;
        &lt;p ng-switch-default&gt;默认的效果&lt;/p&gt;
        &lt;p ng-switch-when=&quot;false&quot;&gt;切换的效果&lt;/p&gt;
    &lt;/div&gt;

    &lt;details ng-open=&quot;bBtn&quot;&gt;
        &lt;summary&gt;Copyright 2011.&lt;/summary&gt;
        &lt;p&gt;All pages and graphics on this web site are the property of W3School.&lt;/p&gt;
    &lt;/details&gt;

&lt;/div&gt;</code></pre>
<p><strong>初始化数据指令</strong></p>
<ul>
<li>ng-init<ul>
<li>标签内定义一下数据。</li>
</ul>
</li>
</ul>
<pre><code class="html">div ng-controller=&quot;Aaa&quot; ng-init=&quot;text=&#39;hello&#39;&quot;&gt;
    {{ text }}
&lt;/div&gt;--&gt;</code></pre>
<pre><code class="html">&lt;div ng-controller=&quot;Aaa&quot;&gt;
    &lt;div ng-repeat=&quot;arrOuter in arr&quot; ng-init=&quot;outerIndex = $index&quot;&gt;
        &lt;div ng-repeat=&quot;arrInner in arrOuter&quot; ng-init=&quot;innerIndex = $index&quot;&gt;
            &lt;p&gt;{{arrInner}}:{{outerIndex}}{{innerIndex}}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>ng-include<ul>
<li>引入其他文件嵌套到当前页面。</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;Aaa&quot; ng-include=&quot;&#39;temp.html&#39;&quot;&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>ng-model<ul>
<li>ng-model-options</li>
<li>updateOn<ul>
<li>数据什么时候更新的一个选项，可以选择光标离开等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;input type=&quot;text&quot; ng-model=&quot;text&quot; ng-model-options=&quot;{updateOn : &#39;blur&#39;}&quot;&gt;
&lt;div&gt;{{text}}&lt;/div&gt;</code></pre>
<ul>
<li>ng-controller<ul>
<li>as<ul>
<li>绑定一个构造函数，然后在指令中可以创建一个对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,FnAaa]);

function FnAaa($scope){
}
FnAaa.prototype.num = &#39;123&#39;;
FnAaa.prototype.text = &#39;hello&#39;;
FnAaa.prototype.show = function(){
    return &#39;angularJS&#39;;
};</code></pre>
<pre><code class="html">&lt;div ng-controller=&quot;FnAaa as a1&quot;&gt;
    &lt;div&gt;{{a1.text}}:{{a1.show()}}&lt;/div&gt;
&lt;/div&gt;</code></pre>
<h1 id="2016年4月12日"><a href="#2016年4月12日" class="headerlink" title="2016年4月12日"></a>2016年4月12日</h1><h2 id="javascript-1"><a href="#javascript-1" class="headerlink" title="javascript"></a>javascript</h2><h3 id="document-write-和writeln区别"><a href="#document-write-和writeln区别" class="headerlink" title="document.write 和writeln区别"></a>document.write 和writeln区别</h3><p><strong>document.write()</strong>:将内容写入文档，当前编辑位置为写入的内容的后一个字符。<br><strong>document.writeln()</strong>:将内容写入文档，并添加一个换行符，当前编辑位置为写入的内容的后一行的的起始位置。 </p>
<pre><code class="js">with(window.open()){ 
document.write(&quot;百度&quot;)
document.write(&quot;百度&quot;)
document.write(&quot;百度&quot;)
document.writeln(&quot;知道&quot;)
document.writeln(&quot;知道&quot;)
document.writeln(&quot;知道&quot;)
} </code></pre>
<p><strong>效果</strong></p>
<pre><code>百度百度知道
知道
知道</code></pre><h3 id="for-in循环与for循环"><a href="#for-in循环与for循环" class="headerlink" title="for in循环与for循环"></a>for in循环与for循环</h3><p>*<em>for…in *</em>语句用于对数组或者对象的属性进行循环操作。</p>
<pre><code class="js">语法：
for (变量 in 对象)
{
    在此执行代码
}
</code></pre>
<p><strong>for循环</strong>是对数组的元素进行循环，而不能引用于非数组对象。</p>
<pre><code class="js">语法：
for(int 变量初始值;条件;递增或递减){
    在此执行代码
}</code></pre>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="Number函数"><a href="#Number函数" class="headerlink" title="Number函数"></a>Number函数</h4><blockquote>
<p>数值：转换后还是原来的值。</p>
</blockquote>
<blockquote>
<p>字符串：如果可以被解析为数值，则转换为相应的数值，否则得到NaN。空字符串转为0。</p>
</blockquote>
<blockquote>
<p>布尔值：true转成1，false转成0。</p>
</blockquote>
<blockquote>
<p>undefined：转成NaN。</p>
</blockquote>
<blockquote>
<p>null：转成0。</p>
</blockquote>
<pre><code class="js">Number(&quot;324&quot;) // 324

Number(&quot;324abc&quot;) // NaN

Number(&quot;&quot;) // 0

Number(false) // 0

Number(undefined) // NaN

Number(null) // 0</code></pre>
<h4 id="String函数：强制转换成字符串"><a href="#String函数：强制转换成字符串" class="headerlink" title="String函数：强制转换成字符串"></a>String函数：强制转换成字符串</h4><blockquote>
<p>数值：转为相应的字符串。</p>
</blockquote>
<blockquote>
<p>字符串：转换后还是原来的值。</p>
</blockquote>
<blockquote>
<p>布尔值：true转为“true”，false转为“false”。</p>
</blockquote>
<blockquote>
<p>undefined：转为“undefined”。</p>
</blockquote>
<blockquote>
<p>null：转为“null”。</p>
</blockquote>
<pre><code class="js">String(123) // &quot;123&quot;

String(&quot;abc&quot;) // &quot;abc&quot;

String(true) // &quot;true&quot;

String(undefined) // &quot;undefined&quot;

String(null) // &quot;null&quot;</code></pre>
<h4 id="Boolean函数：强制转换成布尔值"><a href="#Boolean函数：强制转换成布尔值" class="headerlink" title="Boolean函数：强制转换成布尔值"></a>Boolean函数：强制转换成布尔值</h4><blockquote>
<p>undefined<br>null<br>-0<br>+0<br>NaN<br>’‘（空字符串）</p>
</blockquote>
<pre><code class="js">Boolean(undefined) // false

Boolean(null) // false

Boolean(0) // false

Boolean(NaN) // false

Boolean(&#39;&#39;) // false</code></pre>
<h2 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h2><h3 id="标签指令"><a href="#标签指令" class="headerlink" title="标签指令"></a>标签指令</h3><ul>
<li>&lt; a&gt;<ul>
<li>会阻止默认行为</li>
</ul>
</li>
<li>&lt; select&gt;<ul>
<li>ng-options<ul>
<li>for   in</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;!-- 循环数组对象 --&gt;
&lt;select ng-options=&quot;names.name for names in colors&quot; ng-model=&quot;tn&quot;&gt;&lt;/select&gt;

&lt;!-- 循环数组 --&gt;
&lt;select ng-options=&quot;names for names in name&quot; ng-model=&quot;tn2&quot;&gt;&lt;/select&gt;


$scope.activities =
    [
        { id: 1, type: &quot;Work&quot;, name: &quot;Writing code&quot; },
        { id: 2, type: &quot;Work&quot;, name: &quot;Testing code&quot; },
        { id: 3, type: &quot;Work&quot;, name: &quot;Fixing bugs&quot; },
        { id: 4, type: &quot;Play&quot;, name: &quot;Dancing&quot; }
    ];        
&lt;select ng-model=&quot;engineer.currentActivity&quot; 
        data-ng-options=&quot;a.name group by a.type for a in activities&quot;&gt;                
&lt;/select&gt;</code></pre>
<p>必须要有<code>ng-model</code>,这样才能加载数据。</p>
<ul>
<li>&lt; textarea&gt;</li>
<li>&lt; input&gt;<ul>
<li>可以添加表单认证。</li>
</ul>
</li>
<li>&lt; form&gt;<ul>
<li>novalidate<ul>
<li>阻止表单默认的验证样式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ngularJs的表单验证"><a href="#ngularJs的表单验证" class="headerlink" title="ngularJs的表单验证"></a>ngularJs的表单验证</h3><p>表单验证通过才通过双向数据绑定刷新视图。</p>
<ul>
<li><p>$valid</p>
<ul>
<li>数据有效返回true</li>
</ul>
</li>
<li><p>$invalid</p>
<ul>
<li>数据无效返回true</li>
</ul>
</li>
<li><p>$pristine</p>
<ul>
<li>是否为原始值，是就返回true</li>
</ul>
</li>
<li><p>$dirty</p>
<ul>
<li>修改后返回true。</li>
</ul>
</li>
<li><p>$error</p>
<ul>
<li>验证失败就会返回错误信息。<ul>
<li><a href="http://www.cnblogs.com/rohelm/p/4033513.html" target="_blank" rel="noopener">http://www.cnblogs.com/rohelm/p/4033513.html</a></li>
</ul>
</li>
</ul>
</li>
<li><p>注意点</p>
<ul>
<li>name的方式进行查找</li>
<li>要写ng-model</li>
</ul>
</li>
<li><p>equired</p>
<ul>
<li>必填，false表示验证通过。</li>
</ul>
</li>
<li><p>g-minlength</p>
<ul>
<li>最小长度，通过为false。</li>
</ul>
</li>
<li><p>g-maxlength</p>
<ul>
<li>最大长度，通过为false。</li>
</ul>
</li>
<li><p>g-pattern</p>
<ul>
<li>匹配正则，通过为false。</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;form novalidate name=&quot;myForm&quot;&gt;
        &lt;input type=&quot;email&quot; name=&quot;myText&quot; ng-model=&quot;text&quot; required ng-minlength=&quot;5&quot; ng-pattern=&quot;/^[a-zA-Z]+$/&quot;&gt;
        &lt;div&gt; myForm.myText.$valid：{{ myForm.myText.$valid }}&lt;/div&gt;
        &lt;div&gt;myForm.myText.$invalid ：{{ myForm.myText.$invalid }}&lt;/div&gt;
        &lt;div&gt;myForm.myText.$pristine：{{ myForm.myText.$pristine }}&lt;/div&gt;
        &lt;div&gt; myForm.myText.$dirty ：{{ myForm.myText.$dirty }}&lt;/div&gt;
        &lt;div&gt;myForm.myText.$error ：{{ myForm.myText.$error }}&lt;/div&gt;
    &lt;/form&gt;</code></pre>
<ul>
<li>添加class<ul>
<li>.ng-valid{}</li>
<li>.ng-invalid{}</li>
<li>.ng-pristine{}</li>
<li>.ng-dirty{}</li>
</ul>
</li>
</ul>
<pre><code class="css">.txt.ng-valid{ border:1px green solid; background:#e55;}
.txt.ng-invalid{ border:1px red solid; background:blue;}</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月13日"><a href="#2016年4月13日" class="headerlink" title="2016年4月13日"></a>2016年4月13日</h1><h2 id="angularjs-3"><a href="#angularjs-3" class="headerlink" title="angularjs"></a>angularjs</h2><h3 id="angularJs的自定义指令"><a href="#angularJs的自定义指令" class="headerlink" title="angularJs的自定义指令"></a>angularJs的自定义指令</h3><ul>
<li>angular.module<ul>
<li>controller</li>
<li>run<ul>
<li>挂载全局的变量。</li>
</ul>
</li>
<li>filter</li>
<li>directive<ul>
<li>restrict的四种定义方式<ul>
<li>E 只限元素名使用</li>
<li>A 只限属性使用</li>
<li>C 只限类名使用<ul>
<li>必须设置 restrict 的值为 “C” 才能通过类名来调用指令。</li>
</ul>
</li>
<li>M 只限注释使用<ul>
<li>必须设置 restrict 的值为 “M” 才能通过注释来调用指令。</li>
<li>需要在该实例添加 replace 属性， 否则评论是不可见的。</li>
</ul>
</li>
<li>restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。</li>
</ul>
</li>
<li>replace</li>
<li>template</li>
<li>templateUrl</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;script&gt;

var m1 = angular.module(&#39;myApp&#39;,[]);
m1.directive(&#39;myHello&#39;,function(){
    return {
        restrict : &#39;AECM&#39;,   //区分大小写，而且是可以组合使用的
        replace : true,
        template : &#39;&lt;div&gt;hello angular&lt;/div&gt;&#39;
    };
});
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){
}]);
&lt;/script&gt;


&lt;my-hello&gt;&lt;/my-hello&gt;
&lt;p my-hello&gt;&lt;/p&gt;
&lt;p class=&quot;my-hello&quot;&gt;&lt;/p&gt;
&lt;!-- directive:my-hello --&gt;</code></pre>
<p>也可以引入外部文件：</p>
<pre><code class="js">m1.directive(&#39;myTab&#39;,function(){
    return {
        restrict : &#39;E&#39;,   
        replace : true,
        templateUrl : &#39;temp2.html&#39;
    };
});</code></pre>
<ul>
<li>directive<ul>
<li>scope<ul>
<li>独立作用域true</li>
<li>隔离作用域{}<ul>
<li>在单独的标签里起作用。</li>
<li>@</li>
<li>=</li>
<li>&amp;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">m1.directive(&#39;myTab&#39;,function(){
    return {
        restrict : &#39;E&#39;,   
        replace : true,
        //scope : true,
        //每一个标签元素都可以用ng-init定义独立的作用域。
        scope : {
            myId : &#39;@&#39;,
            myName : &#39;=&#39;,
            myFn : &#39;&amp;&#39;
        },
        controller : [&#39;$scope&#39;,function($scope){
            $scope.name = &#39;miaov&#39;;
        }],
        //引入第三方文件
        templateUrl : &#39;temp2.html&#39;
    };
});</code></pre>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">restrict</td>
<td>决定一个指令可如何被使用（例如元素、属性、CSS class 或 注释）。</td>
</tr>
<tr>
<td align="center">scope</td>
<td>用于创建一个子 scope 或孤立的 scope 。</td>
</tr>
<tr>
<td align="center">template</td>
<td>定义指令的输出内容。可以包含 HTML 、数据绑定表达式，甚至是其它指令。</td>
</tr>
<tr>
<td align="center">templateUrl</td>
<td>提供指令所用模版的路径。如果模版被定义在 &lt; script&gt; 内，那它可以包含一个 DOM 元素的 id 。</td>
</tr>
<tr>
<td align="center">controller</td>
<td>用于定义和指令模版关联的控制器。</td>
</tr>
<tr>
<td align="center">link</td>
<td>用于 DOM 操作任务的函数</td>
</tr>
</tbody></table>
<p>其中<strong>隔离作用域</strong>中的<strong>变量</strong>绑定到属性名称，属性中的值为字符串值、控制器中的变量或者函数。隔离作用域和属性的之间的绑定策略有如下三种：</p>
<ul>
<li>@：绑定的属性值为字符串。此时没有与controller交互。</li>
<li>=：绑定的属性值为变量。此时与controller有交互。</li>
<li>&amp;：绑定的属性值为函数。此时与controller有交互。</li>
</ul>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/scope%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" alt></p>
<blockquote>
<p><a href="http://blog.csdn.net/GAMEloft9/article/details/50848016" target="_blank" rel="noopener">http://blog.csdn.net/GAMEloft9/article/details/50848016</a></p>
</blockquote>
<pre><code class="html">&lt;script&gt;

var m1 = angular.module(&#39;myApp&#39;,[]);
m1.directive(&#39;myTab&#39;,function(){
    return {
        restrict : &#39;E&#39;,   
        replace : true,
        //scope : true,
        scope : {
            myId : &#39;@&#39;,//myId等于my-id,js标识符不支持横线（-），但可以转为驼峰命名法。绑定指定的字符串。
            myName : &#39;=&#39;,//解释的是数据，
            myFn : &#39;&amp;&#39;//绑定父级的函数
        },
        controller : [&#39;$scope&#39;,function($scope){
            $scope.name = &#39;miaov&#39;;
        }],
        templateUrl : &#39;temp2.html&#39;
    };
});

m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){

    $scope.name = &#39;hello&#39;;
    $scope.show = function(n){
        alert(n);
    };  
}]);
&lt;/script&gt;



&lt;body ng-controller=&quot;Aaa&quot;&gt;
&lt;!-- 留意传参的两种方式。 --&gt;
&lt;my-tab my-id=&quot;div1&quot; my-name=&quot;name&quot; my-fn=&quot;show(&#39;hello&#39;)&quot;&gt;&lt;/my-tab&gt;
&lt;my-tab my-id=&quot;div2&quot; my-name=&quot;name&quot; my-fn=&quot;show(num)&quot;&gt;&lt;/my-tab&gt;
&lt;/body&gt;</code></pre>
<p>tab代码</p>
<pre><code class="html">&lt;div id=&quot;{{myId}}&quot;&gt;
    &lt;input class=&quot;active&quot; type=&quot;button&quot; value=&quot;1&quot; ng-click=&quot;myFn({num:456})&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;2&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;3&quot;&gt;
    &lt;div style=&quot;display:block&quot;&gt;{{name}}&lt;/div&gt;
    &lt;div&gt;22222222&lt;/div&gt;
    &lt;div&gt;33333333&lt;/div&gt;
&lt;/div&gt;</code></pre>
<h2 id="javascript-2"><a href="#javascript-2" class="headerlink" title="javascript"></a>javascript</h2><h3 id="valueOf-函数详解"><a href="#valueOf-函数详解" class="headerlink" title="valueOf() 函数详解"></a>valueOf() 函数详解</h3><p><strong>valueOf()</strong>函数返回指定对象的原始值。</p>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array</td>
<td align="left">数组实例对象。</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="left">布尔值。</td>
</tr>
<tr>
<td align="center">Date</td>
<td align="left">以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算。</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="left">函数本身。</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="left">数字值。</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="left">对象本身。这是默认设置。</td>
</tr>
<tr>
<td align="center">String</td>
<td align="left">字符串值。</td>
</tr>
</tbody></table>
<pre><code class="js">// Array：返回数组对象本身
var array = [&quot;CodePlayer&quot;, true, 12, -5];
document.writeln( array.valueOf() === array ); // true

// Date：当前时间距1970年1月1日午夜的毫秒数
var date = new Date(2013, 7, 18, 23, 11, 59, 230);
document.writeln( date.valueOf() ); // 1376838719230

// Number：返回数字值
var num =  15.26540;
document.writeln( num.valueOf() ); // 15.2654

// 布尔：返回布尔值true或false
var bool = true;
document.writeln( bool.valueOf() === bool ); // true
// new一个Boolean对象
var newBool = new Boolean(true);
// valueOf()返回的是true，两者的值相等
document.writeln( newBool.valueOf() == newBool ); // true
// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型
document.writeln( newBool.valueOf() === newBool ); // false

// Function：返回函数本身
function foo(){ 
}
document.writeln( foo.valueOf() === foo ); // true
var foo2 =  new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x + y;&quot;);
document.writeln( foo2.valueOf() === foo2 ); // true

// Object：返回对象本身
var obj = {name: &quot;张三&quot;, age: 18};
document.writeln( obj.valueOf() === obj ); // true

// String：返回字符串值
var str = &quot;http://www.365mini.com&quot;;
document.writeln( str.valueOf() === str ); // true
// new一个字符串对象
var str2 = new String(&quot;http://www.365mini.com&quot;);
// 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型
document.writeln( str2.valueOf() === str2 ); // false</code></pre>
<h3 id="toString-函数详解"><a href="#toString-函数详解" class="headerlink" title="toString() 函数详解"></a>toString() 函数详解</h3><p><strong>toString()</strong>函数用于将当前对象以字符串的形式返回。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>行为描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array</td>
<td>将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td>如果布尔值是true，则返回”true”。否则返回”false”。</td>
</tr>
<tr>
<td align="center">Date</td>
<td>返回日期的文本表示。</td>
</tr>
<tr>
<td align="center">Error</td>
<td>返回一个包含相关错误信息的字符串。</td>
</tr>
<tr>
<td align="center">Function</td>
<td>返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }”</td>
</tr>
<tr>
<td align="center">Number</td>
<td>返回数值的字符串表示。还可返回以指定进制表示的字符串，请参考Number.toString()。</td>
</tr>
<tr>
<td align="center">String</td>
<td>返回 String 对象的值。</td>
</tr>
<tr>
<td align="center">Object(默认)</td>
<td>返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。</td>
</tr>
</tbody></table>
<pre><code class="js">//数组
var array = [&quot;CodePlayer&quot;, true, 12, -5];
document.writeln( array.toString() ); // CodePlayer,true,12,-5

// 日期
var date = new Date(2013, 7, 18, 23, 11, 59, 230);
document.writeln( date.toString() ); // Sun Aug 18 2013 23:11:59 GMT+0800 (中国标准时间)

// 日期2
var date2 = new Date(1099, 7, 18, 23, 11, 59, 230);
document.writeln( date2.toString() ); // Fri Aug 18 1099 23:11:59 GMT+0800 (中国标准时间)

// 数字
var num =  15.26540;
document.writeln( num.toString() ); // 15.2654

// 布尔
var bool = true;
document.writeln( bool.toString() ); // true

// Object
var obj = {name: &quot;张三&quot;, age: 18};
document.writeln( obj.toString() ); // [object Object]

// HTML DOM 节点
var eles = document.getElementsByTagName(&quot;body&quot;);
document.writeln( eles.toString() ); // [object NodeList]
document.writeln( eles[0].toString() ); // [object HTMLBodyElement]</code></pre>
<h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>typeof操作符返回一个字符串,表示未经求值的操作数(unevaluated operand)的类型。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td align="left">Null</td>
<td>“object” (见下方)</td>
</tr>
<tr>
<td align="left">布尔值</td>
<td>“boolean”</td>
</tr>
<tr>
<td align="left">数值</td>
<td>“number”</td>
</tr>
<tr>
<td align="left">字符串</td>
<td>“string”</td>
</tr>
<tr>
<td align="left">Symbol (ECMAScript 6 新增)</td>
<td>“symbol”</td>
</tr>
<tr>
<td align="left">宿主对象(JS环境提供的，比如浏览器)</td>
<td>Implementation-dependent</td>
</tr>
<tr>
<td align="left">函数对象 (implements [[Call]] in ECMA-262 terms)</td>
<td>“function”</td>
</tr>
<tr>
<td align="left">任何其他对象</td>
<td>“object”</td>
</tr>
</tbody></table>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="2016年4月15日"><a href="#2016年4月15日" class="headerlink" title="2016年4月15日"></a>2016年4月15日</h1><h2 id="angularjs-4"><a href="#angularjs-4" class="headerlink" title="angularjs"></a>angularjs</h2><h3 id="自定义指令directive"><a href="#自定义指令directive" class="headerlink" title="自定义指令directive"></a>自定义指令directive</h3><ul>
<li>transclude<ul>
<li>ng-transclude<ul>
<li>默认为false，可以把其他指令嵌入当中。</li>
</ul>
</li>
</ul>
</li>
<li>require<ul>
<li>把一个指令引入到其他指令，在下面的构造器中就可以使用这个指令构造器当中 的变量。</li>
<li>^<ul>
<li>去父级找指令</li>
</ul>
</li>
<li>?<ul>
<li>如果不存在 ，不会报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.directive(&#39;hello&#39;,function(){
    return {
        restrict:&#39;E&#39;,
        replace:true,
        transclude:true, 
        controller:function($scope){
            this.name=&#39;niefee,hello&#39;;
        },
        template:&#39;&lt;div&gt;nihao,&lt;h1 ng-transclude&gt;&lt;/h1&gt;&lt;/div&gt;&#39; 
    };
});

m1.directive(&#39;hi&#39;,function(){
    return {
        restrict : &#39;E&#39;,   
        replace : true,
        require : &#39;?^hello&#39;,    
        template : &#39;&lt;span&gt;hi angular&lt;/span&gt;&#39;,
        link:function(scope,element,attr,reController){

            console.log(reController.name);
        }
    }
});</code></pre>
<pre><code class="html">&lt;hello&gt;
    &lt;hi&gt;&lt;/hi&gt;
&lt;/hello&gt;</code></pre>
<h3 id="http服务"><a href="#http服务" class="headerlink" title="$http服务"></a>$http服务</h3><ul>
<li>$http<ul>
<li>method</li>
<li>url</li>
<li>success<ul>
<li>data–返回的请求数据。</li>
<li>state–返回的状态值</li>
<li>headers–</li>
<li>config</li>
</ul>
</li>
<li>error</li>
<li>简写方式<ul>
<li>jsonp</li>
<li>JSON_CALLBACK</li>
</ul>
</li>
<li>例子  :   百度下拉搜索</li>
</ul>
</li>
</ul>
<pre><code class="js">/*$http({
        method:&#39;GET&#39;,
        url:&#39;data.php&#39;,

    }).success(function(data,state,hesders,config){
        console.log(data);
        console.log(state);
        console.log(hesders);
        console.log(config);
    }).error(function(data){
        document.write(data);
    })*/

    $http.get(&#39;data.php&#39;).success(function(data,stata,headers,config){
        console.log(data);
    })</code></pre>
<h3 id="location"><a href="#location" class="headerlink" title="$location"></a>$location</h3><ul>
<li>absUrl()<ul>
<li>绝对地址</li>
</ul>
</li>
<li>path()<ul>
<li>与路由挂钩</li>
</ul>
</li>
<li>replace()<ul>
<li>不会出现历史管理，没有返回。</li>
</ul>
</li>
<li>hash()<ul>
<li>哈希</li>
</ul>
</li>
<li>search()</li>
<li>url()<ul>
<li>路径、哈希</li>
</ul>
</li>
<li>host()<ul>
<li>主机名</li>
</ul>
</li>
<li>port()<ul>
<li>端口</li>
</ul>
</li>
<li>protocol()<ul>
<li>协议</li>
</ul>
</li>
</ul>
<pre><code class="js">    //var a = $location.absUrl();
    $location.path(&#39;aaa/bbb/ccc&#39;).replace();
    $location.hash(&#39;hello&#39;);
    //$location.search({&#39;age&#39;:&#39;20&#39;});
    var a = $location.port();
    //var a = $location.protocol();
    console.log(a);</code></pre>
<ul>
<li>$anchorScroll()<ul>
<li>例子  :  锚点跳转</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;script&gt;

var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,&#39;$location&#39;,&#39;$anchorScroll&#39;,function($scope,$location,$anchorScroll){

    $scope.change = function(id){

        //console.log(id);
        $location.hash(id);
        $anchorScroll();

    };

}]);

&lt;/script&gt;


&lt;div id=&quot;parent&quot; ng-controller=&quot;Aaa&quot;&gt;
    &lt;ul&gt;
        &lt;li ng-repeat=&quot;id in [1,2,3,4,5]&quot; ng-click=&quot;change(&#39;div&#39;+id)&quot;&gt;{{id}}aaaaaaaaaa&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div ng-repeat=&quot;id in [1,2,3,4,5]&quot; ng-attr-id=&quot;div{{id}}&quot;&gt;{{id}}&lt;/div&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>$cacheFactory<ul>
<li>info()</li>
<li>put()</li>
<li>get()</li>
<li>remove()</li>
<li>配置capacity</li>
</ul>
</li>
</ul>
<h2 id="javascript-3"><a href="#javascript-3" class="headerlink" title="javascript"></a>javascript</h2><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p><strong>添加节点</strong></p>
<pre><code class="js">var para=document.createElement(&quot;p&quot;);
var node=document.createTextNode($scope.arr[i]);
para.appendChild(node);</code></pre>
<p><strong>删除节点</strong></p>
<pre><code class="js">var parent=document.getElementById(&quot;div1&quot;);
var child=document.getElementById(&quot;p1&quot;);
parent.removeChild(child);</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月18日"><a href="#2016年4月18日" class="headerlink" title="2016年4月18日"></a>2016年4月18日</h1><h2 id="javascript-4"><a href="#javascript-4" class="headerlink" title="javascript"></a>javascript</h2><p>JavaScript的原生错误类型</p>
<ul>
<li>SyntaxError<ul>
<li>SyntaxError是解析代码时发生的语法错误。</li>
</ul>
</li>
<li>ReferenceError<ul>
<li>ReferenceError是引用一个不存在的变量时发生的错误。</li>
<li>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</li>
</ul>
</li>
<li>RangeError<ul>
<li>RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</li>
</ul>
</li>
<li>TypeError<ul>
<li>TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</li>
</ul>
</li>
<li>URIError<ul>
<li>URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</li>
</ul>
</li>
<li>EvalError<ul>
<li>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。</li>
</ul>
</li>
</ul>
<h2 id="angularjs-5"><a href="#angularjs-5" class="headerlink" title="angularjs"></a>angularjs</h2><h3 id="cacheFactory缓存服务"><a href="#cacheFactory缓存服务" class="headerlink" title="$cacheFactory缓存服务"></a>$cacheFactory缓存服务</h3><ul>
<li>info()<ul>
<li>缓存内容信息</li>
</ul>
</li>
<li>put()<ul>
<li>设置缓存</li>
</ul>
</li>
<li>get()<ul>
<li>获取缓存</li>
</ul>
</li>
<li>remove()<ul>
<li>删除缓存</li>
</ul>
</li>
<li>配置capacity<ul>
<li>设置缓存长度</li>
</ul>
</li>
</ul>
<pre><code class="js">m1.controller(&#39;Acon&#39;,[&#39;$scope&#39;,&#39;$cacheFactory&#39;,function($scope,$cacheFactory){
    var cache=$cacheFactory(&#39;myCache&#39;);

    console.log(cache.info());

    cache.put(&#39;name&#39;,&#39;hello&#39;);
    cache.put(&#39;age&#39;,&#39;20&#39;);

    console.log(cache.get(&#39;name&#39;));
}]) </code></pre>
<h3 id="log服务"><a href="#log服务" class="headerlink" title="$log服务"></a>$log服务</h3><ul>
<li>log()<ul>
<li>打印</li>
</ul>
</li>
<li>info()<ul>
<li>打印信息</li>
</ul>
</li>
<li>warn()<ul>
<li>警告信息</li>
</ul>
</li>
<li>error()<ul>
<li>错误信息</li>
</ul>
</li>
</ul>
<pre><code class="js">m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,&#39;$log&#39;,function($scope,$log){

    $log.log(&#39;hello&#39;);
    $log.info(&#39;hello&#39;);
    $log.warn(&#39;hello&#39;);
    $log.error(&#39;hello&#39;);
}]);</code></pre>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/log.jpg" alt></p>
<h3 id="interpolate"><a href="#interpolate" class="headerlink" title="$interpolate"></a>$interpolate</h3><p>插值计算</p>
<pre><code class="html">&lt;script&gt;
var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,&#39;$interpolate&#39;,function($scope,$interpolate){ 
    $scope.$watch(&#39;body&#39;,function(newBody){     
        if(newBody){
            var temp = $interpolate(newBody);
            $scope.showText = temp({ name : $scope.name });         
        }       
    }); 
}]);
&lt;/script&gt;

&lt;div ng-controller=&quot;Aaa&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
    &lt;textarea ng-model=&quot;body&quot;&gt;
    &lt;/textarea&gt;
    &lt;p&gt;{{showText}}&lt;/p&gt;
&lt;/div&gt;</code></pre>
<h3 id="供应商概念"><a href="#供应商概念" class="headerlink" title="供应商概念"></a>供应商概念</h3><ul>
<li>服务的相关初始配置操作</li>
<li>config<ul>
<li>provider</li>
<li>$interpolate<ul>
<li>startSymbol()<ul>
<li>表达式头部标识</li>
</ul>
</li>
<li>endSymbol()<ul>
<li>表达式尾部标示</li>
</ul>
</li>
</ul>
</li>
<li>$log<ul>
<li>debugEnabled()<ul>
<li>禁用某功能</li>
</ul>
</li>
</ul>
</li>
<li>$anchorScroll<ul>
<li>disableAutoScrolling()<ul>
<li>禁止在地址栏自动跳转</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="q延迟对象"><a href="#q延迟对象" class="headerlink" title="$q延迟对象"></a><strong>$q</strong>延迟对象</h3><ul>
<li>promise的实现</li>
<li>defer()</li>
<li>resolve()<ul>
<li>成功</li>
</ul>
</li>
<li>reject()<ul>
<li>失败</li>
</ul>
</li>
<li>notify()</li>
<li>then()</li>
</ul>
<h3 id="自定义服务"><a href="#自定义服务" class="headerlink" title="自定义服务"></a>自定义服务</h3><ul>
<li>module<ul>
<li>filter()</li>
<li>directive()</li>
<li>factory()</li>
<li>provider()<ul>
<li>区别</li>
<li>$get</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.factory(&#39;myService&#39;,function(){

    return {
        name:&#39;efee&#39;,
        show:function(){
            return this.name+&#39;:angular&#39;;
        }
    }
})
m1.controller(&#39;Acon&#39;,[&#39;$scope&#39;,&#39;myService&#39;,function($scope,myService){
    console.log(myService.show());
}]) </code></pre>
<ul>
<li>模块之间的通信<ul>
<li>provide好处</li>
</ul>
</li>
<li>service()<ul>
<li>构造函数</li>
</ul>
</li>
<li>constant()<ul>
<li>设置常量</li>
</ul>
</li>
<li>value()<ul>
<li>区别</li>
</ul>
</li>
</ul>
<h3 id="angularjs插件"><a href="#angularjs插件" class="headerlink" title="angularjs插件"></a>angularjs插件</h3><ul>
<li>ngSanitize</li>
<li>ngRoute<ul>
<li>版本的问题</li>
<li>ng-view<ul>
<li>这个插件特有。</li>
</ul>
</li>
<li>$routeProvider<ul>
<li>when<ul>
<li>template</li>
<li>templateUrl</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[TOC]</p>
<h1 id="2016年4月19日"><a href="#2016年4月19日" class="headerlink" title="2016年4月19日"></a>2016年4月19日</h1><h2 id="angularjs-6"><a href="#angularjs-6" class="headerlink" title="angularjs"></a>angularjs</h2><h3 id="内部传播方式"><a href="#内部传播方式" class="headerlink" title="内部传播方式"></a>内部传播方式</h3><ul>
<li>$emit<ul>
<li>向上广播</li>
</ul>
</li>
<li>$broadcast<ul>
<li>向下广播</li>
</ul>
</li>
<li>event<ul>
<li>targetScope<ul>
<li>点击目标</li>
</ul>
</li>
<li>currentScope<ul>
<li>当前目标</li>
</ul>
</li>
<li>name<ul>
<li>事件名称</li>
</ul>
</li>
<li>stopPropagation()<ul>
<li>阻止冒泡</li>
</ul>
</li>
</ul>
</li>
<li>内部传播方式<ul>
<li>$routeChangeStart</li>
<li>$viewContentLoaded</li>
</ul>
</li>
</ul>
<h3 id="运动插件"><a href="#运动插件" class="headerlink" title="运动插件"></a>运动插件</h3><ul>
<li>CSS3的方式</li>
<li>ng-enter<ul>
<li>运动进入开始</li>
</ul>
</li>
<li>ng-enter-active<ul>
<li>运动进入结束</li>
</ul>
</li>
<li>ng-leave<ul>
<li>运动离开开始</li>
</ul>
</li>
<li>ng-leave-active<ul>
<li>运动离开结束</li>
</ul>
</li>
<li>支持的指令<ul>
<li>if,view,repeat,include,swtich</li>
<li>repeat<ul>
<li>ng-enter-stagger</li>
<li>animation-delay</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="css">.box{ transition:1s all;}
.box.ng-enter{ opacity:0;}
.box.ng-enter-active{ opacity:1;}
.box.ng-leave{ display:none;}
.box.ng-enter-stagger{
    animation-delay : 100ms;
}</code></pre>
<ul>
<li>ng-hide-add</li>
<li>ng-hide-add-active</li>
<li>ng-hide-remove</li>
<li>ng-hide-remove-active</li>
<li>支持的指令<ul>
<li>class,show,hide,model等</li>
</ul>
</li>
</ul>
<pre><code class="css">.box{ width:200px; height:200px; background:red; transition:1s all;}
.box.ng-hide-remove{ opacity:0;}
.box.ng-hide-remove-active{ opacity:1;}
.box.ng-hide-add{ opacity:1;}
.box.ng-hide-add-active{ opacity:0;}</code></pre>
<ul>
<li>JS方式<ul>
<li>animation()</li>
<li>enter/leave</li>
<li>removeClass/addClass</li>
</ul>
</li>
</ul>
<pre><code class="js">m1.animation(&#39;.box&#39;,function(){
    return {
        addClass : function(element,sClass,done){
            //console.log(element);
            //console.log(sClass);
            //console.log(done);
            $(element).animate({width:0,height:0},1000,done);
        },
        removeClass : function(element,sClass,done){
            $(element).css({width:0,height:0});
            $(element).animate({width:200,height:200},1000,done);
        }
    };
});</code></pre>
<h3 id="ngResource"><a href="#ngResource" class="headerlink" title="ngResource"></a>ngResource</h3><p>支持 RESTful 架构模式</p>
<ul>
<li><p>get()</p>
<ul>
<li>获取的内容</li>
</ul>
</li>
<li><p>query()</p>
<ul>
<li>区别</li>
</ul>
</li>
<li><p>save()</p>
</li>
<li><p>delete()</p>
</li>
</ul>
<p>[TOC]</p>
<h1 id="2016年4月20日"><a href="#2016年4月20日" class="headerlink" title="2016年4月20日"></a>2016年4月20日</h1><h2 id="javascript-5"><a href="#javascript-5" class="headerlink" title="javascript"></a>javascript</h2><h3 id="apply-与call"><a href="#apply-与call" class="headerlink" title="apply()与call()"></a>apply()与call()</h3><p>函数属性的继承与传递</p>
<pre><code class="js">    /*定义一个人类*/
    function Person(name,age)
    {
        this.name=name;
        this.age=age;
    }
    /*定义一个学生类*/
    function Student(name,age,grade)
    {
        Person.apply(this,arguments);
        this.grade=grade;
    }
    //创建一个学生类
    var student=new Student(&quot;qian&quot;,21,&quot;一年级&quot;);
    //测试
    alert(&quot;name:&quot;+student.name+&quot;\n&quot;+&quot;age:&quot;+student.age+&quot;\n&quot;+&quot;grade:&quot;+student.grade);
    //大家可以看到测试结果name:qian  age:21  grade:一年级
    //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.</code></pre>
<p><strong>Function.apply(obj,args)</strong>方法能接收两个参数<br><strong>obj</strong>：这个对象将代替Function类里this对象,将调用函数<strong>Person</strong>里的<strong>this</strong>变成函数<strong>Student</strong>的<strong>this</strong>。<br><strong>args</strong>：这个是数组，它将作为参数传给Function（args–&gt;arguments）</p>
<blockquote>
<p>在Studen函数里面可以将apply中修改成如下:</p>
</blockquote>
<blockquote>
<blockquote>
<p>Person.call(this,name,age);</p>
</blockquote>
</blockquote>
<h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><ul>
<li>function命令</li>
</ul>
<pre><code class="js">function print(s) {
  console.log(s);
}  </code></pre>
<blockquote>
<p>上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。</p>
</blockquote>
<ul>
<li>函数表达式</li>
</ul>
<pre><code class="js">var print = function(s) {
  console.log(s);
};</code></pre>
<blockquote>
<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。</p>
</blockquote>
<pre><code>var f = function f() {};</code></pre><blockquote>
<p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>
</blockquote>
<ul>
<li>Function构造函数</li>
</ul>
<pre><code class="js"> var add = new Function(
  &#39;x&#39;,
  &#39;y&#39;,
  &#39;return (x + y)&#39;
);

// 等同于

function add(x, y) {
  return (x + y);
}</code></pre>
<blockquote>
<p>在上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。</p>
</blockquote>
<h3 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h3><p>var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>
<pre><code class="js">function foo(x) {
  if (x &gt; 100) {
    var tmp = x - 100;
  }
}</code></pre>
<p>上面的代码等同于</p>
<pre><code class="js">function foo(x) {
  var tmp;
  if (x &gt; 100) {
    tmp = x - 100;
  };
}</code></pre>
<h3 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h3><p>函数本身也是一个值，也有自己的作用域。它的作用域绑定其声明时所在的作用域。</p>
<pre><code class="js">var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}

f() // 1</code></pre>
<p>函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。</p>
<h3 id="函数值传递方式"><a href="#函数值传递方式" class="headerlink" title="函数值传递方式"></a>函数值传递方式</h3><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<pre><code class="js">var p = 2;

function f(p) {
  p = 3;
}
f(p);

p // 2</code></pre>
<p>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p>
<pre><code class="js">var obj = {p: 1};

function f(o) {
  o.p = 2;
}
f(obj);

obj.p // 2</code></pre>
<p>如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<pre><code class="js">var obj = [1, 2, 3];

function f(o){
  o = [2, 3, 4];
}
f(obj);

obj // [1, 2, 3]</code></pre>
<p>如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。</p>
<pre><code>function f(p) {  window[p] = 2;}</code></pre><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>虽然arguments很像数组，但它是一个对象。</p>
<p>下面是两种常用的转换方法：slice方法和逐一填入新数组。</p>
<pre><code class="js">var args = Array.prototype.slice.call(arguments);

// or

var args = [];
for (var i = 0; i &lt; arguments.length; i++) {
  args.push(arguments[i]);
}</code></pre>
<p><strong>callee属性</strong></p>
<p>arguments对象带有一个callee属性，返回它所对应的原函数。</p>
<pre><code class="js">var f = function(one) {
  console.log(arguments.callee === f);
}

f() // true</code></pre>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数内的函数。</p>
<pre><code class="js">function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999</code></pre>
<p>JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。</p>
<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</p>
<pre><code class="js">function createIncrementor(start) {
  return function () {
    return start++;
  };
}

var inc = createIncrementor(5);

inc() // 5
inc() // 6
inc() // 7</code></pre>
<p>外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><pre><code class="js">(function(){ /* code */ }()); 

// 或者

(function(){ /* code */ })(); </code></pre>
<p>让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，这样就可以对此进行运算。</p>
<pre><code class="js">var i = function(){ return 10; }();

true &amp;&amp; function(){ /* code */ }();

0, function(){ /* code */ }();
!function(){ /* code */ }();

~function(){ /* code */ }();

-function(){ /* code */ }();

+function(){ /* code */ }();

new function(){ /* code */ }

new function(){ /* code */ }() // 只有传递参数时，才需要最后那个圆括号。
</code></pre>
<p>一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
<h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>eval命令的作用是，将字符串当作语句执行。</p>
<pre><code class="js">eval(&#39;var a = 1;&#39;);

a // 1</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月21日"><a href="#2016年4月21日" class="headerlink" title="2016年4月21日"></a>2016年4月21日</h1><h2 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>第一步：移动默认的源</p>
<pre><code>gem sources --remove https://rubygems.org/</code></pre><p>第二步：指定淘宝的源</p>
<pre><code>gem sources -a https://ruby.taobao.org/</code></pre><p>第三步：查看指定的源是不是淘宝源</p>
<pre><code>gem sources -l</code></pre><p>删除Sass</p>
<pre><code>gem uninstall sass</code></pre><h3 id="Sass-和-SCSS"><a href="#Sass-和-SCSS" class="headerlink" title="Sass 和 SCSS"></a>Sass 和 SCSS</h3><ul>
<li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li>
<li>语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</li>
</ul>
<h3 id="命令编译"><a href="#命令编译" class="headerlink" title="命令编译"></a>命令编译</h3><p>单文件编译：</p>
<pre><code>sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css</code></pre><p>多文件编译：</p>
<pre><code>sass sass/:css/</code></pre><p>开启“watch”功能，这样只要你的代码进行任保修改，都能自动监测到代码的变化，并且给你直接编译出来：</p>
<pre><code>sass --watch &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css</code></pre><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>声明变量的符号“$”</li>
<li>变量名称</li>
<li>赋予变量的值</li>
</ul>
<blockquote>
<p>如果值后面加上!default则表示默认值。</p>
</blockquote>
<pre><code>$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7</code></pre><h3 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><pre><code class="css">//SCSS
$color: orange !default;
//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量)
.block {
  color: $color;//调用全局变量
}
em {
  $color: red;//定义局部变量
  a {
    color: $color;//调用局部变量
  }
}
span {
  color: $color;//调用全局变量
}</code></pre>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><ul>
<li><strong>选择器嵌套</strong></li>
</ul>
<pre><code class="css">nav {
  a {
    color: red;

    header &amp; {
      color:green;
    }
  }  
}</code></pre>
<p>编译后</p>
<pre><code class="css">nav a {
  color:red;
}

header nav a {
  color:green;
}</code></pre>
<ul>
<li><strong>属性嵌套</strong></li>
</ul>
<pre><code class="css">.box {
  border: {
   top: 1px solid red;
   bottom: 1px solid green;
  }
}</code></pre>
<p>编译后：</p>
<pre><code class="css">.box {
    border-top: 1px solid red;
    border-bottom: 1px solid green;
}</code></pre>
<ul>
<li><strong>伪类嵌套</strong></li>
</ul>
<pre><code class="css">.clearfix{
&amp;:before,
&amp;:after {
    content:&quot;&quot;;
    display: table;
  }
&amp;:after {
    clear:both;
    overflow: hidden;
  }
}</code></pre>
<p>编译后：</p>
<pre><code class="css">clearfix:before, .clearfix:after {
  content: &quot;&quot;;
  display: table;
}
.clearfix:after {
  clear: both;
  overflow: hidden;
}</code></pre>
<h3 id="声明混合宏"><a href="#声明混合宏" class="headerlink" title="声明混合宏"></a>声明混合宏</h3><p>在 Sass 中，使用“@mixin”来声明一个混合宏。如：</p>
<pre><code class="css">@mixin border-radius($radius:5px){
    -webkit-border-radius: $radius;
    border-radius: $radius;
}</code></pre>
<p>调用：</p>
<pre><code class="css">button {
    @include border-radius;
}</code></pre>
<p>编译出来的 CSS:</p>
<pre><code class="css">button {
  -webkit-border-radius: 3px;
  border-radius: 3px;
}</code></pre>
<p>在混合宏中，可以传一个不带任何值的参数，在调用的时候可以给这个混合宏传一个参数值：</p>
<pre><code class="css">.box {
  @include border-radius(3px);
}</code></pre>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 Sass 中是通过关键词 <strong>@extend</strong>来继承已存在的<strong>类样式块</strong>，从而实现代码的继承。</p>
<pre><code class="css">//SCSS
.btn {
  border: 1px solid #ccc;
  padding: 6px 10px;
  font-size: 14px;
}

.btn-primary {
  background-color: #f36;
  color: #fff;
  @extend .btn;
}

.btn-second {
  background-color: orange;
  color: #fff;
  @extend .btn;
}</code></pre>
<p>编译后：</p>
<pre><code class="css">//CSS
.btn, .btn-primary, .btn-second {
  border: 1px solid #ccc;
  padding: 6px 10px;
  font-size: 14px;
}

.btn-primary {
  background-color: #f36;
  color: #fff;
}

.btn-second {
  background-clor: orange;
  color: #fff;
}</code></pre>
<pre><code class="css">%mt5 {
  margin-top: 5px;
}
%pt5{
  padding-top: 5px;
}
.btn {
  @extend %mt5;
  @extend %pt5;
}</code></pre>
<blockquote>
<p>因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/SASS.jpg" alt></p>
<pre><code class="css">//SCSS中混合宏使用
@mixin mt($var){
  margin-top: $var;  
}

.block {
  @include mt(5px);

  span {
    display:block;
    @include mt(5px);
  }
}

.header {
  color: orange;
  @include mt(5px);

  span{
    display:block;
    @include mt(5px);
  }
}

//SCSS 继承的运用
.mt{
  margin-top: 5px;  
}

.block {
  @extend .mt;

  span {
    display:block;
    @extend .mt;
  }
}

.header {
  color: orange;
  @extend .mt;

  span{
    display:block;
    @extend .mt;
  }
}

//SCSS中占位符的使用
%mt{
  margin-top: 5px;  
}

.block {
  @extend %mt;

  span {
    display:block;
    @extend %mt;
  }
}

.header {
  color: orange;
  @extend %mt;

  span{
    display:block;
    @extend %mt;
  }
}</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月23日"><a href="#2016年4月23日" class="headerlink" title="2016年4月23日"></a>2016年4月23日</h1><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-hack"><a href="#CSS-hack" class="headerlink" title="CSS hack"></a>CSS hack</h3><p><strong>CSS hack</strong><br>CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的，比如.kwstu{width:300px; _ width:200px;}，一般浏览器会先给元素使用width:300px;的样式，紧接着后面还有个_width:200px;由于下划线_width只有IE6可以识别，所以此样式在IE6中实际设置对象的宽度为200px，后面的把前面的给覆盖了，而其他浏览器不识别_width不会执行_width:200px;这句样式，所以在其他浏览器中设置对象的宽度就是300px;</p>
<blockquote>
<p>margin属性在ie6中显示的距离会比其他浏览器中显示的距离宽2倍</p>
</blockquote>
<p><strong>浏览器识别字符标准对应表</strong></p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/ie.png" alt></p>
<p>从上图可以分析出以下几种情况：</p>
<ol>
<li>大部分特殊字符IE浏览器支持，其他主流浏览器firefox，chrome，opera，safari不支持 (opera可识别除外)。</li>
<li>\9    ：所有IE浏览器都支持</li>
<li>_和-  ：仅IE6支持</li>
<li>*     ：IE6、E7支持</li>
<li>\0    ：IE8、IE9支持，opera部分支持</li>
<li>\9\0  ：IE8部分支持、IE9支持</li>
<li>\0\9  ：IE8、IE9支持</li>
</ol>
<p>hack汇总</p>
<pre><code class="css">.element{
color:#000;             /*w3c标准*/
[;color:#f00;];         /*Webkit(chrome和safari)*/
color:#666\9;           /*IE8*/
*color:#999;            /*IE7*/
_color:#333;            /*IE6*/
}
:root .element{color:#0f0\9;}  /*IE9*/
@-moz-document url-prefix(){ .element{color:#f1f1f1;}} /*Firefox*/</code></pre>
<p><strong>html头部hack</strong></p>
<p>HTML头部引用(if IE)Hack：针对所有IE：&lt; !–[if IE]&gt;&lt; !–您的代码–&gt;&lt; ![endif]–&gt;，针对IE6及以下版本：&lt; !–[if lt IE 7]&gt;&lt; !–您的代码–&gt;&lt; ![endif]–&gt;，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。</p>
<pre><code class="html">只在IE下生效
&lt;!--[if IE]&gt;
这段文字只在IE浏览器显示
&lt;![endif]--&gt;
只在IE6下生效
&lt;!--[if IE 6]&gt;
这段文字只在IE6浏览器显示
&lt;![endif]--&gt;
只在IE6以上版本生效
&lt;!--[if gte IE 6]&gt;
这段文字只在IE6以上(包括)版本IE浏览器显示
&lt;![endif]--&gt;</code></pre>
<p><strong>选择器前缀hack</strong></p>
<pre><code>*html *前缀只对IE6生效

*+html *+前缀只对IE7生效

@media screen\9{...}只对IE6/7生效

@media \0screen {body { background: red; }}只对IE8有效

@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效

@media screen\0 {body { background: green; }} 只对IE8/9/10有效

@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效

@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等</code></pre><blockquote>
<p><a href="http://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="noopener">http://blog.csdn.net/freshlover/article/details/12132801</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="2016年4月24日"><a href="#2016年4月24日" class="headerlink" title="2016年4月24日"></a>2016年4月24日</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><ul>
<li><strong>消息（1字头）</strong></li>
</ul>
<p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</td>
</tr>
</tbody></table>
<ul>
<li><strong>成功（2字头）</strong></li>
</ul>
<p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>一切正常，对GET和POST请求的应答文档跟在后面。</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>服务器已经创建了文档，Location头给出了它的URL。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已经接受请求，但处理尚未完成。</td>
</tr>
<tr>
<td>…</td>
<td>….</td>
<td>….</td>
</tr>
</tbody></table>
<ul>
<li><strong>重定向（3字头）</strong></li>
</ul>
<p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。<br>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态信息</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td align="left">客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td align="left">客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</td>
</tr>
<tr>
<td>….</td>
<td>……</td>
<td align="left">….</td>
</tr>
</tbody></table>
<ul>
<li><strong>请求错误（4字头）</strong></li>
</ul>
<p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>请求出现语法错误。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>无法找到指定位置的资源。这也是一个常用的应答。</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>….</td>
</tr>
</tbody></table>
<ul>
<li><strong>服务器错误（5、6字头）</strong></li>
</ul>
<p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器遇到了意料不到的情况，不能完成客户的请求。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<blockquote>
<p><a href="http://baike.baidu.com/link?url=xxCnJ3Knmcn4J2aYhZeN7C4t9hUdkO6zNMc4HdgXD1oibXXEUT8i2ackqYUHazczyeOogOZDQLswFyYAqMA43a" target="_blank" rel="noopener">http://baike.baidu.com/link?url=xxCnJ3Knmcn4J2aYhZeN7C4t9hUdkO6zNMc4HdgXD1oibXXEUT8i2ackqYUHazczyeOogOZDQLswFyYAqMA43a</a></p>
</blockquote>
<h2 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h2><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><ul>
<li><strong>line-height属性的细节</strong><br>与大多数CSS属性不同，line-height支持属性值设置为无单位的数字。有无单位在子元素继承属性时有微妙的不同。</li>
<li><strong>语法</strong><br>line-height: normal | <number> | <length> | <percentage><br>normal 根据浏览器决定，一般为1.2。<br>number 仅指定数字时（无单位），实际行距为字号乘以该数字得出的结果。可以理解为一个系数，子元素仅继承该系数，子元素的真正行距是分别与自身元素字号相乘的计算结果。大多数情况下推荐使用，可以避免一些意外的继承问题。<br>length 具体的长度，如px/em等。<br>percentage 百分比，100%与1em相同。</percentage></length></number></li>
<li><strong>有单位（包括百分比）与无单位之间的区别</strong><br>有单位时，子元素继承了父元素计算得出的行距；无单位时继承了系数，子元素会分别计算各自行距（推荐使用）。</li>
</ul>
<p>[TOC]</p>
<h1 id="2016年4月25日"><a href="#2016年4月25日" class="headerlink" title="2016年4月25日"></a>2016年4月25日</h1><h2 id="javascript-6"><a href="#javascript-6" class="headerlink" title="javascript"></a>javascript</h2><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。</p>
<pre><code class="js">1 === 1.0 // true
1 + 1.0 // 2</code></pre>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<pre><code class="js">0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false</code></pre>
<blockquote>
<p>浮点数：采用了IEEE-745浮点数表示法，可以精确地表示分数，遗憾的是，我们常用的分数（特别是在金融的计算方面）都是十进制分数1/10，1/100等。二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字。</p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html</a></p>
</blockquote>
<ul>
<li><strong>数值的表示法</strong></li>
</ul>
<p>以下两种情况，JavaScript会自动将数值转为科学计数法表示</p>
<ol>
<li>小数点前的数字多于21位。</li>
<li>小数点后的零多于5个。</li>
</ol>
<ul>
<li><strong>数值的进制</strong></li>
</ul>
<p>使用字面量（literal）时，JavaScript对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p>
<ol>
<li>十进制：没有前导0的数值。</li>
<li>八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的七个阿拉伯数字的数值。</li>
<li>十六进制：有前缀0x或0X的数值。</li>
<li>二进制：有前缀0b或0B的数值。</li>
</ol>
<ul>
<li><strong>NAN</strong></li>
</ul>
<p>NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p>
<pre><code>typeof NaN // &#39;number&#39;

isNaN(NaN) // true</code></pre><blockquote>
<p>isNaN方法可以用来判断一个值是否为NaN。</p>
</blockquote>
<p>判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断。</p>
<pre><code>function myIsNaN(value) {return value !== value;}</code></pre><ul>
<li><strong>parseInt()</strong></li>
</ul>
<p><strong>parseInt</strong>方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。参数不是字符串，则会先转为字符串再转换。</p>
<pre><code class="js">parseInt(&#39;8a&#39;) // 8
parseInt(&#39;12**&#39;) // 12
parseInt(&#39;12.34&#39;) // 12
parseInt(&#39;15e2&#39;) // 15
parseInt(&#39;15px&#39;) // 15</code></pre>
<p>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制,第二个参数默认为10。</p>
<pre><code class="js">parseInt(&#39;1000&#39;) // 1000
parseInt(&#39;1000&#39;, 10) // 1000</code></pre>
<p>如果第二个参数不是数值，会被自动转为一个整数。如果第二个参数是0、undefined和null，则直接忽略。</p>
<p>字符串包含对于指定进制无意义的字符，则返回NaN。</p>
<ul>
<li><strong>parseFloat()</strong></li>
</ul>
<p>parseFloat方法用于将一个字符串转为浮点数。</p>
<pre><code>parseFloat(&#39;314e-2&#39;) // 3.14
parseFloat(&#39;0.0314E+2&#39;) // 3.14 </code></pre><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</p>
<pre><code class="js">parseFloat([]) // NaN
parseFloat(&#39;FF2&#39;) // NaN
parseFloat(&#39;&#39;) // NaN

parseFloat(&#39;\t\v\r12.34\n &#39;) // 12.34</code></pre>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型：CSS中Class</p>
<p>普通方法：CSS中的style</p>
<p>原型：prototype:要写在构造函数下面。</p>
<pre><code class="js">var arr=[1,2,3,4,5];

Array.prototype.sum=function(){
    var result=0;
    for(var i=0;i&lt;this.length;i++){
        result+=this[i];
    }

    return result;
}

alert(arr.sum());
</code></pre>
<p>面向对象的原型写法：</p>
<pre><code class="js">function 构造函数(){
    this.属性
}

构造函数.原型.方法=function(){};

var 对象1=new 构造函数();
对象1.方法();</code></pre>
<p><strong>Array.<strong>proto</strong></strong>提供的是 数组原型 – 请把它当作 Array 函数所继承的对象。</p>
<p>而<strong>Array.protoype</strong>，提供的的是 所有数组的原型对象。</p>
<pre><code class="js">var Point = function (x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.add = function (otherPoint) {
    this.x += otherPoint.x;
    this.y += otherPoint.y;
}
var p1 = new Point(3, 4);
var p2 = new Point(8, 6);
p1.add(p2);</code></pre>
<blockquote>
<p><a href="http://blog.jobbole.com/66441/" target="_blank" rel="noopener">http://blog.jobbole.com/66441/</a></p>
</blockquote>
<blockquote>
<p>资料参考：<a href="http://javascript.ruanyifeng.com/grammar/number.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/grammar/number.html</a> </p>
</blockquote>
<p>[TOC]</p>
<h1 id="2016年4月26日"><a href="#2016年4月26日" class="headerlink" title="2016年4月26日"></a>2016年4月26日</h1><h2 id="javascript-7"><a href="#javascript-7" class="headerlink" title="javascript"></a>javascript</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。<br>对象的所有键名都是字符串，所以加不加引号都可以。</p>
<ul>
<li>如果键名不符合标识名的条件（数字、空格或者运算符），也不是数字，则必须加上引号。</li>
<li>JavaScript的保留字可以不加引号当作键名。</li>
<li>如果键名是数字，则会默认转为对应的字符串。</li>
</ul>
<pre><code class="js">&#39;1p&#39;: &quot;Hello World&quot;,

for: 1,

1e2: true//100: true   </code></pre>
<h4 id="对象生成"><a href="#对象生成" class="headerlink" title="对象生成"></a>对象生成</h4><pre><code class="js">var o1 = {};
var o2 = new Object();
var o3 = Object.create(null);</code></pre>
<h4 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h4><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p>
<pre><code class="js">var o = {
  p: &#39;Hello World&#39;
};

o.p // &quot;Hello World&quot;
o[&#39;p&#39;] // &quot;Hello World&quot;</code></pre>
<blockquote>
<p>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。</p>
</blockquote>
<pre><code class="js">if(a) {...} // 报错

if(window.a) {...} // 不报错
if(window[&#39;a&#39;]) {...} // 不报错

if(&#39;a&#39; in window) {//推荐 使用
  ...
}
</code></pre>
<p>所有全局变量都是window对象的属性。如果该属性不存在，就返回undefined，并不会报错。</p>
<p><strong>查看所有属性</strong></p>
<pre><code class="js">var o = {
  key1: 1,
  key2: 2
};

Object.keys(o);
// [&#39;key1&#39;, &#39;key2&#39;]</code></pre>
<p><strong>删除属性</strong></p>
<pre><code class="js">var o = {p: 1};
Object.keys(o) // [&quot;p&quot;]

delete o.p // true
o.p // undefined
Object.keys(o) // []</code></pre>
<p>一旦使用delete命令删除某个属性，再读取该属性就会返回undefined，而且Object.keys方法返回的该对象的所有属性中，也将不再包括该属性。</p>
<h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<pre><code class="js">var o1 = {};
var o2 = o1;
//o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。
o1.a = 1;
o2.a // 1

o2.b = 2;
o1.b // 2</code></pre>
<pre><code class="js">var o1 = {};
var o2 = o1;

o1 = 1;
o2 // {}</code></pre>
<p>o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响。</p>
<h4 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h4><p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。</p>
<pre><code class="js">var o = { p: 1 };
&#39;p&#39; in o // true</code></pre>
<p>在JavaScript语言中，所有全局变量都是顶层对象（window）的属性。<br>in运算符的一个问题是，它不能识别对象继承的属性。</p>
<pre><code class="js">var o = new Object();
o.hasOwnProperty(&#39;toString&#39;) // false

&#39;toString&#39; in o // true</code></pre>
<blockquote>
<p>hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。</p>
</blockquote>
<h4 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h4><p>for…in循环用来遍历一个对象的全部属性。<br>for…in循环遍历的是对象所有可enumberable的属性，包括对象本身的属性，还包括对象继承的属性</p>
<pre><code class="js">// name 是 Person 本身的属性
function Person(name) {
  this.name = name;
}

// describe是Person.prototype的属性
Person.prototype.describe = function () {
  return &#39;Name: &#39;+this.name;
};

var person = new Person(&#39;Jane&#39;);

// for...in循环会遍历实例自身的属性（name），
// 以及继承的属性（describe）
for (var key in person) {
  console.log(key);
}
// name
// describe</code></pre>
<p>如果只想遍历对象本身的属性，可以使用hasOwnProperty方法:</p>
<pre><code class="js">for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}
// name</code></pre>
<h4 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h4><p>它的作用是操作同一个对象的多个属性时。</p>
<pre><code class="js">// 例一
with (o) {
  p1 = 1;
  p2 = 2;
}
// 等同于
o.p1 = 1;
o.p2 = 2;

// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);</code></pre>
<p>with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<pre><code class="js">var o = {};

with (o) {
  x = &quot;abc&quot;;
}

o.x // undefined
x // &quot;abc&quot;</code></pre>
<h3 id="数值-1"><a href="#数值-1" class="headerlink" title="数值"></a>数值</h3><p>两个字符串进行比较时，按照字典顺序进行比较。<br>JavaScript引擎内部首先比较首字符的Unicode编号，如果相等，再比较第二个字符的Unicode编号，以此类推。</p>
<pre><code class="js">&#39;cat&#39; &gt; &#39;Cat&#39; // true&#39;</code></pre>
<p>小写的c的Unicode编号（99）大于大写的C的Unicode编号（67）。</p>
<h4 id="同一类的复合类型值"><a href="#同一类的复合类型值" class="headerlink" title="同一类的复合类型值"></a>同一类的复合类型值</h4><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。</p>
<pre><code class="js">({}) === {} // false
[] === [] // false
(function (){}) === function (){} // false</code></pre>
<p>严格相等运算比较的是它们的内存地址是否一样，而上面代码中空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。</p>
<h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h4><ul>
<li>原始类型的值<ul>
<li>原始类型的数据会转换成数值类型再进行比较。</li>
</ul>
</li>
<li>对象与原始类型值比较<ul>
<li>对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</li>
</ul>
</li>
</ul>
<pre><code class="js">[1] == 1 // true
[1] == &#39;1&#39; // true
[1] == true // true</code></pre>
<blockquote>
<p>上面代码将只含有数值1的数组与原始类型的值进行比较，数组[1]会被自动转换成数值1，因此结果都是true。</p>
</blockquote>
<ul>
<li>undefined和null<ul>
<li>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。</li>
</ul>
</li>
<li>相等运算符的缺点<ul>
<li>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</li>
</ul>
</li>
</ul>
<pre><code class="js">&#39;&#39; == &#39;0&#39;           // false
0 == &#39;&#39;             // true
0 == &#39;0&#39;            // true

false == &#39;false&#39;    // false
false == &#39;0&#39;        // true

false == undefined  // false
false == null       // false
null == undefined   // true

&#39; \t\r\n &#39; == 0     // true</code></pre>
<h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><p>取反运算符形式上是一个感叹号，用于将布尔值变为相反值。</p>
<p>以下六个值取反后为true：</p>
<pre><code class="js">!undefined // true
!null // true
!false // true
!0 // true
!NaN // true
!&quot;&quot; // true</code></pre>
<pre><code class="js">!!x

// 等同于

Boolean(x)</code></pre>
<h4 id="且运算符（-amp-amp-）"><a href="#且运算符（-amp-amp-）" class="headerlink" title="且运算符（&amp;&amp;）"></a>且运算符（&amp;&amp;）</h4><p>如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p>
<pre><code class="js">&quot;t&quot; &amp;&amp; &quot;&quot; // &quot;&quot;
&quot;t&quot; &amp;&amp; &quot;f&quot; // &quot;f&quot;
&quot;t&quot; &amp;&amp; (1+2) // 3
&quot;&quot; &amp;&amp; &quot;f&quot; // &quot;&quot;
&quot;&quot; &amp;&amp; &quot;&quot; // &quot;&quot;</code></pre>
<blockquote>
<p>且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。</p>
</blockquote>
<h4 id="或运算符（-）"><a href="#或运算符（-）" class="headerlink" title="或运算符（||）"></a>或运算符（||）</h4><p>如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。</p>
<pre><code class="js">&quot;t&quot; || &quot;&quot; // &quot;t&quot;
&quot;t&quot; || &quot;f&quot; // &quot;t&quot;
&quot;&quot; || &quot;f&quot; // &quot;f&quot;
&quot;&quot; || &quot;&quot; // &quot;&quot;</code></pre>
<blockquote>
<p>或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。</p>
</blockquote>
<h4 id="三元条件运算符（-）"><a href="#三元条件运算符（-）" class="headerlink" title="三元条件运算符（ ? :）"></a>三元条件运算符（ ? :）</h4><p>三元条件运算符用问号（？）和冒号（：），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。</p>
<pre><code class="js">&quot;t&quot; ? true : false // true

0 ? true : false // false</code></pre>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><blockquote>
<p><a href="http://javascript.ruanyifeng.com/grammar/operator.html#toc14" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/grammar/operator.html#toc14</a></p>
</blockquote>
<h4 id="圆括号运算符"><a href="#圆括号运算符" class="headerlink" title="圆括号运算符"></a>圆括号运算符</h4><p>圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。</p>
<p>对象放在圆括号之中，则会返回对象的值，即对象本身。</p>
<pre><code class="js">var o = {p:1};

(o)
// Object {p: 1}</code></pre>
<h4 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h4><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</p>
<p>void运算符的优先性很高</p>
<pre><code class="js">&lt;a href=&quot;javascript:void(f())&quot;&gt;文字&lt;/a&gt;

//下面的代码会提交表单，但是不会产生页面跳转。

&lt;a href=&quot;javascript:void(document.form.submit())&quot;&gt;
文字&lt;/a&gt;</code></pre>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p>
<pre><code class="js">&quot;a&quot;, &quot;b&quot; // &quot;b&quot;

var x = 0;
var y = (x++, 10);
x // 1
y // 10</code></pre>
<h4 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h4><p>赋值运算符（=）和三元条件运算符（?:）是少数运算符的计算顺序是从右到左。</p>
<pre><code class="js">w = x = y = z;
q = a ? b : c ? d : e ? f : g;

w = (x = (y = z));
q = a ? b : (c ? d : (e ? f : g));</code></pre>
<p>下表按从最高到最低的优先级列出JavaScript运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>. [] ()</td>
<td>字段访问、数组下标、函数调用以及表达式分组</td>
</tr>
<tr>
<td>++ – - ~ ! delete new typeof void</td>
<td>一元运算符、返回数据类型、对象创建、未定义值</td>
</tr>
<tr>
<td>* / %</td>
<td>乘法、除法、取模</td>
</tr>
<tr>
<td>+ - +</td>
<td>加法、减法、字符串连接</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>移位</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>小于、小于等于、大于、大于等于、instanceof</td>
</tr>
<tr>
<td>== != === !==</td>
<td>等于、不等于、严格相等、非严格相等</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&#124;</td>
<td>按位或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>逻辑或</td>
</tr>
<tr>
<td>?:</td>
<td>条件</td>
</tr>
<tr>
<td>= oP=</td>
<td>赋值、运算赋值</td>
</tr>
<tr>
<td>,</td>
<td>多重求值</td>
</tr>
</tbody></table>
<p>[TOC]</p>
<h1 id="2016年4月27日"><a href="#2016年4月27日" class="headerlink" title="2016年4月27日"></a>2016年4月27日</h1><h2 id="javascript-8"><a href="#javascript-8" class="headerlink" title="javascript"></a>javascript</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>读取注释：</p>
<pre><code class="js">(function () { /*
line 1
line 2
line 3
*/}).toString().split(&#39;\n&#39;).slice(1, -1).join(&#39;\n&#39;)
// &quot;line 1 line 2 line 3&quot;</code></pre>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<ul>
<li>\0 代表没有内容的字符（\u0000）</li>
<li>\b 后退键（\u0008）</li>
<li>\f 换页符（\u000C）</li>
<li>\n 换行符（\u000A）</li>
<li>\r 回车键（\u000D）</li>
<li>\t 制表符（\u0009）</li>
<li>\v 垂直制表符（\u000B）</li>
<li>\‘ 单引号（\u0027）</li>
<li>\“ 双引号（\u0022）</li>
<li>\\ 反斜杠（\u005C）</li>
<li>\XXX 用三个八进制数（000到377）表示字符，XXX对应该字符的Unicode，比如\251表示版权符号。</li>
<li>\xXX 用两个十六进制数（00到FF）表示字符，XX对应该字符的Unicode，比如\xA9表示版权符号。</li>
<li>\uXXXX 用四位十六进制的Unicode编号代表某个字符，比如\u00A9表示版权符号。</li>
</ul>
<pre><code class="js">&#39;\251&#39; // &quot;©&quot;
&#39;\xA9&#39; // &quot;©&quot;
&#39;\u00A9&#39; // &quot;©&quot;

&#39;\172&#39; === &#39;z&#39; // true
&#39;\x7A&#39; === &#39;z&#39; // true
&#39;\u007A&#39; === &#39;z&#39; // true</code></pre>
<p>字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p>
<pre><code class="js">var s = &#39;hello&#39;;

delete s[0];
s // &quot;hello&quot;

s[1] = &#39;a&#39;;
s // &quot;hello&quot;

s[5] = &#39;!&#39;;
s // &quot;hello&quot;</code></pre>
<p>length属性返回字符串的长度，该属性也是无法改变的。</p>
<pre><code class="js">var s = &#39;hello&#39;;
s.length // 5

s.length = 3;
s.length // 5</code></pre>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>JavaScript使用Unicode字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。</p>
<p>每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。</p>
<h4 id="Base64转码"><a href="#Base64转码" class="headerlink" title="Base64转码"></a>Base64转码</h4><p>Base64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
<p>JavaScript原生提供两个Base64相关方法。</p>
<ul>
<li>btoa()：字符串或二进制值转为Base64编码</li>
<li>atob()：Base64编码转为原来的编码</li>
</ul>
<blockquote>
<p>这两个方法不适合非ASCII码的字符，会报错。 </p>
</blockquote>
<pre><code class="js">var string = &#39;Hello World!&#39;;
btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;
atob(&#39;SGVsbG8gV29ybGQh&#39;) // &quot;Hello World!&quot;</code></pre>
<p>要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。</p>
<pre><code class="js">function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode(&#39;你好&#39;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;
b64Decode(&#39;JUU0JUJEJUEwJUU1JUE1JUJE&#39;) // &quot;你好&quot;</code></pre>
<p>*<em>encodeURIComponent() *</em>函数可把字符串作为 URI 组件进行编码。</p>
<h4 id="escape-encodeURI-encodeURIComponent"><a href="#escape-encodeURI-encodeURIComponent" class="headerlink" title="escape,encodeURI,encodeURIComponent"></a>escape,encodeURI,encodeURIComponent</h4><ul>
<li>escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z</li>
<li>encodeURI不编码字符有82个：!，#，$，&amp;，’，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z</li>
<li>encodeURIComponent不编码字符有71个：!， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。                            </li>
</ul>
<pre><code class="html">&lt;script language=&quot;javascript&quot;&gt;document.write(&#39;&lt;a href=&quot;http://passport.baidu.com/?logout&amp;aid=7&amp;u=&#39;+encodeURIComponent (&quot;http://cang.baidu.com/bruce42&quot;)+&#39;&quot;&gt;退出&lt;/a&gt;&#39;);
&lt;/script&gt;</code></pre>
<ul>
<li>进行url跳转时可以整体使用encodeURI</li>
</ul>
<pre><code>Location.href=encodeURI(http://cang.baidu.com/do/s?word=百度&amp;ct=21);
</code></pre><ul>
<li>js使用数据时可以使用escape</li>
</ul>
<p>例如：搜藏中history纪录。</p>
<ul>
<li>escape对0-255以外的unicode值进行编码时输出%u****格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。</li>
</ul>
<p><strong>解码</strong></p>
<ul>
<li>unescape 方法</li>
<li>decodeURI 方法</li>
<li>decodeURIComponent 方法</li>
</ul>
<blockquote>
<p>资料：<a href="http://www.cnblogs.com/jhxk/articles/1634359.html" target="_blank" rel="noopener">http://www.cnblogs.com/jhxk/articles/1634359.html</a></p>
</blockquote>
<p>三个函数主要区别在于不编码字符的不同：</p>
<pre><code class="js">document.write(encodeURIComponent(&quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;)+ &quot;&lt;br /&gt;&quot;)
document.write(escape(&quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;)+ &quot;&lt;br /&gt;&quot;)
document.write(encodeURI(&quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;)+ &quot;&lt;br /&gt;&quot;)

//结果：
//!%23%24%26&#39;()*%2B%2C-.%2F%3A%3B%3D%3F%40_~
//%21%23%24%26%27%28%29*+%2C-./%3A%3B%3D%3F@_%7E
//!#$&amp;&#39;()*+,-./:;=?@_~</code></pre>
<h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><p><strong>不使用分号的情况</strong></p>
<ul>
<li>for和while循环</li>
</ul>
<pre><code class="js">for ( ; ; ) {
} // 没有分号

while (true) {
} // 没有分号


do {
  a--;
} while(a &gt; 0); // 分号不能省略</code></pre>
<ul>
<li>分支语句：if，switch，try</li>
</ul>
<pre><code class="js">if (true) {
} // 没有分号

switch () {
} // 没有分号

try {
} catch {
} // 没有分号</code></pre>
<ul>
<li>函数的声明语句</li>
</ul>
<pre><code class="js">function f() {
} // 没有分号


//但是函数表达式仍然要使用分号。
var f = function f() {
};</code></pre>
<p>如果本行的结尾或者下一行起首的，是(、[、+、-、/这五个字符中的一个，分号不会被自动添加。</p>
<p><strong>变量声明</strong></p>
<p>为了避免可能出现的问题，最好把变量声明都放在代码块的头部。</p>
<pre><code class="js">for (var i = 0; i &lt; 10; i++) {
  // ...
}

// 写成

var i;
for (i = 0; i &lt; 10; i++) {
  // ...
}</code></pre>
<p><strong>new命令</strong></p>
<p>JavaScript使用new命令，从构造函数生成一个新对象。</p>
<pre><code>var o = new myObject();</code></pre><p>一旦你忘了加上new，myObject()内部的this关键字就会指向全局对象，导致所有绑定在this上面的变量，都变成全局变量。</p>
<p><strong>相等和严格相等</strong></p>
<p>因为”相等”运算符会自动转换变量类型，造成很多意想不到的情况：</p>
<pre><code class="js">0 == &#39;&#39;// true
1 == true // true
2 == true // false
0 == &#39;0&#39; // true
false == &#39;false&#39; // false
false == &#39;0&#39; // true
’ \t\r\n &#39; == 0 // true</code></pre>
<p><strong>switch…case结构</strong></p>
<p><strong>switch…case</strong>结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。</p>
<p>switch…case不使用大括号，不利于代码形式的统一。</p>
<pre><code class="js">function doAction(action) {
  switch (action) {
    case &#39;hack&#39;:
      return &#39;hack&#39;;
      break;
    case &#39;slash&#39;:
      return &#39;slash&#39;;
      break;
    case &#39;run&#39;:
      return &#39;run&#39;;
      break;
    default:
      throw new Error(&#39;Invalid action.&#39;);
  }
}</code></pre>
<p>上面的代码建议改写成对象结构。</p>
<pre><code class="js">function doAction(action) {
  var actions = {
    &#39;hack&#39;: function () {
      return &#39;hack&#39;;
    },
    &#39;slash&#39;: function () {
      return &#39;slash&#39;;
    },
    &#39;run&#39;: function () {
      return &#39;run&#39;;
    }
  };

  if (typeof actions[action] !== &#39;function&#39;) {
    throw new Error(&#39;Invalid action.&#39;);
  }

  return actions[action]();
}
</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月28日"><a href="#2016年4月28日" class="headerlink" title="2016年4月28日"></a>2016年4月28日</h1><h2 id="javascript-9"><a href="#javascript-9" class="headerlink" title="javascript"></a>javascript</h2><h3 id="javascript原型与闭包"><a href="#javascript原型与闭包" class="headerlink" title="javascript原型与闭包"></a>javascript原型与闭包</h3><pre><code class="js">    function Fn() { }
    Fn.prototype.name = &#39;王福朋&#39;;
    Fn.prototype.getYear = function () {
        return 1988;
    };

    var fn = new Fn();
    console.log(fn.name);
    console.log(fn.getYear());</code></pre>
<blockquote>
<p>Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>
</blockquote>
<p>因为每个对象都有一个隐藏的属性:“<strong>__proto__</strong>”，这个属性引用了创建这个对象的函数的prototype。即：</p>
<pre><code>fn.__proto__ === Fn.prototype</code></pre><p>函数与对象之间，不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑。</p>
<p>Object 和 Array 都是函数：</p>
<pre><code class="js">console.log(typeof (Object));  // function
console.log(typeof (Array));  // function ```</code></pre>
<p><strong>每个函数都有一个属性叫做prototype。</strong></p>
<p>这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/proto.jpg" alt></p>
<blockquote>
<p>每个对象都有一个<strong>proto</strong>属性，指向创建该对象的函数的prototype。</p>
</blockquote>
<blockquote>
<blockquote>
<p><strong>Object.prototype是一个特例——它的<strong>proto</strong>指向的是null，切记切记！</strong></p>
</blockquote>
</blockquote>
<h4 id="Instanceof运算符"><a href="#Instanceof运算符" class="headerlink" title="Instanceof运算符"></a>Instanceof运算符</h4><p>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>
<p>Instanceof的判断队则是：沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/prototype.png" alt></p>
<h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</p>
<p><strong>hasOwnProperty()</strong>对自身的属性会返回true，原型链上的属性会返回false。这个方式是Function.prototype继承自Object.prototype的方法。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="Array对象的静态方法"><a href="#Array对象的静态方法" class="headerlink" title="Array对象的静态方法"></a>Array对象的静态方法</h4><ul>
<li>isArray方法</li>
</ul>
<p>Array.isArray方法用来判断一个值是否为数组。</p>
<pre><code class="js">var a = [1, 2, 3];

typeof a // &quot;object&quot;
Array.isArray(a) // true</code></pre>
<ul>
<li>valueOf方法，toString方法</li>
</ul>
<p>valueOf方法返回数组本身。</p>
<pre><code class="js">var a = [1, 2, 3];
a.valueOf() // [1, 2, 3]</code></pre>
<p>toString 方法返回数组的字符串形式。</p>
<pre><code class="js">var a = [1, 2, 3];
a.toString() // &quot;1,2,3&quot;

var a = [1, 2, 3, [4, 5, 6]];
a.toString() // &quot;1,2,3,4,5,6&quot;</code></pre>
<ul>
<li>push()，pop()</li>
</ul>
<p>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<pre><code class="js">var a = [];

a.push(1) // 1
a.push(&#39;a&#39;) // 2
a.push(true, {}) // 4
a // [1, &#39;a&#39;, true, {}]</code></pre>
<p>pop方法用于删除数组的最后一个元素，并返回该元素。</p>
<pre><code class="js">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

a.pop() // &#39;c&#39;
a // [&#39;a&#39;, &#39;b&#39;]

[].pop() // undefined</code></pre>
<ul>
<li>join()，concat()</li>
</ul>
<p>join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。</p>
<pre><code class="js">var a = [1, 2, 3, 4];

a.join(&#39; &#39;) // &#39;1 2 3 4&#39;
a.join(&#39; | &#39;) // &quot;1 | 2 | 3 | 4&quot;
a.join() // &quot;1,2,3,4&quot;</code></pre>
<p>[TOC]</p>
<h1 id="2016年4月29日"><a href="#2016年4月29日" class="headerlink" title="2016年4月29日"></a>2016年4月29日</h1><h2 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h2><p>CSS像素是一个抽象的单位，主要使用在浏览器上，用来精确的度量（确定）Web页面上的内容。一般情况下，CSS像素被称为与设备无关的像素（<strong>device-independent</strong>像素），简称为“<strong>DIPs</strong>”。在一个标准的显示密度下，一个CSS像素对应着一个设备像素。</p>
<p>在javascript中，<strong>“window.devicePixelRatio</strong>”可以用来获得相同的比率。</p>
<p><strong>window.devicePixelRatio</strong>是设备上物理像素和设备像素（device-independent pixels (dips)）的比例。他有一个计算公式：window.devicePixelRatio = 物理像素/dips。</p>
<p>dips可以用来区分视网膜设备还是非视网膜设备。</p>
<blockquote>
<p><a href="http://www.w3cplus.com/css/towards-retina-web.html" target="_blank" rel="noopener">http://www.w3cplus.com/css/towards-retina-web.html</a></p>
</blockquote>
<h3 id="Emulation-模拟器"><a href="#Emulation-模拟器" class="headerlink" title="Emulation 模拟器"></a>Emulation 模拟器</h3><ol>
<li>Device 设备设置<ul>
<li>model 模型选择</li>
<li>resolution 分辨率设置</li>
<li>Device pixel ratio 像素比设置</li>
</ul>
</li>
</ol>
<h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;</code></pre><ol>
<li>width [pixel_value | device-width]</li>
<li>user-scalable 是否允许缩放 （no||yes）</li>
<li>initial-scale 初始比例</li>
<li>minimum-scale 允许缩放的最小比例</li>
<li>maximum-scale 允许缩放的最大比例 </li>
<li>target-densitydpi [dpi_value | device-dpi | high-dpi | medium-dpi | low-dpi] —安卓系统开始放弃此属性。</li>
</ol>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>引入方式：</p>
<p>一、</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;index.css&quot; media=&quot;all and (min-width: 600px)&quot;&gt;</code></pre><p>二、</p>
<pre><code>@import url(&quot;css/reset.css&quot;) all and (min-width: 600px) ;</code></pre><p>使用@import的话，你必须时刻记得要将@import放到样式代码的最前面，否则它将会不起作用。避免使用@import 同样对网站性能有益。</p>
<p>三、</p>
<pre><code class="js">@media all and (min-width: 600px)
{
    .box
    {
        width:100px;
    }
}</code></pre>
<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><ol>
<li>all 所有媒体</li>
<li>braille 盲文触觉设备</li>
<li>embossed 盲文打印机</li>
<li>print 手持设备 </li>
<li>projection 打印预览</li>
<li>screen 彩屏设备</li>
<li>speech ‘听觉’类似的媒体类型</li>
<li>tty 不适用像素的设备</li>
<li>tv  电视</li>
</ol>
<h4 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h4><ol>
<li>(max-width:599px) </li>
<li>(min-width:600px) </li>
<li>(orientation:portrait) 竖屏</li>
<li>(orientation:landscape)        横屏</li>
<li>(-webkit-min-device-pixel-ratio: 2) 像素比</li>
</ol>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ol>
<li>and</li>
<li>not      not关键字是用来排除某种制定的媒体类型</li>
<li>only     only用来定某种特定的媒体类型</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-Container-With-Most-Water/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-Container-With-Most-Water/" itemprop="url">Container With Most Water</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Container With Most Water  </li>
</ol>
<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container. </p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先要明确一个我之前一直理解错的，它的题目是<font color="red">随意找2个木板构成木桶，容量最大，</font>我之前以为是所有的木板已经在它的位置上了，然后找其中容量最大的——你加的水是可以漫过中间比较短的板子的。</p>
<p>如果按题意来，就简单了。</p>
<p>我们用两个指针来限定一个水桶，left,right。<br>h[i]表示i木板高度。<br>Vol_max表示木桶容量最大值</p>
<blockquote>
<p>由于桶的容量由最短的那个木板决定：<br>Vol = min(h[left],h[right]) * (right - left)</p>
</blockquote>
<ul>
<li>left和right分别指向两端的木板。</li>
<li>left和right都向中央移动，每次移动left和Right中间高度较小的（因为反正都是移动一次，宽度肯定缩小1，这时候只能指望高度增加来增加容量，肯定是替换掉高度较小的，才有可能找到更大的容量。）</li>
<li>看新桶子的容量是不是大于Vol_max，直到left和right相交。</li>
</ul>
<p>代码如下：</p>
<pre><code class="java">public class Solution {
    public int maxArea(int[] height) {
       int l = 0,r = height.length-1;
       int i = height[l] &gt; height[r] ? r:l;
       int vol,vol_max = height[i]*(r-l);
       while(l &lt; r)
       {
           if(height[l] &lt; height[r])  l++;
           else r--;
           vol = Math.min(height[l],height[r]) * (r - l);
           if(vol &gt; vol_max)     vol_max = vol;
       }
       return vol_max;
    }
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-JS4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-JS4/" itemprop="url">JS4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2015年12月3日"><a href="#2015年12月3日" class="headerlink" title="2015年12月3日"></a>2015年12月3日</h1><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>面向对象：不了解原理的情况下，会使用功能。</p>
<p>对象：不了解内部结构，知道表面的各种操作。</p>
<p>Date、getFullYear、Array、sort（）</p>
<p>变量：自由的，不属于任何对象</p>
<p>属性：属于一个对象</p>
<pre><code class="javascript">var arr-[1,2,3,4];
arr.a=12;
arr.show=function(){//添加事件
    //方法
    alert(arr.a);//12
}

arr.show();</code></pre>
<p>不能在系统对象中随意添加方法、属性，否则会覆盖已有的方法、属性。</p>
<p>this:当前发生事件的对象，当前的方法属于谁。</p>
<p>window.show=function(){};&gt;&gt;&gt;&gt;function show(){};</p>
<pre><code class="javascript">var obj=new Object();

obj.name=&#39;blue&#39;;
obj.qq=&#39;12345&#39;

obj.showName=function(){
    alert(this.name);
}

obj.showName();
</code></pre>
<p><strong>添加<code>new</code></strong></p>
<pre><code class="javascript">function createPerson(name, qq)     //构造函数
{
    //系统偷偷替咱们做：
    //var this=new Object();

    //加工
    this.name=name;
    this.qq=qq;

    this.showName=function ()
    {
        alert(&#39;我的名字叫：&#39;+this.name);
    };
    this.showQQ=function ()
    {
        alert(&#39;我的QQ号：&#39;+this.qq);
    };

    //也会偷偷做一些：
    //return this;
}

var obj=new createPerson(&#39;blue&#39;, &#39;258248832&#39;);
var obj2=new createPerson(&#39;张三&#39;, &#39;45648979879&#39;);

obj.showName();
obj.showQQ();</code></pre>
<p>任何函数前面都可以加一个<code>new</code> ，系统会在里面自动创建一个新的空白对象<code>this</code>，最后会返回出去。</p>
<p><strong>原型</strong></p>
<pre><code class="javascript">var arr1=new Array(12,55,34,78,676);
var arr2=new Array(12,33, 1);

Array.prototype.sum=function () //原型》》》类似CSS中的class
//arr1.sum=function ()              //行间样式
{
    var result=0;

    for(var i=0;i&lt;this.length;i++)
    {
        result+=this[i];
    }

    return result;
};

alert(arr1.sum());
alert(arr2.sum());  </code></pre>
<table>
<thead>
<tr>
<th>css</th>
<th>&nbsp;</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>行间样式</td>
<td>一次给一组元素添加样式</td>
<td>原型</td>
</tr>
<tr>
<td>行间样式</td>
<td>一次给一个元素添加样式</td>
<td>给对象加东西（方法）</td>
</tr>
</tbody></table>
<blockquote>
<p>类似于<code>css</code>中的<code>class</code>方法。</p>
</blockquote>
<p>类、对象</p>
<p>类：模子<br>对象：产品（成品）</p>
<pre><code>var arr=new Array(1,2,3,4);</code></pre><p>Array   类<br>arr     对象</p>
<p>用构造函数加属性<br>用原型加方法</p>
<h1 id="2015年12月7日"><a href="#2015年12月7日" class="headerlink" title="2015年12月7日"></a>2015年12月7日</h1><h2 id="javascript-1"><a href="#javascript-1" class="headerlink" title="javascript"></a>javascript</h2><p><strong>把面向过程的程序，改写成面向对象的形式</strong></p>
<ul>
<li>原则<ul>
<li>不能有函数套函数，但可以有全局 变量</li>
</ul>
</li>
<li>过程<ul>
<li>onload  &gt;&gt;&gt;&gt;     构造函数</li>
<li>全局变量&gt;&gt;&gt;&gt;     属性</li>
<li>函数    &gt;&gt;&gt;&gt;     方法</li>
</ul>
</li>
</ul>
<h2 id="json与面向对象"><a href="#json与面向对象" class="headerlink" title="json与面向对象"></a>json与面向对象</h2><pre><code class="js">var json={
    name:&#39;blue&#39;,
    qq:&#39;23214323&#39;,
    showName:function(){
        alert(&#39;我的名字叫：&#39;+this.name);
    },
    showQQ:function(){
        alert(&quot;我的QQ号是：&quot;+this.qq);
    }
};
json.showName();
josn.showQQ();</code></pre>
<p><strong>call</strong><br><code>call</code>可以改变改变<code>this</code>的指向对象；</p>
<pre><code class="js">function a(){alert(this)};
a();//object Window
a.call(12);//12</code></pre>
<p><strong>原形的继承</strong></p>
<pre><code class="js">for(var i in A.prototype){
    B.prototype[i]=A.prototype[i];
}
B.prototype.fn=function(){
    alert(&quot;abc&quot;);
}//函数B特有的方法。</code></pre>
<p><strong>本地对象</strong>（非静态对象）<br>常用对象：<code>Object</code>,<code>Function</code>,<code>Array</code>,<code>String</code>,<code>Boolean</code>,<code>Number</code>,<code>Date</code>,<code>RegExp</code>,<code>Error</code>。</p>
<p><strong>内置对象</strong>（静态对象）</p>
<p><code>Math()</code>，直接使用它的方法就可以了（例如<code>Math.ceil()</code>)。</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><pre><code>window.open(&quot;http://www.163.com&quot;);//打开一个窗口</code></pre><p><code>write()</code>：可以识别<strong>标签</strong>。</p>
<p><code>window.navigator.userAgent</code>:可以显示浏览器信息。</p>
<p><code>window.lacation</code>:可以显示当前页面的地址，或者可以赋值转到某地址。</p>
<p><code>document.documentElement.clientWidth</code>:可视区的宽；<br><code>document.documentElement.clientHeight</code>:可视区的高</p>
<p>IE:<code>document.documentElement.scrollTop</code>:滚动距离（上面隐藏的距离）；</p>
<p>Chrome:<code>document.body.scrollTop</code>:滚动距离（上面隐藏的距离）；</p>
<p><strong>系统对话框</strong></p>
<ul>
<li>警告框：alert（”内容”),没有返回值。</li>
<li>选择框：confirm(“提问的内容”)，返回<code>boolean</code>;</li>
<li>输入框：prompt(),返回字符串或null。</li>
</ul>
<p><strong>widow对象常用事件</strong></p>
<ul>
<li>onload</li>
<li>onscroll（滚动事件）</li>
<li>onresize（调节窗口大小事件）</li>
<li></li>
</ul>
<h1 id="2015年12月9日"><a href="#2015年12月9日" class="headerlink" title="2015年12月9日"></a>2015年12月9日</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie特点：</p>
<ul>
<li>同一个网站的所有页面共享一套cookie</li>
<li>数量、大小有限</li>
<li>过期时间</li>
</ul>
<p><strong>Date()对像</strong></p>
<pre>
Date()          返回当日的日期和时间。
getDate()       从 Date 对象返回一个月中的某一天 (1 ~ 31)。
getDay()        从 Date 对象返回一周中的某一天 (0 ~ 6)。
getMonth()      从 Date 对象返回月份 (0 ~ 11)。
getFullYear()   从 Date 对象以四位数字返回年份。

setDate()       设置 Date 对象中月的某一天 (1 ~ 31)。
setMonth()      设置 Date 对象中月份 (0 ~ 11)。
setFullYear()   设置 Date 对象中的年份（四位数字）。
</pre>

<p>javascript使用cookie</p>
<ul>
<li>document.cookie</li>
</ul>
<p>设置cookie函数</p>
<pre><code class="js">function setCookie(name,value,iDay){
    var oDate=new Date();
    oDate.setDate(oDate.getDate()+iDay);
    document.cookie=name+&#39;=&#39;+value+&#39;;expires=&#39;+oDate;
}

function getCookie(name){
    var arr=document.cookie.split(&quot;; &quot;);
    for(var i=0;i&lt;arr.length;i++){
        var arr2=arr[i].split(&quot;=&quot;);
        if(arr2[0]==name){
            return arr2[1];
        }
        return &#39;&#39;;
    }
}

function removeCookie(name){
    setCookie(name,1,-1);
}</code></pre>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote>
<p>强大的字符串匹配工具</p>
</blockquote>
<p><code>search()</code>:返回寻找的字符串的位置，没有就会返回-1；<br><code>charAt()</code>:返回某个指定位置下的字符；<br><code>substring()</code>:获取子字符串； //不包括结束位置<br><code>split()</code>:分割字符串，获得数组。</p>
<pre><code class="js">var str=&#39;abcdef&#39;;

alert(str.search(&#39;u&#39;));     //位置, -1
alert(str.charAt(0));       //&#39;a&#39;
alert(str.substring(2, 5));   //cde,不包括结束位置</code></pre>
<p><strong>null与undefined</strong></p>
<pre><code class="js">5+null
//5
6+undefined
//NaN</code></pre>
<blockquote>
<p>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p>
</blockquote>
<p>目前的用法</p>
<p><strong>null表示”没有对象”，即该处不应该有值。典型用法是：</strong></p>
<ul>
<li><p>作为函数的参数，表示该函数的参数不是对象。</p>
</li>
<li><p>作为对象原型链的终点。</p>
<p>Object.getPrototypeOf(Object.prototype)// null</p>
</li>
</ul>
<p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</strong>。典型用法是：</p>
<ol>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>对象没有赋值的属性，该属性的值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。</li>
</ol>
<pre><code class="js">var i;
i // undefined

function f(x){console.log(x)}
f() // undefined

var  o = new Object();
o.p // undefined

var x = f();
x // undefined</code></pre>
<p><strong>正则表达式写法</strong></p>
<pre><code class="js">var re=new RegExp(&#39;b&#39;, &#39;i&#39;);//js风格，&#39;b&#39;就代表字母&#39;b&#39;,&#39;i&#39;代表忽略大小写。
//或者
var re=/a/i;//perl风格

alert(str.search(re));//1  </code></pre>
<p><strong>转义字符</strong></p>
<p><code>i</code>:代表忽略大小写;</p>
<p><code>g</code>:全局匹配；</p>
<p><code>+</code>:若干个；</p>
<p><code>|</code>:或</p>
<p><code>[]</code>:里面的其中一个跟外面的组合匹配；例如’var re=/[apx]pc/g;’。</p>
<p><code>[^a-z]</code>:排除英文字母，[0-9]等于<code>\d</code>。</p>
<p><code>^</code>:在<code>[]</code>里表示排除，在其他位置是行首的意思。</p>
<p><code>$</code>:行尾；</p>
<blockquote>
<p><code>re=/^\w+@[a-z0-9]+\.[a-z]+$/i</code>,邮箱校验，有<code>^</code>与<code>$</code>可以限制整个字符串都要符合正则表达式，而不是部分。</p>
</blockquote>
<p><code>.</code>(点):任意字符；</p>
<p><code>\d</code>:匹配数字；[0-9]</p>
<p><code>\w</code>:英文、数字、下划线;[a-z0-9]</p>
<p><code>\s</code>:空白字符;</p>
<p><code>\D</code>:[^0-9];</p>
<p><code>\W</code>:[^a-z0-9];</p>
<p><strong>量词</strong></p>
<p><code>{n}</code>:正好出现n次；</p>
<p><code>\d{8}</code>:至少八次;<br><code>[1-9]\d{7}</code>:匹配电话号码要求；</p>
<p><code>{n,m}</code>:最少n次，最多m次；</p>
<p><code>{n,}</code>:最少n次，最多不限；</p>
<p><code>+</code>:{1，};</p>
<p><code>?</code>:{0,1}，可以有，或者没有。</p>
<p><code>(0\d{2,3}-)?[1-9]\d{7}(-\d{1,5})?</code>,固定电话规则；</p>
<p><code>*</code>:{0,}任意次，不建议使用。</p>
<p><strong>常用函数</strong></p>
<p><code>match()</code>:把所有匹配的都提取出去。</p>
<p><code>test()</code>:检验是否符合正则要求，返回boolean；只要字符串一部分要求，就会返回true，</p>
<pre><code class="js">var str=&#39;abcdef 8223 234 24 346 35dfsh8 h9 h98 h98898h 89h&#39;;
var re=/\d+/g;

alert(str.match(re));//8223 234 24 346 35 8 9 98 98898 89
</code></pre>
<h1 id="2015年12月10日"><a href="#2015年12月10日" class="headerlink" title="2015年12月10日"></a>2015年12月10日</h1><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>javascript对大小写敏感（关键字、函数名、变量名等），标识符的首字符必须是<strong>字母</strong>、<strong>下划线 <code>_</code></strong>或者<strong><code>$</code>符</strong>，其后的字符可以含<strong>数字</strong></p>
<p><strong>匿名函数自执行</strong></p>
<pre><code class="js">(function(){
        var a=10;
        alert(a);
    })();
</code></pre>
<h2 id="关于冒泡和捕获"><a href="#关于冒泡和捕获" class="headerlink" title="关于冒泡和捕获"></a>关于冒泡和捕获</h2><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>捕获过程即事件从最外层的元素开始触发，然后逐渐触发到当前元素。</p>
<p>例如对于如下的 DOM 结构：</p>
<pre><code class="html">&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;</code></pre>
<p>如果 child 元素触发事件，那么捕获的过程为：body -&gt; div.father -&gt; div.child 。</p>
<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>冒泡与捕获相反，从当前元素开始触发，逐渐向外扩展直到最外层元素或者被终止。</p>
<p>例如对于上面的 DOM 结构，如果 child 元素触发事件，那么冒泡的过程为：div.child -&gt; div.father -&gt; body 。</p>
<p>如何使用</p>
<p>在支持的浏览器中，可以通过参数来控制发生的过程究竟是在捕获还是在冒泡，如下：</p>
<p><code>element.addEventListener(&#39;click&#39;, function () {}, false);</code><br>其中第三个参数为 false 表示发生在冒泡阶段（默认），为 true 表示发生在捕获阶段。</p>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><blockquote>
<p>设想一下这种场景，有一个列表，其中点击列表项需要触发一个事件，假如说这个列表有 1000 项，那是不是需要绑定 1000 次事件？ 如果这还不够麻烦的话，那如果列表内容也是可变的，每次添加新的还需要再绑定事件，删除已有的也需要删除相应的事件，那么我添加 1000 项再删除 1000 次呢？</p>
</blockquote>
<p>我们现在已经知道了事件存在冒泡的机制，那么对于类似的场景，我们可以通过事件代理来处理。 直接在外层的父节点上绑定事件监听，再通过 target 属性获取到事件触发的元素即可。</p>
<pre><code class="html">    &lt;ul id=&quot;list&quot;&gt;
        &lt;li&gt;test1&lt;/li&gt;
        &lt;li&gt;test2&lt;/li&gt;
        &lt;li&gt;test3&lt;/li&gt;
        &lt;li&gt;test4&lt;/li&gt;
        &lt;li&gt;test5&lt;/li&gt;
        &lt;li&gt;test6&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.getElementById(&#39;list&#39;);
        ul.addEventListener(&#39;click&#39;, function (e) {
            console.log(&#39;事件代理成功，触发事件的元素为：&#39;);
            console.log(e.target);
        }, false);
    &lt;/script&gt;
</code></pre>
<p>target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。</p>
<h3 id="阻止行为"><a href="#阻止行为" class="headerlink" title="阻止行为"></a>阻止行为</h3><p>在事件处理函数中，可以通过<code>e.stopPropagation()</code> 来阻止事件冒泡，通过<code>e.preventDefault()</code>来阻止默认行为的触发。</p>
<h1 id="2015年12月11日"><a href="#2015年12月11日" class="headerlink" title="2015年12月11日"></a>2015年12月11日</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="vi-amp-vim-打开-关闭-保存-文件"><a href="#vi-amp-vim-打开-关闭-保存-文件" class="headerlink" title="vi &amp; vim 打开 关闭 保存 文件"></a>vi &amp; vim 打开 关闭 保存 文件</h3><ul>
<li><p>创建、打开文件：<br>输入<code>$ vi [filename]</code>,此时 vi 处于默认的命令模式，键盘输入字母 ‘ i ’ 进入最常用的插入编辑模式.</p>
</li>
<li><p>保存文件<br>按下 “ ESC ” 键，退出编辑模式，切换到命令模式.<br>在命令模式下键入：<br>“ ZZ “<br>或者：<br>“ :wq “<br>保存修改并且退出 vi </p>
<p>如果只想保存文件，则键入：<br>“ :w “</p>
<p>放弃所有文件修改：<br>按下 “ ESC “ 键进入命令模式，键入 “ :q! “ </p>
<p>放弃所有文件修改，但不退出 vi ,即回退到文件打开后最后一次保存操作的状态，继续进行文件操作：<br>按下 “ ESC “ 键进入命令模式，键入 “ :e! “ ：</p>
</li>
</ul>
<blockquote>
<p>参考资料<a href="http://blog.chinaunix.net/uid-20671208-id-3721795.html" target="_blank" rel="noopener">连接</a></p>
</blockquote>
<p><code>cd</code>:根目录；</p>
<p><code>ls</code>:显示目录列表</p>
<p><code>touch Readme</code>:生成一个叫<code>Readme</code>的文件。</p>
<p><code>git mv hellogit.rb helloworld.rb</code>:重命名；</p>
<p><code>git commit -m &quot;rename hellogit.rb&quot;</code>:再次 提交。</p>
<h1 id="2015年12月13日"><a href="#2015年12月13日" class="headerlink" title="2015年12月13日"></a>2015年12月13日</h1><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li>Transition</li>
</ul>
<blockquote>
<p>css的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code>transition ： [&lt;&#39;transition-property&#39;&gt; || &lt;&#39;transition-duration&#39;&gt; || &lt;&#39;transition-timing-function&#39;&gt; || &lt;&#39;transition-delay&#39;&gt; [, [&lt;&#39;transition-property&#39;&gt; || &lt;&#39;transition-duration&#39;&gt; || &lt;&#39;transition-timing-function&#39;&gt; || &lt;&#39;transition-delay&#39;&gt;]]* </code></pre><ul>
<li>transition-property:</li>
</ul>
<pre><code class="html">    transition-property ： none | all | [ &lt;IDENT&gt; ] [ &#39;,&#39; &lt;IDENT&gt; ]*</code></pre>
<blockquote>
<p>transition-property是用来指定当元素其中一个属性改变时执行transition效果，其主要有以下几个值：none(没有属性改变)；all（所有属性改变）这个也是其默认值；indent（元素属性名）。当其值为none时，transition马上停止执行，当指定为all时，则元素产生任何属性值变化时都将执行transition效果，ident是可以指定元素的某一个属性值。</p>
</blockquote>
<ul>
<li>transition-duration:</li>
</ul>
<pre><code class="html">transition-duration ： &lt;time&gt; [, &lt;time&gt;]* </code></pre>
<blockquote>
<p>transition-duration是用来指定元素 转换过程的持续时间，取值：<time>为数值，单位为s（秒）或者ms(毫秒),可以作用于所有元素，包括:before和:after伪元素。其默认值是0，也就是变换时是即时的。</time></p>
</blockquote>
<ul>
<li>transition-timing-function:</li>
</ul>
<blockquote>
<p>transition-timing-function的值允许你根据时间的推进去改变属性值的变换速率，transition-timing-function有5个可能值：</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/transition-timing-function.png" alt="text"></p>
<blockquote>
<p>或者可以自定义贝塞尔速度曲线，例如<code>cubic-bezier(0.42, 0, 0, 1.02)</code>;</p>
</blockquote>
<ul>
<li>transition-delay:</li>
</ul>
<pre><code class="html">  transition-delay ： &lt;time&gt; [, &lt;time&gt;]* </code></pre>
<blockquote>
<p>transition-delay是用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行transition效果，其取值：<time>为数值，单位为s（秒）或者ms(毫秒)，其使用和transition-duration极其相似，也可以作用于所有元素，包括:before和:after伪元素。 默认大小是”0”，也就是变换立即执行，没有延迟。</time></p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/transition-suji.png" alt></p>
<h1 id="2015年12月14日"><a href="#2015年12月14日" class="headerlink" title="2015年12月14日"></a>2015年12月14日</h1><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><pre><code class="html">transform ： none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]* 
   也就是：
transform: rotate | scale | skew | translate |matrix;</code></pre>
<ul>
<li><p>旋转rotato</p>
<p>语法：<code>rotato(&lt;angle&gt;)</code>,通过指定的角度参数对原元素指定一个2D rotation（2D 旋转），需先有transform-origin属性的定义。transform-origin定义的是旋转的基点，其中angle是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数。</p>
</li>
<li><p>移动translate</p>
<p>语法：<code>translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])</code>。</p>
<p>移动translate我们分为三种情况：<code>translate(x,y)</code>水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）；<code>translateX(x)</code>仅水平方向移动（X轴移动）；<code>translateY(Y)</code>仅垂直方向移动（Y轴移动。</p>
</li>
<li><p>缩放scale</p>
<p>语法：<code>scale(&lt;number&gt;[, &lt;number&gt;])</code>,如果第二个参数未提供，则取与第一个参数一样的值。<code>scale(X,Y)</code>是用于对元素进行缩放，可以通过<code>transform-origin</code>对元素的基点进行设置,默认是中心位置。</p>
<p>如：transform:scale(2,1.5):<br><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/scale-x-y.png" alt></p>
<p>如transform:scaleX(2):<br><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/scale-x.png" alt></p>
<p>如transform:scaleY(2):<br><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/scale-y.png" alt></p>
</li>
<li><p>扭曲skew</p>
<p>语法：<code>skew(&lt;angle&gt; [, &lt;angle&gt;])</code>,第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。同样是以元素中心为基点，我们也可以通过<code>transform-origin</code>来改变元素的基点位置。</p>
<p>如：transform:skew(30deg,10deg):</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img.skew-x-y.png" alt></p>
<p> 如 transform:skewX(30deg):</p>
<p> <img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/skew-x.png" alt></p>
<p> 如：transform:skewY（10deg):</p>
<p> <img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/skew-y.png" alt></p>
</li>
<li><p>元素基点transform-origin</p>
</li>
</ul>
<p><code>transform-origin(X,Y)</code>:用来设置元素的运动的基点（参照点）。默认点是元素的中心点。其中X和Y的值可以是百分值,em,px，其中X也可以是字符参数值left,center,right；</p>
<div>
1、top left | left top 等价于 0 0 | 0% 0%

<p>2、top | top center | center top 等价于 50% 0</p>
<p>3、right top | top right 等价于 100% 0</p>
<p>4、left | left center | center left 等价于 0 50% | 0% 50%</p>
<p>5、center | center center 等价于 50% 50%（默认值）</p>
<p>6、right | right center | center right 等价于 100% 50%</p>
<p>7、bottom left | left bottom 等价于 0 100% | 0% 100%</p>
<p>8、bottom | bottom center | center bottom 等价于 50% 100%</p>
<p>9、bottom right | right bottom 等价于 100% 100%</p>
</div>

<h1 id="2015年12月16日"><a href="#2015年12月16日" class="headerlink" title="2015年12月16日"></a>2015年12月16日</h1><h2 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h2><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>综合语法：</p>
<pre><code class="html5">  @keyframes IDENT {
     from {
       Properties:Properties value;
     }
     Percentage {
       Properties:Properties value;
     }
     to {
       Properties:Properties value;
     }
   }
   或者全部写成百分比的形式：
   @keyframes IDENT {
      0% {
         Properties:Properties value;
      }
      Percentage {
         Properties:Properties value;
      }
      100% {
         Properties:Properties value;
      }
    }</code></pre>
<p><code>INENT</code>:是动画名称；<br><code>Percentage</code>:过程的百分比，可以添加多个。<br><code>value</code>：属性的属性值。</p>
<p><strong>1.animation-name</strong></p>
<pre><code class="css3">animation-name: none | IDENT[,none | IDENT]*;</code></pre>
<p><code>animation-name</code>:是用来定义一个动画的名称，其主要有两个值：IDENT是由Keyframes创建的动画名，换句话说此处的IDENT要和Keyframes中的IDENT一致。</p>
<p><strong>2.animation-duration</strong></p>
<pre><code class="css3">animation-duration: &lt;time&gt;[,&lt;time&gt;]*</code></pre>
<p>animation-duration是用来指定元素播放动画所持续的时间长，取值:<time>为数值，单位为s （秒.）其默认值为“0”。这个属性跟transition中的transition-duration使用方法是一样的。</time></p>
<p><strong>3.animation-timing-function</strong></p>
<pre><code class="css3">animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out |step-start | step-end | steps(&lt;integer&gt;[, [ start | end ] ]?)| cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, ease | linear | ease-in | ease-out | ease-in-out |step-start | step-end | steps(&lt;integer&gt;[, [ start | end ] ]?)| cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)]* 
</code></pre>
<p><strong>step-start</strong>：等同于 steps(1, start);<br><strong>step-end</strong>：等同于 steps(1, end);<br><strong>steps(&lt;integer&gt;[, [ start | end ] ]?)</strong>：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。;</p>
<p>animation-timing-function:是指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。</p>
<p><strong>4.animation-delay</strong></p>
<pre><code class="css3">animation-delay: &lt;time&gt;[,&lt;time&gt;]*</code></pre>
<p>animation-delay:是用来指定元素动画开始时间。取值为<time>为数值，单位为s(秒)，其默认值也是0。</time></p>
<p><strong>5.animation-iteration-count</strong></p>
<pre><code class="css3">animation-iteration-count:infinite | &lt;number&gt; [, infinite | &lt;number&gt;]*</code></pre>
<p>animation-iteration-count是用来指定元素播放动画的循环次数，其可以取值<number>为数字，其默认值为“1”；infinite为无限次数循环。</number></p>
<p><strong>6.animation-diretion</strong></p>
<pre><code class="css3">animation-direction: normal | reverse | alternate | alternate-reverse [,normal | reverse | alternate | alternate-reverse]* </code></pre>
<p>animation-direction是用来指定元素动画播放的方向，取值:<br>normal：正常方向;<br>reverse：反方向运行;<br>alternate：动画先正常运行再反方向运行，并持续交替运行;<br>alternate-reverse:动画先反运行再正方向运行，并持续交替运行;</p>
<p><strong>7.animation-play-state</strong></p>
<pre><code class="css3">animation-play-state:running | paused [, running | paused]* </code></pre>
<p>animation-play-state主要是用来控制元素动画的播放状态。其主要有两个值，running和paused其中running为默认值。可以通过paused将正在播放的动画停下了，也可以通过running将暂停的动画重新播放，我们这里的重新播放不一定是从元素动画的开始播放，而是从你暂停的那个位置开始播放。</p>
<p><strong>总结</strong></p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/animation-pro.png" alt></p>
<p>综合语法：</p>
<pre><code class="css3"> animation:[&lt;animation-name&gt; || &lt;animation-duration&gt; || &lt;animation-timing-function&gt; || &lt;animation-delay&gt; || &lt;animation-iteration-count&gt; || &lt;animation-direction&gt;] [, [&lt;animation-name&gt; || &lt;animation-duration&gt; || &lt;animation-timing-function&gt; || &lt;animation-delay&gt; || &lt;animation-iteration-count&gt; || &lt;animation-direction&gt;] ]* </code></pre>
<p><strong>补充：animation-fill-mode</strong></p>
<pre><code class="css3">animation-fill-mode：&lt;single-animation-fill-mode&gt;[,&lt;single-animation-fill-mode&gt;]*
&lt;single-animation-fill-mode&gt; = none | forwards | backwards | both</code></pre>
<p><strong>none</strong>：默认值。不设置对象动画之外的状态;<br><strong>forwards</strong>：设置对象状态为动画结束时的状态;<br><strong>backwards</strong>：设置对象状态为动画开始时的状态;<br><strong>both</strong>：设置对象状态为动画结束或开始的状态;</p>
<h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>语法：</p>
<pre><code class="html5">E {box-shadow: &lt;length&gt; &lt;length&gt; &lt;length&gt;?&lt;length&gt;?||&lt;color&gt;}
也就是：
E {box-shadow:inset x-offset y-offset blur-radius spread-radius color}
换句说：
对象选择器 {box-shadow:投影方式 X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色}</code></pre>
<blockquote>
<p>box-shadow和text-shadow一样可以使用一个或多个投影，如果使用多个投影时必须需要用逗号“，”分开。</p>
</blockquote>
<p><strong>阴影类型</strong>：此参数是一个可选值，如果不设值，其默认的投影方式是外阴影；如果取其唯一值“inset”,就是将外阴影变成内阴影，也就是说设置阴影类型为“inset”时，其投影就是内阴影；</p>
<p><strong>X-offset</strong>:是指阴影水平偏移量其值可以是正负值可以取正负值，如果值为正值，则阴影在对象的右边，反之其值为负值时，阴影在对象的左边；</p>
<p><strong>Y-offset</strong>:是指阴影的垂直偏移量，其值也可以是正负值，如果为正值，阴影在对象的底部，反之其值为负值时，阴影在对象的顶部；</p>
<p><strong>阴影模糊半径</strong>：此参数是可选，，但其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；</p>
<p><strong>阴影扩展半径</strong>：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值是，则缩小</p>
<p><strong>阴影颜色</strong>：此参数可选，如果不设定任何颜色时，浏览器会取默认色，但各浏览器默认色不一样，特别是在webkit内核下的safari和chrome浏览器将无色，也就是透明，建议不要省略此参数。</p>
<p>盒子模型可添加颜色的属性的层次：</p>
<p><strong>边框&gt;内阴影&gt;背景图片&gt;背景颜色&gt;外阴影</strong></p>
<p>因为大家都知道，我们的背景图片是在背景颜色之上的。</p>
<h3 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h3><p>语法：</p>
<p>** &lt; linear-gradient&gt;** = linear-gradient([ [ &lt; angle&gt; | to &lt; side-or-corner&gt; ] ,]? &lt; color-stop&gt;[, &lt; color-stop&gt;]+)<br>** &lt; side-or-corner&gt; <strong>= [left | right] || [top | bottom]<br>** &lt; color-stop&gt;</strong> = &lt; color&gt; [ &lt; length&gt; | &lt; percentage&gt; ]?</p>
<p>** &lt; angle&gt;<strong>：用角度值指定渐变的方向（或角度）。<br>**to left</strong>：设置渐变为从右到左。相当于: 270deg<br><strong>to right</strong>：设置渐变从左到右。相当于: 90deg<br><strong>to top</strong>:设置渐变从下到上。相当于: 0deg<br><strong>to bottom</strong>:设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。<br>** &lt; color-stop&gt;<strong>: 用于指定渐变的起止颜色：<br>** &lt; color&gt;</strong>指定颜色。<br>** &lt; length&gt;<strong>：用长度值指定起止色位置。不允许负值<br>** &lt; percentage&gt;</strong>：用百分比指定起止色位置。</p>
<p>例子：</p>
<pre><code class="html5">linear-gradient(#fff, #333);
linear-gradient(to bottom, #fff 20px, #333);
linear-gradient(to top, #333, #fff);
linear-gradient(180deg, #fff, #333);
linear-gradient(to bottom, #fff 0%, #333 100%);</code></pre>
<h3 id="repeating-linear-gradient"><a href="#repeating-linear-gradient" class="headerlink" title="repeating-linear-gradient()"></a>repeating-linear-gradient()</h3><p><strong>用重复的线性渐变创建图像。</strong></p>
<ul>
<li>repeating-linear-gradient()的语法与linear-gradient()相同。</li>
<li>示例：</li>
</ul>
<pre><code class="css3">background:repeating-linear-gradient(#f00, #ff0 10%, #f00 15%);
background:repeating-linear-gradient(to bottom, #f00, #ff0 10%, #f00 15%);
background:repeating-linear-gradient(180deg, #f00, #ff0 10%, #f00 15%);
background:repeating-linear-gradient(to top, #f00, #ff0 10%, #f00 15%);</code></pre>
<p>效果：<br><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/repeating-linear-gradient.png" alt></p>
<h1 id="2015年12月17日"><a href="#2015年12月17日" class="headerlink" title="2015年12月17日"></a>2015年12月17日</h1><h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p>描述一个色彩有三种途径，按色彩的<strong>色相</strong>，<strong>饱和度</strong>，<strong>亮度</strong>。</p>
<ul>
<li>彩度</li>
</ul>
<p>下图显示的是彩度（Chroma）或者称为饱和度（saturation）：反应的是色彩相对于灰度的纯度</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100513052116804.jpg" alt></p>
<ul>
<li>亮度</li>
</ul>
<p>下图显示的是彩度（Chroma）或者称为饱和度（saturation）：反应的是色彩相对于灰度的纯度。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100513052913196.jpg" alt></p>
<ul>
<li>减色</li>
</ul>
<p>当使用颜料或者使用涂料等方式时候，我们使用减色法。减色法意味着由白色开始，随色色彩的叠加，直到黑色。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100513071353897.gif" alt></p>
<blockquote>
<p>CMYK 色彩模型用于减色法</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100513071354656.gif" alt></p>
<blockquote>
<p>这个色轮用于颜料色彩搭配–减色法</p>
</blockquote>
<ul>
<li>加色</li>
</ul>
<p>如果你使用电脑来处理色彩，那么电脑上的色彩是由加色法呈现的。加色法意味着色彩是从黑色开始，随着色彩的叠加，逐渐变亮，最后成为白色。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100513071356825.gif" alt> </p>
<blockquote>
<p>这是RGB色彩模型表示加色法，白色由R红色，G绿色,蓝色叠加而成。</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100513071356624.gif" alt></p>
<blockquote>
<p>这个色轮用于加色。</p>
</blockquote>
<ul>
<li>色环</li>
</ul>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/20100515092156201.gif" alt></p>
<blockquote>
<p>色环中根据亮度又分为积极色（ Active colors，也可以称为暖色）和消极色（ Passive colors也可以叫做冷色），积极色表现出活跃，积极的一面，消极色则相反。<br>此外还有<strong>原色</strong>、<strong>间色（次色）</strong>、<strong>三级色</strong>、<strong>互补色</strong>、<strong>类似色</strong>。<br>参考：<a href="http://www.peise.net/info/2010/0514/28.html" target="_blank">链接；</a></p>
</blockquote>
<h1 id="2015年12月18日"><a href="#2015年12月18日" class="headerlink" title="2015年12月18日"></a>2015年12月18日</h1><h2 id="javascript-2"><a href="#javascript-2" class="headerlink" title="javascript"></a>javascript</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre><code class="js">oDiv.onclick=function(){
    alert(this);
}</code></pre>
<blockquote>
<p>给一对象添加<strong>事件</strong>（click事件），等于给一个对象添加<strong>方法</strong>（function）；</p>
</blockquote>
<p><strong>this</strong></p>
<ul>
<li>当前发生事件的对象</li>
<li>当前的方法属于谁，this就是谁。</li>
</ul>
<p><strong>对象的组成</strong></p>
<ul>
<li><p>方法——函数：过程、动态的</p>
</li>
<li><p>属性——变量：状态、静态的</p>
<p><strong>类与对象</strong></p>
<p>类：模子<br>对象：产品</p>
</li>
</ul>
<pre><code>var arr=new Array(1,2,3,4,5)</code></pre><p>Array—– 类<br>arr  —– 对象</p>
<p>用构造函数加属性<br>用原型加方法</p>
<p><strong>继承</strong></p>
<pre><code class="javascript">A.prototype.show=function ()
{
    alert(this.abc);
};
for(var i in A.prototype)
{
    B.prototype[i]=A.prototype[i];

}
B.prototype.fn=function(){
    alert(&#39;abc&#39;);
}
var objA=new A();
var objB=new B();

objA.fn();//error.
</code></pre>
<p><code>call()</code>:可以改变函数<code>this</code>的指向。</p>
<pre><code class="javascript">function A(){
    this.abc=12;
}

function B(){
    //这里的this指--&gt;new B(),把A的this指向了B的this，本来给A加的属性，变成给B加的属性。
    A.call(this);
}</code></pre>
<h1 id="2015年12月20日"><a href="#2015年12月20日" class="headerlink" title="2015年12月20日"></a>2015年12月20日</h1><h2 id="jQuery-1"><a href="#jQuery-1" class="headerlink" title="jQuery"></a>jQuery</h2><ul>
<li>对比</li>
</ul>
<pre><code class="js">function getByClass(oParent, sClass)
{
 var aEle=oParent.getElementsByTagName(&#39;*&#39;);
 var aResult=[];
 var i=0;

 for(i=0;i&lt;aEle.length;i++)
 {
  if(aEle[i].className==sClass)
  {
   aResult.push(aEle[i]);
  }
 }

 return aResult;
}</code></pre>
<p>使用jQuery可以简写成：<code>$(&#39;sClass&#39;)</code>。</p>
<ul>
<li>跳转</li>
</ul>
<pre><code class="html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=http://www.taobao.com&quot;&gt;</code></pre>
<p>网页会在3秒后跳转到淘宝网。</p>
<ul>
<li>jQuery选择器</li>
</ul>
<div>
<table class="dataintable">
<tbody><tr>
<th>选择器</th>
<th>实例</th>
<th>选取</th>
</tr>

<tr>
<td><a href="/jquery/selector_all.asp" title="jQuery * 选择器">*</a></td>
<td>$("*")</td>
<td>所有元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_id.asp" title="jQuery # 选择器">#<i>id</i></a></td>
<td>$("#lastname")</td>
<td>id="lastname" 的元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_class.asp" title="jQuery . 选择器">.<i>class</i></a></td>
<td>$(".intro")</td>
<td>所有 class="intro" 的元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_element.asp" title="jQuery element 选择器"><i>element</i></a></td>
<td>$("p")</td>
<td>所有 &lt;p&gt; 元素</td>
</tr>

<tr>
<td>.<i>class</i>.<i>class</i></td>
<td>$(".intro.demo")</td>
<td>所有 class="intro" 且 class="demo" 的元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_first.asp" title="jQuery :first 选择器">:first</a></td>
<td>$("p:first")</td>
<td>第一个 &lt;p&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_last.asp" title="jQuery :last 选择器">:last</a></td>
<td>$("p:last")</td>
<td>最后一个 &lt;p&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_even.asp" title="jQuery :even 选择器">:even</a></td>
<td>$("tr:even")</td>
<td>所有偶数 &lt;tr&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_odd.asp" title="jQuery :odd 选择器">:odd</a></td>
<td>$("tr:odd")</td>
<td>所有奇数 &lt;tr&gt; 元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_eq.asp" title="jQuery :eq() 选择器">:eq(<i>index</i>)</a></td>
<td>$("ul li:eq(3)")</td>
<td>列表中的第四个元素（index 从 0 开始）</td>
</tr>

<tr>
<td><a href="/jquery/selector_gt.asp" title="jQuery :gt 选择器">:gt(<i>no</i>)</a></td>
<td>$("ul li:gt(3)")</td>
<td>列出 index 大于 3 的元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_lt.asp" title="jQuery :lt 选择器">:lt(<i>no</i>)</a></td>
<td>$("ul li:lt(3)")</td>
<td>列出 index 小于 3 的元素</td>
</tr>

<tr>
<td>:not(<i>selector</i>)</td>
<td>$("input:not(:empty)")</td>
<td>所有不为空的 input 元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_header.asp" title="jQuery :header 选择器">:header</a></td>
<td>$(":header")</td>
<td>所有标题元素 &lt;h1&gt; - &lt;h6&gt;</td>
</tr>

<tr>
<td><a href="/jquery/selector_animated.asp" title="jQuery :animated 选择器">:animated</a></td>
<td>&nbsp;</td>
<td>所有动画元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_contains.asp" title="jQuery :contains 选择器">:contains(<i>text</i>)</a></td>
<td>$(":contains('W3School')")</td>
<td>包含指定字符串的所有元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_empty.asp" title="jQuery :empty 选择器">:empty</a></td>
<td>$(":empty")</td>
<td>无子（元素）节点的所有元素</td>
</tr>

<tr>
<td>:hidden</td>
<td>$("p:hidden")</td>
<td>所有隐藏的 &lt;p&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_visible.asp" title="jQuery :visible 选择器">:visible</a></td>
<td>$("table:visible")</td>
<td>所有可见的表格</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td>s1,s2,s3</td>
<td>$("th,td,.intro")</td>
<td>所有带有匹配选择的元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_attribute.asp" title="jQuery [attribute] 选择器">[<i>attribute</i>]</a></td>
<td>$("[href]")</td>
<td>所有带有 href 属性的元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_attribute_equal_value.asp" title="jQuery [attribute=value] 选择器">[<i>attribute</i>=<i>value</i>]</a></td>
<td>$("[href='#']")</td>
<td>所有 href 属性的值等于 "#" 的元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_attribute_notequal_value.asp" title="jQuery [attribute!=value] 选择器">[<i>attribute</i>!=<i>value</i>]</a></td>
<td>$("[href!='#']")</td>
<td>所有 href 属性的值不等于 "#" 的元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_attribute_end_value.asp" title="jQuery [attribute$=value] 选择器">[<i>attribute</i>$=<i>value</i>]</a></td>
<td>$("[href$='.jpg']")</td>
<td>所有 href 属性的值包含以 ".jpg" 结尾的元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_input.asp" title="jQuery :input 选择器">:input</a></td>
<td>$(":input")</td>
<td>所有 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_text.asp" title="jQuery :text 选择器">:text</a></td>
<td>$(":text")</td>
<td>所有 type="text" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_password.asp" title="jQuery :password 选择器">:password</a></td>
<td>$(":password")</td>
<td>所有 type="password" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_radio.asp" title="jQuery :radio 选择器">:radio</a></td>
<td>$(":radio")</td>
<td>所有 type="radio" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_checkbox.asp" title="jQuery :checkbox 选择器">:checkbox</a></td>
<td>$(":checkbox")</td>
<td>所有 type="checkbox" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_submit.asp" title="jQuery :submit 选择器">:submit</a></td>
<td>$(":submit")</td>
<td>所有 type="submit" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_reset.asp" title="jQuery :reset 选择器">:reset</a></td>
<td>$(":reset")</td>
<td>所有 type="reset" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_button.asp" title="jQuery :button 选择器">:button</a></td>
<td>$(":button")</td>
<td>所有 type="button" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_image.asp" title="jQuery :image 选择器">:image</a></td>
<td>$(":image")</td>
<td>所有 type="image" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_file.asp" title="jQuery :file 选择器">:file</a></td>
<td>$(":file")</td>
<td>所有 type="file" 的 &lt;input&gt; 元素</td>
</tr>

<tr>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
<td style="background-color:#fff;">&nbsp;</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_enabled.asp" title="jQuery :enabled 选择器">:enabled</a></td>
<td>$(":enabled")</td>
<td>所有激活的 input 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_disabled.asp" title="jQuery :disabled 选择器">:disabled</a></td>
<td>$(":disabled")</td>
<td>所有禁用的 input 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_selected.asp" title="jQuery :selected 选择器">:selected</a></td>
<td>$(":selected")</td>
<td>所有被选取的 input 元素</td>
</tr>

<tr>
<td><a href="/jquery/selector_input_checked.asp" title="jQuery :checked 选择器">:checked</a></td>
<td>$(":checked")</td>
<td>所有被选中的 input 元素</td>
</tr>
</tbody></table>
</div>

<p><code>filter()</code>可以为元素进一步缩减为指定的选择器元素。</p>
<pre><code class="js">    $(&#39;li&#39;).filter(&#39;:even&#39;).css(&#39;background&#39;,&#39;red&#39;);
    //也可以写成下面的方式。
    $(&#39;li:even&#39;).css(&#39;background&#39;,&#39;red&#39;);

    $(&#39;a&#39;).filter(&#39;.external&#39;)  
    //也可以写成下面的方式。
    $(&#39;a&#39;).filter(function(index) {  
        return $(this).hasClass(&#39;external&#39;);  
    })  
</code></pre>
<ul>
<li>属性选择器<ul>
<li><strong>E[attr]</strong>：只使用属性名，但没有确定任何属性值；</li>
<li><strong>E[attr=”value”]</strong>：指定属性名，并指定了该属性的属性值；</li>
<li><strong>E[attr~=”value”]</strong>：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写；</li>
<li><strong>E[attr^=”value”]</strong>：指定了属性名，并且有属性值，属性值是以value开头的；</li>
<li><strong>E[attr$=”value”]</strong>：指定了属性名，并且有属性值，而且属性值是以value结束的；</li>
<li><strong>E[attr*=”value”]</strong>：指定了属性名，并且有属性值，而且属值中包含了value；</li>
<li><strong>E[attr|=”value”]</strong>：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）; </li>
</ul>
</li>
<li>jQuery设计思想写法</li>
</ul>
<p><strong>方法函数化</strong></p>
<pre><code class="js">window.onload=function(){};//原生写法
$(function(){});//jQuery写法

$();//相当于有一个函数function $(){};

innerHTML = 123;
html(123);
function html(){};

onclick = function(){};
click(function(){});
function click(){};</code></pre>
<ul>
<li>javascript与jQuery不能混用</li>
</ul>
<pre><code class="js">$(function(){

    $(&#39;#div1&#39;).click(function(){

        //alert( $(this).html() );  //jq的写法

        //alert( this.innerHTML );  //js的写法

        alert( $(this).innerHTML );  //错误的
        alert( this.html() );  //错误的 
    });    
});
</code></pre>
<h1 id="2015年12月21日"><a href="#2015年12月21日" class="headerlink" title="2015年12月21日"></a>2015年12月21日</h1><h2 id="jQuery-2"><a href="#jQuery-2" class="headerlink" title="jQuery"></a>jQuery</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code class="js">css(&#39;width&#39;,&#39;200px&#39;)
css(&#39;width&#39;)
//当只有一个参数的时候，是取值；当有两个参数的时候，是赋值。

alert( $(&#39;li&#39;).html() );  
//当一组元素的时候，取值是一组中的第一个

$(&#39;li&#39;).html(&#39;hello&#39;); 
//当一组元素的时候,赋值是一组中的所有元素</code></pre>
<p><strong>$()下常用方法</strong></p>
<ul>
<li><p>filter()与not()</p>
<p><code>filter()</code>是过滤，<code>not()</code>是其反义词。</p>
</li>
</ul>
<pre><code class="js">$(function(){

    //$(&#39;div&#39;).filter(&#39;.box&#39;).css(&#39;background&#39;,&#39;red&#39;);

    $(&#39;div&#39;).not(&#39;.box&#39;).css(&#39;background&#39;,&#39;red&#39;);

});</code></pre>
<ul>
<li><p>has()</p>
<p><code>has()</code>是包含的意思，是操作元素的子节点。保留包含特定后代的元素，去掉那些不含有指定后代的元素。</p>
</li>
</ul>
<pre><code class="js">$(function(){
    //$(&#39;div&#39;).has(&#39;.box&#39;).css(&#39;background&#39;,&#39;red&#39;);
    $(&#39;div&#39;).filter(&#39;.box&#39;).css(&#39;background&#39;,&#39;red&#39;);

});


&lt;div&gt;div1&lt;span class=&quot;box&quot;&gt;span&lt;/span&gt;&lt;/div&gt;//has()使这个div变红。
&lt;div class=&quot;box&quot;&gt;div2&lt;/div&gt;//filter()使这个div变红。</code></pre>
<ul>
<li><p>next()与prev()</p>
<p><code>next()</code>选择下一个兄弟节点，<code>prev()</code>选择上一个兄弟节点。</p>
</li>
<li><p>find()</p>
<p><code>find()</code>这个函数是找出正在处理的元素的后代元素的结合。</p>
</li>
<li><p>eq()</p>
<p><code>eq()</code>找出元素结合中的某个元素。</p>
<pre><code class="js">$(&#39;div&#39;).find(&#39;h2&#39;).eq(1).css(&#39;background&#39;,&#39;red&#39;);</code></pre>
</li>
</ul>
<blockquote>
<p>第二个<code>h2</code>变红。</p>
</blockquote>
<ul>
<li>index()<ul>
<li><code>index()</code>索引就是当前元素在所有兄弟节点中的位置。</li>
</ul>
</li>
</ul>
<pre><code>​```js
    alert( $(&#39;#h&#39;).index() );//并返回相应元素的索引值，从0开始计数。
​```

 - 元素的index，相对于选择器

​```js

    $(&quot;button&quot;).click(function(){
        alert($(&quot;.hot&quot;).index($(&quot;#favorite&quot;)));
        alert($(&quot;.hot&quot;).index($(&quot;#hate&quot;)));
      });

    &lt;li class=&quot;hot&quot;&gt;Tea&lt;/li&gt;
    &lt;li class=&quot;hot&quot; id=&quot;favorite&quot;&gt;Coffee&lt;/li&gt;//1
    &lt;li class=&quot;hot&quot; id=&quot;hate&quot;&gt;Coffee&lt;/li&gt;//2
​```</code></pre><ul>
<li><p>addClass()与removeClass()</p>
<p><code>addCladd()</code>可以为元素添加多个类名，<code>removeClass()</code>可以移除多个类名。</p>
</li>
<li><p>width()、innerWidth()、outerWidth</p>
</li>
</ul>
<pre><code class="js">    alert( $(&#39;div&#39;).width() );  //width
   // $(&#39;div&#39;).width(200);  //width=200

    alert( $(&#39;div&#39;).innerWidth() );  //width + padding

    alert( $(&#39;div&#39;).outerWidth() );  //width + padding + border

    alert( $(&#39;div&#39;).outerWidth(true) );  //width + padding + border + margin</code></pre>
<blockquote>
<p>设置或者获取相关容器的宽度，同理<code>height()</code>、<code>innerHeight()</code>、<code>outerHeight()</code>。</p>
</blockquote>
<ul>
<li><p>insertBefore() insertAfter()  appendTo()  prependTo()</p>
<pre><code class="js">&lt;div class=&quot;d1&quot;&gt;div&lt;/div&gt;
&lt;div class=&quot;d2&quot;&gt;div&lt;/div&gt;
&lt;span class=&quot;s1&quot;&gt;span&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;span&lt;/span&gt;

</code></pre>
</li>
</ul>
<p>   $(‘span’).insertBefore( $(‘div’) );<br>   //把所有span元素重复插到每一个div元素前面。<br>   //结果：<br>  <span class="s1">span</span><br>  <span class="s2">span</span><br>  <span class="s3">span</span><br>  <div class="d1">div</div><br>  <span class="s1">span</span><br>  <span class="s2">span</span><br>  <span class="s3">span</span><br>  <div class="d2">div</div></p>
<p>  //$(‘div’).insertAfter( $(‘span’) );<br>  //把所有div元素重复插到每一个span元素后面。</p>
<p>  //$(‘div’).appendTo( $(‘span’) );<br>  //把所有div元素重复插到每一个span元素里面的最后面去。</p>
<p>  //$(‘div’).prependTo( $(‘span’) );<br>  //把所有span元素重复插到每一个div元素里面的最前面去。    </p>
<pre><code>
- before()  after() append()  prepend()

  与上面一样，不同就是后续的操作不一样，样式操作的都是前面的节点。

  ```js
  $(&#39;span&#39;).insertBefore( $(&#39;div&#39;) ).css(&#39;background&#39;,&#39;red&#39;);
  //span元素插入div元素前面，样式操作的是span元素。

  //$(&#39;div&#39;).before( $(&#39;span&#39;) ).css(&#39;background&#39;,&#39;red&#39;);
  //div元素的前面是span，样式操作的是div元素。

  //$(&#39;div&#39;).append( $(&#39;span&#39;) );
  //每一个div元素的里面的最后都插入所有的span元素。
  //
  //$(&#39;div&#39;).prepend( $(&#39;span&#39;) );
  //每一个div元素里面的前面都插入所有的span元素。</code></pre><ul>
<li><p>remove()</p>
<p><code>remove()</code>是删除节点，<code>$(&#39;div).remove()</code>就是删除div这个节点。</p>
</li>
<li><p>on()</p>
<p><code>on()</code>在选择元素上绑定一个或多个事件的事件处理函数。</p>
<pre><code class="js">$(&#39;div&#39;).on({
    &#39;click&#39; : function(){
        alert(123);
    },
    &#39;mouseover&#39; : function(){
        alert(456);
    }
});</code></pre>
</li>
<li><p>off()</p>
<p><code>off()</code>在选择元素上移除一个或多个事件的事件处理函数。<code>off()</code>方法通常用于移除通过 <code>on()</code>方法添加的事件处理程序。</p>
<pre><code class="js">$(&#39;div&#39;).on(&#39;click mouseover&#39;,function(){
    alert(123);
    $(&#39;div&#39;).off(&#39;mouseover&#39;);
});</code></pre>
</li>
<li><p>scrollTop()</p>
<p><code>scrollTop()</code>获取匹配元素相对滚动条顶部的偏移。</p>
<pre><code class="js">$(document).click(function(){        
    alert( $(window).scrollTop() );  //滚动距离
});
</code></pre>
</li>
</ul>
<h3 id="BOM-window对象"><a href="#BOM-window对象" class="headerlink" title="BOM window对象"></a>BOM window对象</h3><p><strong>Window 对象</strong><br>所有浏览器都支持 window 对象。它表示浏览器窗口。</p>
<p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p>
<p>全局变量是 window 对象的属性。</p>
<p>全局函数是 window 对象的方法。</p>
<p>甚至 HTML DOM 的 document 也是 window 对象的属性之一：</p>
<pre><code>window.document.getElementById(&quot;header&quot;);</code></pre><p>与此相同</p>
<pre><code>document.getElementById(&quot;header&quot;);</code></pre><ul>
<li><p>resize()  scroll()</p>
<p><code>resize()</code>事件是当调整浏览器窗口的大小时，发生 resize 事件。<br><code>scroll()</code>事件是当用户滚动指定的元素时，会发生 scroll 事件。scroll 事件适用于所有可滚动的元素和 window 对象（浏览器窗口）。</p>
</li>
<li><p>ev  pageX  which  </p>
<pre><code class="js">//ev : event对象,相当于&#39;ev||window.event&#39;;

//ev.pageX(相对于文档的鼠标位置,包括滚动条) : clientX(相对于可视区)。
//ev.pageY同理。

//ev.which : 相当于keyCode。
</code></pre>
</li>
<li><p>preventDefault  stopPropagation</p>
<p><code>ev.preventDefault()</code>:阻止默认事件</p>
<p><code>ev.stopPropagation()</code>:阻止冒泡的操作</p>
<p><code>return false</code>:阻止默认事件 + 阻止冒泡的操作</p>
</li>
<li><p>one()</p>
<p><code>one()</code>表示事件只能执行一次。</p>
</li>
</ul>
<h1 id="2015年12月22日"><a href="#2015年12月22日" class="headerlink" title="2015年12月22日"></a>2015年12月22日</h1><h2 id="javascript-3"><a href="#javascript-3" class="headerlink" title="javascript"></a>javascript</h2><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p>offset()  position()</p>
<pre><code class="javascript"> $(&#39;#div2&#39;).offset().left;  //获取到屏幕的左距离

 $(&#39;#div2&#39;).position().left;  //到有定位的父级的left值,把当前元素转化成类似定位的形式</code></pre>
<p><code>offsetLeft()</code>是指元素的<code>margin</code>外边沿相对于已定位的父级元素的<code>padding</code>的内边沿的距离。</p>
<p><code>offsetParent()</code>是offsetParent属性返回一个对象的引用，这个对象是距离调用 offsetParent的元素最近的。</p>
</li>
</ul>
<ol>
<li>如果当前元素的父级元素没有进行CSS定位（position为absolute或relative），offsetParent为body。</li>
<li>如果当前元素的父级元素中有CSS定位（position为absolute或relative），offsetParent取最近的那个父级元素。</li>
</ol>
<ul>
<li><p>offsetParent()</p>
<p><code>offsetParent()</code>: 获取有定位的父级;<br><code>parent()</code> : 获取父级;</p>
</li>
<li><p>val()</p>
<p><code>val()</code>方法返回或设置被选元素的<code>value</code>值。</p>
</li>
<li><p>size()</p>
<p><code>size()</code>方法返回被 jQuery 选择器匹配的元素的数量。</p>
</li>
<li><p>each()</p>
<p><code>each()</code>的一般语法为<code>$(selector).each(function(index,element))</code>,</p>
<p><code>function()</code>:为每个匹配元素规定运行的函数。<br><code>index</code>:选择器的 index 位置<br><code>element</code>: 当前的元素（也可使用 “this” 选择器）</p>
</li>
<li><p>hover()</p>
<p><code>hover(inFunction,outFunction)</code> 方法规定当鼠标指针悬停在被选元素上时要运行的两个函数。</p>
<p><code>inFunction</code>:必需。规定 mouseenter 事件发生时运行的函数。</p>
<p><code>outFunction</code>:可选。规定 mouseleave 事件发生时运行的函数。</p>
<pre><code class="js">$(&quot;td&quot;).hover(
    function () {
    $(this).addClass(&quot;hover&quot;);
    },
function () {
    $(this).removeClass(&quot;hover&quot;);
    }
);</code></pre>
</li>
<li><p>show()  hide()   </p>
<p><code>show([speed,[easing],[fn]])</code>:显示隐藏的匹配元素。</p>
<p><code>hide([speed,[easing],[fn]])</code>:隐藏匹配元素。</p>
<p><strong>speed</strong>:三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)；</p>
<p><strong>easing</strong>:(Optional) 用来指定切换效果，默认是”swing（两边慢，中间快）”，可用参数”linear（匀速）”<br><strong>fn</strong>:在动画完成时执行的函数，每个元素执行一次。</p>
</li>
<li><p>fadeOut()     fadeIn()    fadeTo()</p>
<p><code>fadeOut([speed],[easing],[fn])</code>:通过不透明度的变化来实现所有匹配元素的<strong>淡出</strong>效果，并在动画完成后可选地触发一个回调函数。</p>
<p><code>fadeIn([speed],[easing],[fn])</code>:通过不透明度的变化来实现所有匹配元素的<strong>淡入</strong>效果，并在动画完成后可选地触发一个回调函数。</p>
<p><code>fadeTo([speed],[easing],[fn])</code>:把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数。</p>
</li>
<li><p>slideUp()    slideDown()</p>
<p><code>slideUp([speed,[easing],[fn]])</code>:通过高度变化（向上减小）来动态地<strong>隐藏</strong>所有匹配的元素，在隐藏完成后可选地触发一个回调函数。</p>
<p><code>slideDown([speed],[easing],[fn])</code>:概述通过高度变化（向下增大）来动态地<strong>显示</strong>所有匹配的元素，在显示完成后可选地触发一个回调函数。</p>
</li>
</ul>
<h1 id="2015年12月23日"><a href="#2015年12月23日" class="headerlink" title="2015年12月23日"></a>2015年12月23日</h1><h2 id="jQuery-3"><a href="#jQuery-3" class="headerlink" title="jQuery"></a>jQuery</h2><ul>
<li><p>get()</p>
<p><code>get()</code>方法就是把JQ转成原生JS。</p>
<pre><code class="js">$(&#39;#div1&#39;).get(0).innerHTML
//document.getElementById(&#39;div1&#39;).innerHTML

for(var i=0;i&lt;$(&#39;li&#39;).length;i++){
    $(&#39;li&#39;).get(i).style.background = &#39;red&#39;;
}</code></pre>
<p><code>get([index])</code>取得第 index 个位置上的元素。</p>
<p><code>get()</code>取得所有匹配的 DOM 元素集合。</p>
<p>取得其中一个匹配的元素。num表示取得第几个匹配的元素。从0开始，返回的是DOM对象，类似的有eq(index),不过eq(index)返回的是jQuery对象。</p>
</li>
<li><p>outerWidth()</p>
<pre><code class="js">$(&#39;div&#39;).width() //width

// $(&#39;div&#39;).width(200);  //width=200

$(&#39;div&#39;).innerWidth();  //width + padding

$(&#39;div&#39;).outerWidth();  //width + padding + border

$(&#39;div&#39;).outerWidth(true);  //width + padding + border + margin</code></pre>
</li>
</ul>
<blockquote>
<p><code>offsetWidth()</code>:是获取不到隐藏元素的值。</p>
</blockquote>
<ul>
<li><p>text()</p>
<p><code>text()</code>取得所有匹配元素的内容。结果是由所有匹配元素包含的文本内容组合起来的文本。</p>
</li>
</ul>
<ul>
<li><p>remove()     detach()</p>
<p><code>remove()</code>从DOM中删除所有匹配的元素。<br>这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。但除了这个元素本身得以保留之外，其他的比如绑定的事件，附加的数据等都会被移除。</p>
<p><code>detach()</code>与<code>remove()</code>不同的是，所有绑定的事件、附加的数据等都会保留下来。</p>
<pre><code class="js">$(function(){

    $(&#39;div&#39;).click(function(){
        alert(123);
    });

    var oDiv = $(&#39;div&#39;).remove();

    $(&#39;body&#39;).append( oDiv );

</code></pre>
</li>
</ul>
<p>  });</p>
<pre><code>
- $:$(document).ready(function(){})

  完整版：

  ```js
  $(document).ready(function(){});</code></pre><p>  简略版：</p>
<pre><code class="js">  $(function(){});
  //DOMContentLoaded，DOM加载完就触发的事件。</code></pre>
<blockquote>
<p>等DOM加载完就可以执行了，性能要好。</p>
</blockquote>
<p><code>window.onload=function(){}</code>:整个页面文档加载完才触发。</p>
<ul>
<li>parents()</li>
</ul>
<p><code>parents()</code>方法返回被选元素的<strong>所有</strong>祖先元素,参数就是筛选功能。</p>
<p><code>parent()</code>方法返回被选元素的直接父元素。</p>
<p><code>closest()</code>方法返回被选元素的<strong>第一个</strong>祖先元素(包括当前元素自身),必须要写筛选的参数,只能找到<strong>一个</strong>元素。</p>
<ul>
<li>siblings()</li>
</ul>
<p><code>siblings()</code>:找所有的兄弟节点，参数也是筛选功能。</p>
<p><code>nextAll()</code> :下面所有的兄弟节点，参数也是筛选功能。</p>
<p><code>prevAll()</code> : 上面所有的兄弟节点。</p>
<ul>
<li>parentsUntil()   nextUntil()     prevUntil()</li>
</ul>
<p><code>parentsUntil([expr|element][,filter])</code>查找当前元素的所有的<strong>父辈元素</strong>，直到遇到匹配的那个元素为止。</p>
<p><code>nextUntil([exp|ele][,fil])</code>查找当前元素<strong>之后</strong>所有的同辈元素，直到遇到匹配的那个元素为止。</p>
<p><code>prevUntil([exp|ele][,fil])</code>查找当前元素<strong>之前</strong>所有的同辈元素，直到遇到匹配的那个元素为止。</p>
<pre><code class="js">$(&#39;span&#39;).nextUntil(&#39;h2&#39;).css(&#39;background&#39;,&#39;red&#39;);
//查找当前元素之后所有的同辈元素，直到h2标签为止。
</code></pre>
<table>
<thead>
<tr>
<th>[ expr][,filter]</th>
<th>String,String</th>
</tr>
</thead>
</table>
<p><strong>expr</strong>: 用于筛选祖先元素的表达式<br><strong>filter</strong>: 一个字符串，其中包含一个选择表达式匹配元素。</p>
<table>
<thead>
<tr>
<th>[element][,filter]</th>
<th>DOMElement,String</th>
</tr>
</thead>
</table>
<p><strong>element</strong>:用于筛选祖先元素的DOM元素<br><strong>filter</strong>: 一个字符串，其中包含一个选择表达式匹配元素。</p>
<ul>
<li>clone()</li>
</ul>
<p><code>clone()</code> 克隆匹配的DOM元素并且选中这些克隆的副本,在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。</p>
<blockquote>
<p>可以加一个参数（true 或者 false，默认值是：false），指示事件处理函数是否会被复制。</p>
</blockquote>
<ul>
<li>wrap()</li>
</ul>
<p><code>wrap()</code> : 包装,把所有匹配的元素用其他元素的结构化标记包裹起来。</p>
<p><code>wrapAll()</code>: 整体包装，将所有匹配的元素用单个元素包裹起来</p>
<p><code>wrapInner()</code> : 内部包装,将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来</p>
<p><code>unwrap()</code> : 删除包装 ( 删除父级 : 不包括body ),这个方法将移出元素的父元素</p>
<ul>
<li>add()</li>
</ul>
<p><code>add()</code> 方法把元素添加到已存在的元素组合中。</p>
<pre><code class="js">var elem = $(&#39;div&#39;);

var elem2 = elem.add(&#39;span&#39;);

elem.css(&#39;color&#39;,&#39;red&#39;);

elem2.css(&#39;background&#39;,&#39;yellow&#39;);
//elem2包括div、span元素。</code></pre>
<ul>
<li>slice()</li>
</ul>
<p><code>slice()</code> 选取一个匹配的子集;</p>
<pre><code class="js">$(&#39;li&#39;).slice(1,4).css(&#39;background&#39;,&#39;red&#39;);</code></pre>
<ul>
<li>serialize()  serializeArray()</li>
</ul>
<p><code>serialize()</code>序列化表格内容为字符串。</p>
<p><code>serializeArray()</code>序列化表格元素 (类似 ‘.serialize()’ 方法) 返回 JSON 数据结构数据。</p>
<pre><code class="js">    console.log($(&#39;form&#39;).serialize());  
    //string : a=1&amp;b=2&amp;c=3


    console.log( $(&#39;form&#39;).serializeArray() );

    //[{ name : &#39;a&#39; , value : &#39;1&#39; },{ name : &#39;b&#39; , value : &#39;2&#39; },{ name : &#39;c&#39; , value : &#39;3&#39; ]
</code></pre>
<blockquote>
<p>注意，此方法返回的是JSON对象而非JSON字符串。需要使用插件或者第三方库进行字符串化操作。</p>
</blockquote>
<h1 id="2015年12月24日"><a href="#2015年12月24日" class="headerlink" title="2015年12月24日"></a>2015年12月24日</h1><h2 id="jQuery-4"><a href="#jQuery-4" class="headerlink" title="jQuery"></a>jQuery</h2><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>animate()</li>
</ul>
<p><code>annimateanimate(params,[speed],[easing],[fn])</code>用于创建自定义动画的函数。</p>
<p><strong>params</strong>:一组包含作为动画属性和终值的样式属性和及其值的集合<br><strong>speed</strong>:三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)<br><strong>easing</strong>:要使用的擦除效果的名称(需要插件支持).默认jQuery提供”linear” 和 “swing”.<br><strong>fn</strong>:在动画完成时执行的函数，每个元素执行一次。</p>
<ul>
<li>stop()</li>
</ul>
<p><code>stop([clearQueue],[jumpToEnd])</code> 停止所有在指定元素上正在运行的动画。<br><strong>clearQueue(Boolean)</strong>:如果设置成true，则清空队列，立即结束当前的动画。<br><strong>gotoEnd(Boolean)</strong>:让当前正在执行的动画立即完成，并且重设show和hide的原始样式，调用回调函数等</p>
<ul>
<li>finish()</li>
</ul>
<p><code>finish()</code>停止当前正在运行的动画，删除所有排队的动画，属性值跳转到最终值。</p>
<ul>
<li>delay()</li>
</ul>
<p><code>delay()</code> 延迟一定的毫秒数后运行函数。</p>
<pre><code class="js">$(&#39;#div1&#39;).click(function(){

        /*$(this).animate({width : 300} , 2000 , &#39;linear&#39;,function(){
            $(this).animate({height : 300});
        });*/
        //链式操作。
        $(this).animate({width : 300} , 2000).delay(1000).animate({height : 300} , 2000);
        //延迟1秒后触发。
});


$(&#39;#div2&#39;).click(function(){

        //$(&#39;#div1&#39;).stop();   //默认 : 只会阻止当前运动

        //$(&#39;#div1&#39;).stop(true); //阻止后续的运动

        //$(&#39;#div1&#39;).stop(true,true); //可以立即停止到指定的目标点

        $(&#39;#div1&#39;).finish();  //立即停止到所有指定的目标点

});</code></pre>
<ul>
<li>delegate()</li>
</ul>
<p><code>delegate()</code>方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。</p>
<p><strong>语法</strong></p>
<pre><code>$(selector).delegate(childSelector,event,data,function)</code></pre><table>
<thead>
<tr>
<th align="center">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">childSelector</td>
<td>必需。规定要添加事件处理程序的一个或多个子元素。</td>
</tr>
<tr>
<td align="center">event</td>
<td>必需。规定添加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。</td>
</tr>
<tr>
<td align="center">data</td>
<td>可选。规定传递到函数的额外数据。</td>
</tr>
<tr>
<td align="center">function</td>
<td>必需。规定当事件发生时运行的函数。</td>
</tr>
</tbody></table>
<blockquote>
<p>此方法属于事件委托。</p>
</blockquote>
<ul>
<li>undelegate()</li>
</ul>
<p><code>undelegate([selector,[type],fn])</code>删除由 delegate() 方法添加的一个或多个事件处理程序。</p>
<p><strong>selector</strong>:需要删除事件处理程序的选择器。<br><strong>type</strong>:需要删除处理函数的一个或多个事件类型。 由空格分隔多个事件值。必须是有效的事件。<br><strong>fn</strong>:要删除的具体事件处理函数。</p>
<pre><code class="js">$(&#39;ul&#39;).delegate(&#39;li&#39;,&#39;click&#39;,function(){

        this.style.background = &#39;red&#39;;

        $(&#39;ul&#39;).undelegate();

    });//点击一次后，这方法就会被删除。</code></pre>
<ul>
<li>trigger()</li>
</ul>
<p><code>trigger(type,[data])</code>:在每一个匹配的元素上触发某类事件。</p>
<p><strong>type</strong>:一个事件对象或者要触发的事件类型。<br><strong>data</strong>:传递给事件处理函数的附加参数。</p>
<pre><code class="js">$(&#39;#div1&#39;).on(&#39;show&#39;,function(){
        alert(123);
    });

$(&#39;#div1&#39;).on(&#39;show&#39;,function(){
        alert(456);
    });

$(&#39;#div1&#39;).trigger(&#39;show&#39;);//会弹出两次</code></pre>
<ul>
<li>ev.data 、 ev.target、    ev.type</li>
</ul>
<pre><code class="js">$(function(){

    $(&#39;#div1&#39;).on(&#39;click&#39;,{name:&#39;hello&#39;},function(ev){
        alert(ev.data.name);//hello

        alert( ev.target );//[object HTMLDivElement]
        //ev.target.nodeName;//DIV

        alert( ev.type );//click

    }); 
});
</code></pre>
<p>以下属于事件对象：</p>
<p><code>ev.data</code>: 属性包含当前执行的处理程序被绑定时传递到事件方法的可选数据。</p>
<p><code>ev.target</code>:最初触发事件的DOM元素。</p>
<p><code>ev.type</code>:返回哪种事件类型被触发：</p>
<hr>
<h3 id="下的常用方法"><a href="#下的常用方法" class="headerlink" title="$下的常用方法"></a>$下的常用方法</h3><p>$().css()  $().html()  $().val()  : 只能给JQ对象用</p>
<p>$.xxx()  $.yyy()  $.zzz()  : 不仅可以给JQ用，也可以给原生JS用 : 叫做工具方法</p>
<ul>
<li>type() 、trim()</li>
</ul>
<p><code>type()</code>:检测obj的数据类型。<br><code>trim()</code>:去除空格。</p>
<pre><code class="js">$(function(){

    var a = 4234;

    //$.type() : 也是判断类型,比原生的javascript更强大。

    //alert( typeof a );//number

    alert( $.type(a) );//number

    // var str = &#39;   hello  &#39;;

    // alert(&#39;(&#39;+$.trim(str)+&#39;)&#39;);//(hello)

});</code></pre>
<ul>
<li>inArray()</li>
</ul>
<p><code>jQuery.inArray(value,array,[fromIndex])</code> :确定第一个参数在数组中的位置，从0开始计数(如果没有找到则返回 -1 )。</p>
<p><strong>value</strong>:用于在数组中查找是否存在<br><strong>array</strong>:待处理数组。<br><strong>fromIndex</strong>:用来搜索数组队列的开始位置，默认值为0</p>
<pre><code class="js">var arr = [2,&#39;sdf&#39;, &quot;Pete&quot;, 4, 8, &quot;John&quot; ];

alert($.inArray(&quot;John&quot;, arr)) //5

alert($.inArray(4, arr))//3

alert($.inArray(&quot;David&quot;, arr))//-1

alert($.inArray(&quot;Pete&quot;, arr,3)) //-1</code></pre>
<ul>
<li>proxy()</li>
</ul>
<p><code>proxy(function,context)</code>当有事件处理函数要附加到元素上，但他们的作用域实际是指向另一个对象时，此方法可以改变 <em>this</em> 的指向。</p>
<pre><code class="js">//proxy()  : 改变this指向的

function show(n1,n2){
        alert(n1);
        alert(n2);
        alert(this);
}

show(12,45);//12,45,window

//$.proxy(show , document,3)(4);//12,45,document
//改变函数show()的this的指向，有window变成document。
//$.proxy(show , document)(3,4);//12,45,document
//$.proxy(show , document,3,4)();//12,45,document


// $(document).click( $.proxy(show,window,3,4));//12,45,document</code></pre>
<ul>
<li>noConflict()</li>
</ul>
<p><code>noConflict()</code>:防止冲突。</p>
<pre><code class="js">//$ 等价于 jQuery

var miaov = $.noConflict();

var $ = 10;

miaov(function(){

    miaov(&#39;body&#39;).css(&#39;background&#39;,&#39;red&#39;);

});</code></pre>
<ul>
<li>parseJson()</li>
</ul>
<pre><code class="js">var str = &#39;{&quot;name&quot;:&quot;hello&quot;}&#39;;

$.parseJSON( str )//解释成Json对象。

alert($.parseJSON( str ).name);//hello</code></pre>
<ul>
<li>makeArray()</li>
</ul>
<p><code>makeArray()</code>:将类数组对象转换为数组对象。</p>
<pre><code class="js">window.onload = function(){

var aDiv = document.getElementsByTagName(&#39;div&#39;);  //类数组

$.makeArray(aDiv).push();

};</code></pre>
<ul>
<li>ajax()</li>
</ul>
<pre><code class="js">$.ajax({
    url : &#39;xxx.php&#39;,
    data : &#39;name=hello&amp;age=20&#39;,
    type : &#39;POST&#39;,
    success : function(data){
        alert(1);
    },
    error : function(){
        alert(2);
    }
});

$.get(&#39;xxx.php&#39;,{},function(){

});

$.post(&#39;xxx.php&#39;,function(){

});

$.getJSON(&#39;xxx.php?callback=?&#39;,function(data){
    data
});</code></pre>
<ul>
<li>$.extend、$.fn.extend、</li>
</ul>
<p><strong>$.extend</strong> : 扩展工具方法下的插件形式  $.xxx() $.yyy()</p>
<p><strong>$.fn.extend</strong>  :  扩展到JQ对象下的插件形式  $().xxx()  $().yyy()</p>
<pre><code class="js">var str=&#39;        hello            &#39;;
$.extend({
    leftTrim : function(str){
        return str.replace(/^\s+/,&#39;&#39;);
    },
});
alert(&#39;(&#39;+$.ldftTrim(str)+&#39;)&#39;);//(hello            )
aaa : function(){
        alert(1);
    }
//-----------------------------------------------------------
//包装一个拖拽的方法。
$.fn.extend({

    drag : function(){

        //this : $(&#39;#div1&#39;)

        var disX = 0;
        var disY = 0;

        var This = this;

        this.mousedown(function(ev){

            disX = ev.pageX - $(this).offset().left;
            disY = ev.pageY - $(this).offset().top;

            $(document).mousemove(function(ev){

                This.css(&#39;left&#39; , ev.pageX - disX);
                This.css(&#39;top&#39; , ev.pageY - disY);

            });

            $(document).mouseup(function(){
                $(this).off();
            });

            return false;

        });

    },
    aaa : function(){
        alert(2);
    }

});

//----------------------------------------------------

$.aaa();  // 1
$().aaa();  //2</code></pre>
<!-- Test -->

<h1 id="2015年12月26日"><a href="#2015年12月26日" class="headerlink" title="2015年12月26日"></a>2015年12月26日</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li>base</li>
</ul>
<p><code>&lt;base&gt;</code>标签为页面上的所有链接规定默认地址或默认目标。<br>使浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。</p>
<pre><code class="html5">&lt;html&gt;
&lt;head&gt;
&lt;base href=&quot;http://www.w3school.com.cn/i/&quot; /&gt;
&lt;base target=&quot;_blank&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;eg_smile.gif&quot; /&gt;&lt;br /&gt;
&lt;p&gt;请注意，我们已经为图像规定了一个相对地址。由于我们已经在 head 部分规定了一个基准 URL，浏览器将在如下地址寻找图片：&lt;/p&gt;
&lt;p&gt;&quot;http://www.w3school.com.cn/i/eg_smile.gif&quot;&lt;/p&gt;

&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;W3School&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请注意，链接会在新窗口中打开，即使链接中没有 target=&quot;_blank&quot; 属性。这是因为 base 元素的 target 属性已经被设置为 &quot;_blank&quot; 了。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>文本格式化标签</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th>描述</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt; b&gt;</td>
<td>定义粗体文本。</td>
<td><b>This text is bold</b></td>
</tr>
<tr>
<td align="center">&lt; big&gt;</td>
<td>定义大号字。</td>
<td><big>This text is big</big></td>
</tr>
<tr>
<td align="center">&lt; em&gt;</td>
<td>定义着重文字。</td>
<td><em>This text is emphasized</em></td>
</tr>
<tr>
<td align="center">&lt; i&gt;</td>
<td>定义斜体字。</td>
<td><i>This text is italic</i></td>
</tr>
<tr>
<td align="center">&lt; small&gt;</td>
<td>定义小号字。</td>
<td><small>This text is small</small></td>
</tr>
<tr>
<td align="center">&lt; strong&gt;</td>
<td>定义加重语气。</td>
<td><strong>This text is strong</strong></td>
</tr>
<tr>
<td align="center">&lt; sub&gt;</td>
<td>定义下标字。</td>
<td><sub>subscript</sub>This text contains</td>
</tr>
<tr>
<td align="center">&lt; sup&gt;</td>
<td>定义上标字。</td>
<td>This text contains<sup>superscript</sup></td>
</tr>
<tr>
<td align="center">&lt; ins&gt;</td>
<td>定义插入字。</td>
<td><ins>ins</ins></td>
</tr>
<tr>
<td align="center">&lt; del&gt;</td>
<td>定义删除字。</td>
<td><del>del</del></td>
</tr>
</tbody></table>
<ul>
<li>计算机输出标签</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; code&gt;</td>
<td>定义计算机代码。</td>
<td><code>Computer code</code></td>
</tr>
<tr>
<td>&lt; kbd&gt;</td>
<td>定义键盘码。</td>
<td><kbd>Keyboard input</kbd></td>
</tr>
<tr>
<td>&lt; samp&gt;</td>
<td>定义计算机代码样本。</td>
<td><samp>Sample text</samp></td>
</tr>
<tr>
<td>&lt; tt&gt;</td>
<td>定义打字机代码。</td>
<td><tt>Teletype text</tt></td>
</tr>
<tr>
<td>&lt; var&gt;</td>
<td>定义变量。</td>
<td><var>Computer variable</var></td>
</tr>
<tr>
<td>&lt; pre&gt;</td>
<td>定义预格式文本。</td>
<td></td>
</tr>
</tbody></table>
<p>** &lt; pre&gt;**</p>
<pre><code class="html5"> &lt;pre&gt;
Text in a pre element
is displayed in a fixed-width
font, and it preserves
both      spaces and
line breaks
&lt;/pre&gt;</code></pre>
<p><strong>效果</strong></p>
<pre>
Text in a pre element
is displayed in a fixed-width
font, and it preserves
both      spaces and
line breaks
</pre>

<blockquote>
<p>pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。<br>可以导致段落断开的标签（例如标题、&lt; p&gt; 和 &lt; address&gt; 标签）<strong>绝不能</strong>包含在 &lt; pre&gt; 所定义的块里。尽管有些浏览器会把段落结束标签解释为简单地换行，但是这种行为在所有浏览器上并不都是一样的。</p>
</blockquote>
<ul>
<li>面向对象的编程:关于对象的 属性、方法和事件 的理解</li>
</ul>
<p>把 <strong>属性</strong> 看作是对象的 性质 。<br>把 <strong>方法</strong> 看作是对象的 动作 。<br>把 <strong>事件</strong> 看作是对象的 响应 。</p>
<h1 id="2015年12月27日"><a href="#2015年12月27日" class="headerlink" title="2015年12月27日"></a>2015年12月27日</h1><h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><pre><code class="html5">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;!-- 在IE运行最新的渲染模式   --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;!-- 初始化移动浏览显示。
    &#39;width=device-widt&#39;表示宽度等于设备的宽度，&#39;initial-scale=1&#39;表示初始的缩放比例为1，就是不缩放。 --&gt;

    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;
    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;

    &lt;!-- Bootstrap --&gt;
    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;

    &lt;!-- 以下两个插件用于在IE8以及以下版本浏览器支持HTML5元素和媒体查询，如果不需要用可以移除 --&gt;
    &lt;!-- WARNING: Respond.js doesn&#39;t work if you view the page via file:// --&gt;
    &lt;!--[if lt IE 9]&gt;
      &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;
      &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
    &lt;!-- 很多 CSS3 属性和 HTML5 元素 - - 例如，圆角矩形和投影  - - 是肯定不被支持的，所以要引入js文件解决。 Internet Explorer 8 需要 Respond.js 配合才能实现对媒体查询（media query）的支持。 --&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;你好，世界！&lt;/h1&gt;

    &lt;!-- 如果要使用Bootstrap的js插件，必须先调入jQuery --&gt;
    &lt;script src=&quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 包括所有bootstrap的js插件或者可以根据需要使用的js插件调用　--&gt;
    &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h1 id="2015年12月28日"><a href="#2015年12月28日" class="headerlink" title="2015年12月28日"></a>2015年12月28日</h1><h2 id="bootstrap-1"><a href="#bootstrap-1" class="headerlink" title="bootstrap"></a>bootstrap</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code class="html">&lt;!--Bootstrap中的标题--&gt;
&lt;h1&gt;Bootstrap标题一&lt;/h1&gt;
&lt;!-- 也可以写成下面的效果  --&gt;
&lt;!--Bootstrap中让非标题元素和标题使用相同的样式--&gt;
&lt;div class=&quot;h1&quot;&gt;Bootstrap标题一&lt;/div&gt;</code></pre>
<pre><code class="html">&lt;h1&gt;Bootstrap标题一&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h1&gt;</code></pre>
<p><em>效果如下</em></p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-title.jpg" alt></p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul>
<li>强调内容</li>
</ul>
<p><code>b</code>和<code>&lt;strong&gt;</code>标签加粗;<br><code>&lt;em&gt;</code>和<code>&lt;i&gt;</code>斜体显示;</p>
<blockquote>
<p><code>&lt;b&gt;</code>和<code>&lt;i</code>&gt; 仅用来使文本呈现粗体和斜体，区别其它文本，不会产生任何语义的变化。<br><code>&lt;em&gt;</code>是句意强调，加与不加会引起语义变化。<code>&lt;strong&gt;</code>是重要性强调，和局部还是全局无关，局部强调用<code>&lt;strong&gt;</code>也可以，<code>&lt;strong&gt;</code>强调的是重要性，不会改变句意。</p>
</blockquote>
<ul>
<li>强调内容的类</li>
</ul>
<p>Bootstrap还定义了一套类名，这里称其为强调类名（类似前面说的“.lead”）,这些强调类都是通过颜色来表示强调，具本说明如下：</p>
<ul>
<li>.text-muted：提示，使用浅灰色（#999）</li>
<li>.text-primary：主要，使用蓝色（#428bca）</li>
<li>.text-success：成功，使用浅绿色(#3c763d)</li>
<li>.text-info：通知信息，使用浅蓝色（#31708f）</li>
<li>.text-warning：警告，使用黄色（#8a6d3b）</li>
<li>.text-danger：危险，使用褐色（#a94442）</li>
</ul>
<p><em>效果如下</em></p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-text.jpg" alt></p>
<ul>
<li>文本对齐风格<ul>
<li>.text-left：左对齐</li>
<li>.text-center：居中对齐</li>
<li>.text-right：右对齐</li>
<li>.text-justify：两端对齐</li>
</ul>
</li>
<li>列表</li>
</ul>
<p>通过给无序列表添加一个类名<code>.list-unstyled</code>,这样就可以去除默认的列表样式的风格。</p>
<pre><code class="html"> /*源码请查看bootstrap.css文件*/
.list-unstyled {
padding-left: 0;
list-style: none;
}</code></pre>
<p>通过添加类名<code>.list-inline</code>来实现内联列表，简单点说就是把垂直列表换成水平列表，而且去掉项目符号（编号），保持水平显示。</p>
<pre><code class="html">/*源码查看bootstrap.css*/
.list-inline {
padding-left: 0;
margin-left: -5px;
list-style: none;
}
.list-inline &gt; li {
display: inline-block;
padding-right: 5px;
padding-left: 5px;
}</code></pre>
<p>水平定义列表就像内联列表一样，Bootstrap可以给<code>&lt;dl&gt;</code>添加类名<code>.dl-horizontal</code>给定义列表实现水平显示效果。</p>
<pre><code class="html">/*源码请查看bootstrap.css*/

@media (min-width: 768px) {
.dl-horizontal dt {
float: left;
width: 160px;
overflow: hidden;
clear: left;
text-align: right;
text-overflow: ellipsis;
white-space: nowrap;
  }
.dl-horizontal dd {
margin-left: 180px;
  }
}</code></pre>
<p>宽屏下的效果（屏幕大于768px）：</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-hor.jpg" alt></p>
<br>
当你缩小你的浏览器屏幕时，水平定义列表将回复到原始的状态:
![](C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-hor-2.jpg)

<ul>
<li>代码风格</li>
</ul>
<pre><code> + `&lt;code&gt;`：一般是针对于单个单词或单个句子的代码

 + `&lt;pre&gt;`：一般是针对于多行代码（也就是成块的代码）

 + `&lt;kbd&gt;`:一般是表示用户要通过键盘输入的内容 </code></pre><p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-code.jpg" alt></p>
<p>类名<code>.pre-scrollable</code>，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在<strong>Y</strong>轴出现滚动条。</p>
<pre><code class="html">/*源码请查看bootstrap.css*/

.pre-scrollable {
max-height: 340px;
overflow-y: scroll;
}</code></pre>
<ul>
<li>表格<br>Bootstrap为表格不同的样式风格提供了不同的类名，主要包括：<ul>
<li><code>.table</code>：基础表格 </li>
<li><code>.table-striped</code>：斑马线表格</li>
<li><code>.table-bordered</code>：带边框的表格</li>
<li><code>.table-hover</code>：鼠标悬停高亮的表格</li>
<li><code>.table-condensed</code>：紧凑型表格</li>
<li><code>.table-responsive</code>：响应式表格,当你的浏览器可视区域小于768px时，表格底部会出现水平滚动条。</li>
</ul>
</li>
</ul>
<p>Bootstrap还为表格的行元素<code>&lt;tr&gt;</code>提供了五种不同的类名，每种类名控制了行的不同背景颜色，具体说明如下表所示：</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-tr.jpg" alt></p>
<ul>
<li>表单</li>
</ul>
<p>在<code>&lt;form&gt;</code>元素是使用类名“form-horizontal”。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-form.jpg" alt></p>
<p>在Bootstrap框架中实现这样的表单效果是轻而易举的，你只需要在<code>&lt;form&gt;</code>元素中添加类名<code>form-inline</code>。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-form-1.jpg" alt></p>
<p>为了让控件在各种表单风格中样式不出错，需要添加类名<code>form-control</code>。</p>
<pre><code class="html">&lt;form role=&quot;form&quot;&gt;
&lt;div class=&quot;form-group&quot;&gt;
&lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;Enter email&quot;&gt;
&lt;/div&gt;
&lt;/form&gt;</code></pre>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-form-2.jpg" alt></p>
<p>多行选择设置<code>multiple</code>属性的值为<code>multiple</code>。</p>
<pre><code class="html5">&lt;select multiple class=&quot;form-control&quot;&gt;
    &lt;option&gt;1&lt;/option&gt;
    &lt;option&gt;2&lt;/option&gt;
    &lt;option&gt;3&lt;/option&gt;
    &lt;option&gt;4&lt;/option&gt;
    &lt;option&gt;5&lt;/option&gt;
&lt;/select&gt;</code></pre>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-form-3.jpg" alt></p>
<p>文本域和原始使用方法一样，设置<code>rows</code>可定义其高度，设置<code>cols</code>可以设置其宽度。但如果<code>textarea</code>元素中添加了类名<code>form-control</code>类名，则无需设置<code>cols</code>属性。</p>
<pre><code class="html">&lt;form role=&quot;form&quot;&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;
  &lt;/div&gt;
&lt;/form&gt;</code></pre>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/bs-form-4.jpg" alt></p>
<p><strong>复选框与单选框</strong></p>
<p>1、不管是<code>checkbox</code>还是<code>radio</code>都使用<code>label</code>包起来了<br>2、<code>checkbox</code>连同<code>label</code>标签放置在一个名为<code>.checkbox</code>的容器内<br>3、<code>radio</code>连同<code>label</code>标签放置在一个名为<code>.radio</code>的容器内</p>
<pre><code class="html">&lt;div class=&quot;checkbox&quot;&gt;
    &lt;label&gt;
      &lt;input type=&quot;checkbox&quot; value=&quot;&quot;&gt;
      记住密码
    &lt;/label&gt;
&lt;/div&gt;</code></pre>
<p>1、如果checkbox需要水平排列，只需要在<code>labe</code>l标签上添加类名<code>checkbox-inline</code></p>
<p>2、如果radio需要水平排列，只需要在<code>label</code>标签上添加类名<code>radio-inline</code></p>
<ul>
<li>按钮</li>
</ul>
<p>按钮也是表单重要控件之一,制作按钮通常使用下面代码来实现：</p>
<pre><code> + input[type=“submit”]

 + input[type=“button”]

 + input[type=“reset”]

 + &lt; button&gt;</code></pre><p><img src alt></p>
<p><img src="C:%5CUsers%5CADMINI~1%5CAppData%5CLocal%5CTemp%5C1571647954241.png" alt="1571647954241"></p>
<h1 id="2015年12月29日"><a href="#2015年12月29日" class="headerlink" title="2015年12月29日"></a>2015年12月29日</h1><h2 id="bootstrap-2"><a href="#bootstrap-2" class="headerlink" title="bootstrap"></a>bootstrap</h2><h3 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h3><p>这两个类名是：</p>
<p><code>input-sm</code>:让控件比正常大小更小</p>
<p><code>input-lg</code>:让控件比正常大小更大</p>
<p>在Bootstrap框架中同样提供这几种效果。</p>
<ul>
<li><p><code>.has-warning</code>:警告状态（黄色）</p>
</li>
<li><p><code>.has-error</code>：错误状态（红色）</p>
</li>
<li><p><code>.has-success</code>：成功状态（绿色）</p>
</li>
<li><p><code>.has-feedback</code>：添加状态符号的类名，对应不同的状态会自动出现不同的符号。</p>
</li>
<li><p><code>.help-block</code>:提示信息以块状显示，并且显示在控件底部。</p>
</li>
</ul>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><pre><code class="html5">&lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot;&gt;button标签按钮&lt;/button&gt; 
&lt;input type=&quot;submit&quot; class=&quot;btn btn-default&quot; value=&quot;input标签按钮&quot;/&gt;

&lt;span class=&quot;btn btn-default&quot;&gt;span标签按钮&lt;/span&gt;  
&lt;div class=&quot;btn btn-default&quot;&gt;div标签按钮&lt;/div&gt;  </code></pre>
<p>效果如下：<br><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/btn.jpg" alt></p>
<blockquote>
<p>建议使用button或a标签来制作按钮。</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/btn-2.jpg" alt></p>
<ul>
<li><code>btn-block</code>:这个类名可以让按钮充满整个容器。</li>
</ul>
<p><strong>在Bootstrap框架中，要禁用按钮有两种实现方式：</strong></p>
<p>方法1：在标签中添加disabled属性</p>
<p>方法2：在元素标签中添加类名“disabled”</p>
<p><strong>区别：</strong></p>
<p><code>.disabled</code>样式不会禁止按钮的默认行为,而在元素标签中添加<code>disabled</code>属性的方法是可以禁止元素的默认行为的。</p>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul>
<li><strong>img-responsive</strong>：响应式图片，主要针对于响应式设计</li>
<li><strong>img-rounded</strong>：圆角图片</li>
<li><strong>img-circle</strong>：圆形图片</li>
<li><strong>img-thumbnail</strong>：缩略图片</li>
</ul>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>图标都是使用CSS3的<code>@font-face</code>属性配合字体来实现的icon效果。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2015/12/img/icon.jpg" alt></p>
<p>需要对icon设置一个默认样式，在Bootstrap框架中是通过给元素添加<code>glyphicon</code>类名来实现，然后通过伪元素<code>:before</code>的<code>content</code>属性调取对应的icon编码：</p>
<pre><code class="html">.glyphicon {
position: relative;
top: 1px;
display: inline-block;
font-family: &#39;Glyphicons Halflings&#39;;
font-style: normal;
font-weight: normal;
line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

//伪类
.glyphicon-asterisk:before {
content: &quot;\2a&quot;;
}


//代码写法
&lt;span class=&quot;glyphicon glyphicon-asterisk&quot;&gt;&lt;/span&gt;</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/04/2019-10-04-JS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/2019-10-04-JS/" itemprop="url">JS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T10:00:00+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2016年3月2日"><a href="#2016年3月2日" class="headerlink" title="2016年3月2日"></a>2016年3月2日</h1><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>数据：是指所有能输入计算机并能被计算机系统和程序识别、存储、加工和处理的符号的总称。</li>
<li>数据元素：数据的基本单位，在计算机程序中通常把数据元素作为一个整体来存储和处理。有时一个数据元素可由若干个数据项组成。</li>
<li>数据项：是数据不可分割的，具有独立含义的最小数据单位。</li>
</ul>
<p><strong>算法</strong>：</p>
<p>即对数据施加的操作。数据的运算定义在数据的逻辑结构上，每种逻辑结构都有一个运算的集合。最常用的检索、插入、删除、更新、排序等运算实际上只是在抽象的数据上所施加的一系列抽象的操作。</p>
<h1 id="2016年3月3日"><a href="#2016年3月3日" class="headerlink" title="2016年3月3日"></a>2016年3月3日</h1><h2 id="javascript-1"><a href="#javascript-1" class="headerlink" title="javascript"></a>javascript</h2><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p><strong>JavaScript Array 对象</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或更多的数组，并返回结果。</td>
</tr>
<tr>
<td>join()</td>
<td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除并返回数组的最后一个元素</td>
</tr>
<tr>
<td>push()</td>
<td>向数组的末尾添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td>reverse()</td>
<td>颠倒数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除并返回数组的第一个元素</td>
</tr>
<tr>
<td>slice()</td>
<td>从某个已有的数组返回选定的元素</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序</td>
</tr>
<tr>
<td>splice()</td>
<td>删除元素，并向数组添加新元素。</td>
</tr>
<tr>
<td>toSource()</td>
<td>返回该对象的源代码。</td>
</tr>
<tr>
<td>toString()</td>
<td>把数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>把数组转换为本地数组，并返回结果。</td>
</tr>
<tr>
<td>unshift()</td>
<td>向数组的开头添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组对象的原始值</td>
</tr>
</tbody></table>
<p><strong>push()</strong> 遇到数组参数时，把整个数组参数作为一个元素；而 <strong>concat()</strong> 则是拆开数组参数，一个元素一个元素地加进去。 <strong>push()</strong> 直接改变当前数组；<strong>concat()</strong> 不改变当前数组。</p>
<pre><code class="js">var arr = new Array(3)
arr[0] = &quot;George&quot;
arr[1] = &quot;John&quot;
arr[2] = &quot;Thomas&quot;


//push()
document.write(arr + &quot;&lt;br /&gt;&quot;)
document.write(arr.push([12,324,345]) + &quot;&lt;br /&gt;&quot;)
document.write(arr[3])
//George,John,Thomas
//4
//1,2,3,4

//concat()

brr=arr.concat([1,2,3]);
document.write(brr[3])
//1</code></pre>
<pre><code class="js">var d; // 声明变量。 
d = new Date(); // 创建 Date 对象。 
document.write(d.toLocaleString()+&quot;&lt;br/&gt;&quot;); // 转换为当前区域,返回转换的日期。

document.write(d.toString()); // 返回转换的日期。

结果：
2016/3/4 上午10:28:51

Fri Mar 04 2016 10:28:51 GMT+0800 (中国标准时间)</code></pre>
<p><strong>toLocaleString()</strong>方法返回一个 String 对象 ,这个对象中包含了用当前区域设置的默认格式表示的日期。 </p>
<p><strong>toString()</strong>返回值与没有参数的 join() 方法返回的字符串相同。</p>
<h1 id="2016年3月5日"><a href="#2016年3月5日" class="headerlink" title="2016年3月5日"></a>2016年3月5日</h1><h2 id="javascript-2"><a href="#javascript-2" class="headerlink" title="javascript"></a>javascript</h2><ul>
<li>parseInt(string, radix) 函数</li>
</ul>
<p><strong>radix</strong>： 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</p>
<p>函数可解析一个字符串，并返回一个十进制整数。</p>
<ul>
<li>进制转换</li>
</ul>
<pre><code class="javascript">//十进制转其他  
var x=110;  
alert(x);  
alert(x.toString(8));  
alert(x.toString(32));  
alert(x.toString(16));  
//其他转十进制  
var x=&#39;110&#39;;  
alert(parseInt(x,2));  
alert(parseInt(x,8));  
alert(parseInt(x,16));  
//其他转其他  
//先用parseInt转成十进制再用toString转到目标进制  
alert(String.fromCharCode(parseInt(141,8)))//&quot;a&quot;
alert(parseInt(&#39;ff&#39;,16).toString(2));//&quot;11111111&quot;</code></pre>
<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><p>在ecmascript部分node和js其实是一样的，比如数据类型的定义，语法结构，内置对象</p>
<p>在js中的顶层对象:  window</p>
<p>在node中的顶层对象:  global</p>
<blockquote>
<p>注意：在node中也没有什么window</p>
</blockquote>
<p>一个文件就是一个模块</p>
<p>每个模块都有自己的作用域</p>
<p>我们使用var来申明的一个变量，他并不是全局的，而是属于当前模块下</p>
<p><strong>__filename</strong>:当前文件被解析过后的绝对路径;</p>
<p><strong>require(‘模块’)</strong>:模块加载;</p>
<p>模块加载机制：</p>
<ul>
<li>路径<ul>
<li>绝对路径</li>
<li>相对路径</li>
</ul>
</li>
<li>查找方式<ol>
<li>首先按照加载的模块的文件名称进行查找</li>
<li>如果没有找到，则会在模块文件名称后加上.js的后缀，进行查找</li>
<li>如果还没有找到，则会在文件名称后加上.json的后缀，进行查找</li>
<li>如果还没有，则会在文件名称后加上.node的后缀，进行查找</li>
</ol>
</li>
</ul>
<blockquote>
<p>文件名称 -&gt; .js -&gt; .json -&gt; .node</p>
</blockquote>
<h1 id="2016年3月6日"><a href="#2016年3月6日" class="headerlink" title="2016年3月6日"></a>2016年3月6日</h1><h2 id="nodejs-1"><a href="#nodejs-1" class="headerlink" title="nodejs"></a>nodejs</h2><p>在一个模块中通过var定义的变量，其作用域范围是当前模块，外部不能够直接的访问<br>如果我们想一个模块能够访问另外一个模块中定义的变量，可以：</p>
<ol>
<li>把变量作为global对象的一个属性，但是这样的做法是推荐</li>
<li>使用模块对象 module</li>
</ol>
<p><strong>module</strong> : 保存提供和当前模块有关的一些信息;<br>在这个<strong>module</strong>对象，有一个子对象：<strong>exports</strong> 对象<br>我们可以通过这个对象把一个模块中的局部变量对象进行提供访问</p>
<pre><code class="js">&lt;!-- 1.js --&gt;
module.exports.a = a;


&lt;!-- 2.js --&gt;
var m5 = require(&#39;./5&#39;); //这个方法的返回值，其实就被加载模块中的module.exports

console.log(module);

//{ a: 100 }
//
//module.exports = [1,2,3];   //exports 和 module.exports 的指向关系已经断开了,module.exports 给改写了，不是在这个对象上添加属性那样了
//。</code></pre>
<p><strong><strong>filename *<em>: 返回当前模块文件解析后的绝对路径，该属性其实并非全局的，而是模块作用域下的<br>*</em></strong>dirname</strong> : 返回当前模块文件所在目录解析后的绝对路径，该属性也不是全局的，而是模块作用域下的。</p>
<h1 id="2016年3月7日"><a href="#2016年3月7日" class="headerlink" title="2016年3月7日"></a>2016年3月7日</h1><h2 id="nodejs-2"><a href="#nodejs-2" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="process对象"><a href="#process对象" class="headerlink" title="process对象"></a>process对象</h3><ul>
<li>global<ul>
<li>process对象<ul>
<li>process对象是一个全局对象，可以在任何地方都能访问到他，通过这个对象提供的属性和方法，使我们可以对当前运行的程序的进程进行访问与控制。</li>
<li>argv<ul>
<li>Array，一组包含命令行参数的数组</li>
</ul>
</li>
<li>execPath<ul>
<li>开启当前进程的绝对路径</li>
</ul>
</li>
<li>env<ul>
<li>返回用户环境信息。</li>
</ul>
</li>
<li>version<ul>
<li>返回node版本信息</li>
</ul>
</li>
<li>versions<ul>
<li>返回node以及node依赖包版本信息</li>
</ul>
</li>
<li>pid<ul>
<li>当前进程的pid</li>
</ul>
</li>
<li>title<ul>
<li>当前进程的显示名称（Getter、Setter）</li>
</ul>
</li>
<li>arch<ul>
<li>返回当前CPU处理器架构 arm、ia32、x64</li>
</ul>
</li>
<li>platform<ul>
<li>返回当前操作系统平台</li>
</ul>
</li>
<li>cwd()<ul>
<li>返回当前进程的工作目录</li>
</ul>
</li>
<li>chdir(directory)<ul>
<li>改变当前进程的工作目录</li>
</ul>
</li>
<li>memoryUsage()<ul>
<li>返回node进程的内存使用情况，单位是byte</li>
</ul>
</li>
<li>exit(code)<ul>
<li>退出</li>
</ul>
</li>
<li>kill(pid)<ul>
<li>想进程发送信息</li>
</ul>
</li>
<li>stdin<ul>
<li>标准输入流</li>
</ul>
</li>
<li>stdout<ul>
<li>标准输出流</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">//默认情况下，输入流是关闭的，要监听处理输入流数据，首先要开启输入流
process.stdin.resume();

//用于监听用户的输入数据

process.stdin.on(&#39;data&#39;, function(chunk) {
    console.log(&#39;用户输入了：&#39; + chunk);
});</code></pre>
<h3 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h3><p><strong>new Buffer(size); size [Number]</strong> 创建一个Buffer对象，并为这个对象分配一个大小<br>当我们为一个Buffer对象分配空间大小以后，其长度是固定，不能更改。</p>
<blockquote>
<p>内容会随机填充。</p>
</blockquote>
<p><strong>new Buffer(str, [encoding])</strong>:将字符串转化成指定二进制数字。</p>
<ul>
<li>str String类型 - 需要存入buffer的string字符串.</li>
<li>encoding String类型 - 使用什么编码方式，参数可选.</li>
</ul>
<p><strong>buf.length</strong></p>
<pre><code class="js">var str2 = &#39;妙味&#39;;
var bf2 = new Buffer(str2);
console.log(str2.length);//字符串长度
console.log(bf2.length);//字节长度</code></pre>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>TCP/IP协议</strong></p>
<p><strong>HTTP</strong>(Hyper Text Transfer Protocol，超文本传输协议)是一种通信协议 ，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<ul>
<li>它是一个应用层协议，承载于TCP之上</li>
<li>由请求和响应构成，是一个标准的客户端服务器模型</li>
</ul>
<p>TCP/IP协议族最重要的一点就是分层。按层次分别分为以下4层：</p>
<ul>
<li>应用层</li>
</ul>
<p>负责处理特定的应用程序，TCP/IP协议族内预存了各类通用的应用服务。<br>比如FTP、DNS等等，HTTP也在该层。</p>
<ul>
<li>传输层</li>
</ul>
<p>对上层应用层提供处于网络连接中两台计算机之间的数据传输。<br>该层有两个不同的协议：TCP和UDP。</p>
<ul>
<li>网络层</li>
</ul>
<p>处理网络上流动的数据包。<br>该层有协议有：IP、ICMP、IGMP。</p>
<ul>
<li>数据链路层</li>
</ul>
<p>处理连接网络的硬件部分。<br>包括操作系统、硬件设备驱动、网卡、光纤等。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/pic1.png" alt></p>
<p><strong>IP的作用：</strong></p>
<p>把各种数据包传送给对方。如果要保证确定传送到对方那里，则需要满足各类条件，其中最重要的两个条件是IP地址和MAC地址。</p>
<p>(1)IP地址：指明了节点被分配到的地址<br>(2)MAC地址：是指网卡所属的固定地址<br>(3)区别：IP地址可变换，但MAC地址基本上不会更改。</p>
<p><strong>URI与URL</strong></p>
<pre><code class="js">格式：
http://user:pass@www.example.com:80/home/index.html?age=11#mask
http：协议方案名
user:pass：登录信息（认证）
www.example.com：服务器地址
80：端口号
/hone/index.html：文件路径
age=11：查询字符串
mask：片段标识符 </code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="js">// 函数声明
function foo() {}

// 函数表达式
(function bar() {})

// 函数表达式
x = function hello() {}

if (x) {
   // 函数表达式
   function world() {}
}

// 函数声明
function a() {
   // 函数声明
   function b() {}
   if (0) {
      //函数表达式
      function c() {}
   }
}

//匿名函数
function () {}; </code></pre>
<blockquote>
<p>参考：<a href="http://my.oschina.net/u/2331760/blog/468672?fromerr=uCBMydOv" target="_blank" rel="noopener">http://my.oschina.net/u/2331760/blog/468672?fromerr=uCBMydOv</a></p>
</blockquote>
<p><strong>arguments.callee</strong></p>
<p>*<em>arguments.callee *</em>在哪一个函数中运行，它就代表哪个函数。 一般用在匿名函数中。<br>在匿名函数中有时会需要自己调用自己，但是由于是匿名函数，没有名子，无名可调。<br>这时就可以用arguments.callee来代替匿名的函数。</p>
<pre><code class="js">(function(n){

    if(n &gt; 1)    return n* arguments.calle(n-1);

    return n;

})(10);
//计算10的阶乘
//
function calleeDemo() {    
  alert(arguments.callee);
  return 10*10;
}

//function calleeDemo() {    
//alert(arguments.callee);
//return 10*10;
//}</code></pre>
<h1 id="2016年3月8日"><a href="#2016年3月8日" class="headerlink" title="2016年3月8日"></a>2016年3月8日</h1><h2 id="javascript-3"><a href="#javascript-3" class="headerlink" title="javascript"></a>javascript</h2><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p><strong>函数自执行</strong></p>
<p><strong>( function(){…} )()</strong> 、 <strong>( function (){…} () )</strong>这两种立即执行函数的写法。</p>
<p>要在函数体后面加括号就能立即调用，则这个函数必须是<strong>函数表达式</strong>，不能是<strong>函数声明</strong>。</p>
<h2 id="nodejs-3"><a href="#nodejs-3" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>Buffer类方法</strong></p>
<ul>
<li>一个用户更好的操作二进制数据的类<ul>
<li>我们在操作文件或者网络数据的时候，其实操作的就是二进制数据流，Node为 我们提供了一个更加方便的去操作这个数据流的类Buffer，他是一个全局的类。</li>
</ul>
</li>
<li><strong>new Buffer(size)</strong><ul>
<li>分配一个新的 size 大小单位为8位字节的 buffer。</li>
</ul>
</li>
<li><strong>new Buffer(array)</strong><ul>
<li>分配一个新的 buffer 使用一个8位字节 array 数组.</li>
</ul>
</li>
<li><strong>new Buffer(string,[encoding])</strong><ul>
<li>str String类型 - 需要存入buffer的string字符串.</li>
<li>encoding String类型 - 使用什么编码方式，参数可选.</li>
</ul>
</li>
<li><strong>buf.length</strong>:buffer的bytes大小</li>
<li><strong>buf[index]</strong>:获取或者设置在指定index索引位置的8位字节内容。</li>
<li><strong>buf.write(string,[offset],[length],[encoding])</strong>:根据参数offset偏移量和指定的encoding编码方式，将参数string数据写入buffer。<ul>
<li><strong>buf.write</strong>(要写入的字符串, 从Buffer对象中的几位开始写入, 写入的字符串的长度, 写入的字符串的编码)</li>
</ul>
</li>
<li><strong>buf.toString([encoding],[start],[end])</strong>:根据encoding参数（默认是”utf-8”)返回一个解码的string类型；</li>
<li><strong>buf.toJSON()</strong>:返回一个JSON表示的Buffer实例。JSON.stringify将会默认调用字符串序列化这个Buffer实例。</li>
<li><strong>buf.slice([start],[end])</strong>:返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，注意：修改这个新的buffer实例slice切片，将会改变原来的buffer。</li>
<li><strong>buffer.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd])</strong>：进行buffer的拷贝。</li>
</ul>
<pre><code class="js">var bf=new Buffer(&quot;1234567&quot;);
var bf2=new Buffer(10);

console.log(bf);
console.log(bf2);

bf.copy(bf2,2,1,3);
console.log(bf);
console.log(bf2);

//结果：
//
&lt;Buffer 31 32 33 34 35 36 37&gt;
&lt;Buffer 78 2f e5 4b b0 01 00 00 01 00&gt;
&lt;Buffer 31 32 33 34 35 36 37&gt;
&lt;Buffer 78 2f 32 33 b0 01 00 00 01 00&gt;</code></pre>
<p><strong>静态方法</strong></p>
<ul>
<li><strong>Buffer.isEncoding(encoding)</strong>:如果给定的编码encoding是有效的，返回true，否则返回false。</li>
<li><strong>Buffer.isBuffer(obj)</strong>:测试这个obj是否一个Buffer。</li>
<li><strong>Buffer.byteLength(string,[encoding])</strong>:将会返回这个字符串真实byte长度。encoding编码默认是：”utf8”。</li>
<li><strong>Buffer.concat(list,[totalLength])</strong>:返回一个保存着将传入buffer数组中所有buffer对象拼接在一起的buffer对象。</li>
</ul>
<h1 id="2016年3月9日"><a href="#2016年3月9日" class="headerlink" title="2016年3月9日"></a>2016年3月9日</h1><h2 id="nodejs-4"><a href="#nodejs-4" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><p><strong>fs.open(path, flags, [mode], callback)</strong></p>
<blockquote>
<p>异步打开一个文件</p>
</blockquote>
<ul>
<li>path : 要打开的文件的路径</li>
<li>flags : 打开文件的方式 读/写</li>
<li>mode : 设置文件的模式 读/写/执行  4/2/1(可以不填，意义不大）)</li>
<li>callback : 回调<ul>
<li>err : 文件打开失败的错误保存在err里面，如果成功err为null</li>
<li>fd : 被打开文件的标识，和定时器</li>
</ul>
</li>
</ul>
<pre><code class="js">fs.open(&#39;1.txt&#39;, &#39;r&#39;, function(err, fd) {

    //console.log(err);
    //console.log(fd);

    if (err) {
        console.log( &#39;文件打开失败&#39; );
    } else {
        console.log( &#39;文件打开成功&#39; );
        console.log( fd );
    }

});

//结果：

null
3
文件打开成功
3



fs.open(&#39;1.txt&#39;, &#39;r&#39;, function(err, fd) {
    console.log(fd);
});

console.log(&quot;hello&quot;);

//结果
hello
3
//两个操作独自运行，打开文件需要一定时间，所以先输出&quot;hello&quot;。</code></pre>
<p><strong>fs.openSync(path, flags, [mode])</strong></p>
<blockquote>
<p>fs.open() 的同步版.</p>
</blockquote>
<p><strong>fs.read(fd, buffer, offset, length, position, callback)</strong></p>
<blockquote>
<p>从指定的文档标识符fd读取文件数据。</p>
</blockquote>
<ul>
<li>fd : 通过open方法成功打开一个文件返回的编号</li>
<li>buffer : buffer对象</li>
<li>offset : 新的内容添加到buffer中的起始位置</li>
<li>length ： 添加到buffer中内容的长度</li>
<li>position ：读取的文件中的起始位置</li>
<li>callback : 回调<ul>
<li>err</li>
<li>buffer的长度</li>
<li>buffer对象</li>
</ul>
</li>
</ul>
<h1 id="2016年3月10日"><a href="#2016年3月10日" class="headerlink" title="2016年3月10日"></a>2016年3月10日</h1><h2 id="javascript-4"><a href="#javascript-4" class="headerlink" title="javascript"></a>javascript</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><pre><code class="js">//JSON.parse 将 JSON 字符串转换成对象。
var jsontext = &#39;{&quot;firstname&quot;:&quot;Jesper&quot;,&quot;surname&quot;:&quot;Aaberg&quot;,&quot;phone&quot;:[&quot;555-0100&quot;,&quot;555-0120&quot;]}&#39;; 
var contact = JSON.parse(jsontext); 
document.write(contact.surname + &quot;, &quot; + contact.firstname); 

// Output: Aaberg, Jesper
// 


//JSON.stringify() 方法可以将任意的 JavaScript 值序列化成 JSON 字符串
//JSON.parse() 方法可以将一个 JSON 字符串解析成为一个 JavaScript 值。在解析过程中，还可以选择性的篡改某些属性的原始解析值。
//

var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; 
var str = JSON.stringify(arr); 
document.write(str); 
document.write (&quot;&lt;br/&gt;&quot;); 

var newArr = JSON.parse(str); 

while (newArr.length &gt; 0) { 
    document.write(newArr.pop() + &quot;&lt;br/&gt;&quot;); 
} 


// Output: 
// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 
// c 
// b 
// a</code></pre>
<h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><ul>
<li>File System - 文件系统模块 -require(“fs”)<ul>
<li>该模块是核心模块，需要使用require导入后使用</li>
<li>该模块提供了操作的一些API</li>
</ul>
</li>
</ul>
<ul>
<li>fs.readFile(filename, [options], callback)<ul>
<li>fs.read()函数的同步版本。返回bytesRead的个数。</li>
</ul>
</li>
</ul>
<ul>
<li>fs.write(fd, buffer, offset, length[, position], callback)<ul>
<li>fd : 打开的文件</li>
<li>buffer : 要写入的数据</li>
<li>offset : buffer对象中要写入的数据的起始位置</li>
<li>length : 要写入的buffer数据的长度</li>
<li>position : fd中的起始位置</li>
<li>callback : 回调</li>
</ul>
</li>
</ul>
<pre><code class="js">fs.open(&#39;1.txt&#39;,&#39;r+&#39;,function(err,fd){
    console.log(err);
    console.log(fd);
    if (err) {
        console.log(&quot;打开文件失败。&quot;);
    }else{
        var bf=new Buffer(&quot;acdb&quot;);
        console.log(bf);
        fs.write(fd,bf,0,3,10,function(){
            console.log(arguments);//{ &#39;0&#39;: null(错误信息), &#39;1&#39;: 5(数据长度), &#39;2&#39;: &lt;Buffer 31 32 33 34 33 35 34 35&gt;(buffer内容) }
            console.log(&quot;Bf更新后内容：&quot;+bf);

        });
    }

})</code></pre>
<ul>
<li>fs.write(fd, data[, position[, encoding]],callback)<ul>
<li>把data写入到文档中，通过指定的fd。如果data不是buffer对象的实例则会把值强制转化成一个字符串。</li>
</ul>
</li>
<li>fs.writeSync(fd, buffer, offset, length[, position])<ul>
<li>fs.write()同步版本</li>
</ul>
</li>
<li>fs.writeSync(fd, data[, position[, encoding]])<ul>
<li>fs.write()同步版本</li>
</ul>
</li>
<li>fs.close(fd,callback)<ul>
<li>关闭一个打开的文件</li>
</ul>
</li>
<li>fs.closeSync(fd)<ul>
<li>fs.close()的同步版本。</li>
</ul>
</li>
<li>fs.writeFile(filename, data, [options], callback)<ul>
<li>异步的将数据写入一个文件，如果文件不存在则新建，如果文件原先存在，会被替换。data可以是一个string，也可以是一个原生buffer。</li>
</ul>
</li>
</ul>
<pre><code class="js">var fs=require(&quot;fs&quot;);
var rq=new Date();

var time=rq.getFullYear()+&quot;年&quot;+(rq.getMonth()+1)+&quot;月&quot;+rq.getDate()+&quot;日&quot;;
var fileName=time+&quot;.markdown&quot;;
console.log(fileName);
fs.writeFile(&quot;1/&quot;+fileName,&quot;#&quot;+time,function(){
    console.log(arguments);
});</code></pre>
<ul>
<li>fs.writeFileSync(filename, data, [options])<ul>
<li>fs.writeFile的同步版本。注意：没有callback，也不需要。</li>
</ul>
</li>
<li>fs.appendFile(filename, data, [options], callback)<ul>
<li>异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新 文件。data可以是一个string，也可以是一个原生buffer。</li>
</ul>
</li>
<li>fs.appendFileSync(filename, data, [options])<ul>
<li>fs.appendFile的同步版本 </li>
</ul>
</li>
<li>fs.readFile(filename, [options], callback)<ul>
<li>异步读取一个文件的全部内容</li>
</ul>
</li>
<li>fs.readSync(fd, buffer, offset, length, position)<ul>
<li>fs.readFile同步版本 </li>
</ul>
</li>
<li>fs.exists(path, callback)<ul>
<li>检查指定路径的文件或者目录是否存在</li>
</ul>
</li>
<li>fs.existsSync(path)<ul>
<li>fs.exists 函数的同步版。</li>
</ul>
</li>
<li>fs.unlink(path, callback)<ul>
<li>删除一个文件</li>
</ul>
</li>
<li>fs.unlinkSync(path)<ul>
<li>fs.unlink()同步版本。</li>
</ul>
</li>
</ul>
<h1 id="2016年3月11日"><a href="#2016年3月11日" class="headerlink" title="2016年3月11日"></a>2016年3月11日</h1><h2 id="Nodejs-1"><a href="#Nodejs-1" class="headerlink" title="Nodejs"></a>Nodejs</h2><h3 id="File-System-文件系统模块"><a href="#File-System-文件系统模块" class="headerlink" title="File System 文件系统模块"></a>File System 文件系统模块</h3><ul>
<li>fs.readFile(filename, [options], callback)<ul>
<li>异步读取一个文件的全部内容</li>
</ul>
</li>
<li>fs.readSync(fd, buffer, offset, length, position)<ul>
<li>fs.readFile同步版本 </li>
</ul>
</li>
</ul>
<pre><code class="js">fs.readFile(&quot;text.txt&quot;,function(err,data){
    if (err) {
        console.log(&quot;error&quot;);
    }else{
        console.log(data.toString());
    }
})
// Output: 
// hello</code></pre>
<ul>
<li>fs.unlink(path, callback)<ul>
<li>删除一个文件</li>
</ul>
</li>
<li>fs.unlinkSync(path)<ul>
<li>fs.unlink()同步版本。</li>
</ul>
</li>
</ul>
<pre><code class="js">fs.unlink(&quot;2.txt&quot;,function(err){
    if (err) {
        console.log(&quot;error&quot;);
    }else{
        console.log(&quot;OK!&quot;);
    }
});
// Output: 
// OK!</code></pre>
<ul>
<li><p>fs.rename(oldPath, newPath, callback)</p>
<ul>
<li>重命名</li>
</ul>
</li>
<li><p>fs.renameSync(oldPath, newPath)</p>
<ul>
<li>同步版本的rename()</li>
</ul>
</li>
</ul>
<pre><code class="js">fs.rename(&quot;2.txt&quot;,&quot;2.new.txt&quot;,function(err){
    if (err) {
        console.log(&quot;error&quot;);
    }else{
        console.log(&quot;OK!&quot;);
    }
});
</code></pre>
<ul>
<li>fs.stat(path, callback)<ul>
<li>读取文件信息</li>
</ul>
</li>
<li>fs.statSync(path)<ul>
<li>fs.stat()同步版本。</li>
</ul>
</li>
</ul>
<pre><code class="js">fs.stat(&#39;2.txt&#39;,function(){
    console.log(arguments);
})

//Output:
/*{ &#39;0&#39;: null,
  &#39;1&#39;: 
   { dev: -1302886562,
     mode: 33206,
     nlink: 1,
     uid: 0,
     gid: 0,
     rdev: 0,
     blksize: undefined,
     ino: 22799473113575696,
     size: 15,
     blocks: undefined,
     atime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间),
     mtime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间),
     ctime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间),
     birthtime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间) } }
*/</code></pre>
<ul>
<li>fs.watch(filename,[options],[listener])<ul>
<li>观察指定路径的改变，filename路径可以是文件或者目录。</li>
</ul>
</li>
</ul>
<pre><code class="js">var fs = require(&#39;fs&#39;);

var filename = &#39;2.new.txt&#39;;

fs.watch(filename, function(ev, fn) {
    console.log(ev);
    if (fn) {
        console.log(fn + &#39; 发生了改变&#39;);
    } else {
        console.log(&#39;...hah.&#39;);
    }

});</code></pre>
<blockquote>
<p>如果系统底层函数出于某些原因不可用，那么 fs.watch 也就无法工作。例如，监视网络文件系统(如 NFS, SMB 等)的文件或者目录，就时常不能稳定的工作，有时甚至完全不起作用。</p>
</blockquote>
<ul>
<li><p>fs.mkdir(path, [mode], callback)</p>
<ul>
<li>创建文件夹</li>
<li>[mode]<ul>
<li>33206:文件</li>
<li>16822文件夹</li>
</ul>
</li>
</ul>
</li>
<li><p>fs.mkdirSync(path, [mode])</p>
<ul>
<li>同步版的 mkdir()</li>
</ul>
</li>
<li><p>fs.rmdir(path, callback)</p>
<ul>
<li>删除文件夹</li>
</ul>
</li>
<li><p>fs.rmdirSync(path)</p>
<ul>
<li>fs.redir()的同步版</li>
</ul>
</li>
</ul>
<pre><code class="js">fs.mkdir(&quot;./12&quot;,33206,function(){
    console.log(arguments);
});
/*fs.rmdir(&quot;./12&quot;,function(){
    console.log(arguments);
})*/</code></pre>
<ul>
<li>fs.readdirSync(path)<ul>
<li>异步版的 readdir()。 读取 path 路径所在目录的内容。 回调函数 (callback) 接受两个参数 (err, files) 其中 files是一个存储目录中所包含的文件名称的数组，数组中不包括 ‘.’ 和 ‘..’。</li>
</ul>
</li>
</ul>
<pre><code class="js">var fs = require(&#39;fs&#39;);

fs.readdir(&#39;../FileSystem&#39;, function(err, fileList) {

    //console.log(fileList);

    fileList.forEach(function(f) {

        fs.stat(f, function(err, info) {
            //console.log(info);

           switch (info.mode) {
                case 16822:
                    console.log( &#39;[文件夹] &#39; + f );
                    break;

                case 33206:
                    console.log( &#39;[文件] &#39; + f );
                    break;

                default :
                    console.log( &#39;[其他类型] &#39; + f );
                    break;
            }

        });

    });

})
</code></pre>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul>
<li><p>Unicode:(统一码)是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。</p>
</li>
<li><p>UTF-8:针对Unicode的可变长度字符编码，又称万国码。</p>
<ul>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </li>
<li>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</li>
</ul>
</li>
<li><p>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，</p>
</li>
</ul>
<h1 id="2016年3月12日"><a href="#2016年3月12日" class="headerlink" title="2016年3月12日"></a>2016年3月12日</h1><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><h4 id="Flex容器属性（flex-container）"><a href="#Flex容器属性（flex-container）" class="headerlink" title="Flex容器属性（flex container）"></a>Flex容器属性（flex container）</h4><p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex1.png" alt> </p>
<p>容器默认存在两根轴：水平的主轴<strong>（main axis）</strong>和垂直的交叉轴<strong>（cross axis）</strong>。主轴的开始位置（与边框的交叉点）叫做<strong>main start</strong>，结束位置叫做<strong>main end</strong>；交叉轴的开始位置叫做<strong>cross start</strong>，结束位置叫做<strong>cross end</strong>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做<strong>main size</strong>，占据的交叉轴空间叫做<strong>cross size</strong>。</p>
<p><strong>flex容器属性</strong></p>
<ul>
<li><strong>flex-direction</strong></li>
</ul>
<p><strong>flex-direction</strong>属性决定主轴的方向（即项目的排列方向）。</p>
<pre><code class="css">.box {
    flex-direction: row | row-reverse | column | column-reverse;
}</code></pre>
<ol>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ol>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-direction.png" alt></p>
<ul>
<li><strong>flex-wrap</strong>属性</li>
</ul>
<pre><code class="css"> .box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}</code></pre>
<ol>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ol>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-wrap.jpg" alt> </p>
<ul>
<li><strong>flex-flow</strong></li>
</ul>
<pre><code class="js">.box {
  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
}</code></pre>
<p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<ul>
<li><strong>justify-content</strong></li>
</ul>
<p><strong>justify-content</strong>属性定义了项目在主轴上的对齐方式。</p>
<pre><code class="js">.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}</code></pre>
<ol>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ol>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/justify-content.png" alt></p>
<ul>
<li><strong>align-items</strong></li>
</ul>
<p><strong>align-items</strong>属性定义项目在交叉轴上如何对齐。</p>
<pre><code class="js">.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}</code></pre>
<ol>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ol>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/align-items.png" alt></p>
<ul>
<li><strong>align-content</strong></li>
</ul>
<p><strong>align-content</strong>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<pre><code class="js">.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}</code></pre>
<ol>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ol>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/align-content.png" alt></p>
<h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><ul>
<li>order</li>
</ul>
<pre><code class="js">.item {
  order: &lt;integer&gt;;
}</code></pre>
<p><strong>order</strong>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/order.png" alt></p>
<ul>
<li><strong>flex-grow</strong></li>
</ul>
<p><strong>flex-grow</strong>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<pre><code class="js">.item {
  flex-grow: &lt;number&gt;; /* default 0 */
}</code></pre>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-grow.png" alt></p>
<ul>
<li><strong>flex-shrink</strong></li>
</ul>
<p><strong>flex-shrink</strong>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 </p>
<pre><code class="js">.item {
  flex-shrink: &lt;number&gt;; /* default 1 */
}</code></pre>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-shrink.jpg" alt></p>
<ul>
<li><strong>flex-basis</strong></li>
</ul>
<p><strong>flex-basis</strong>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 </p>
<pre><code class="js">.item {
  flex-basis: &lt;length&gt; | auto; /* default auto */
}</code></pre>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<ul>
<li><strong>flex</strong></li>
</ul>
<p><strong>flex</strong>属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<pre><code class="js">.item {
  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]
}</code></pre>
<ul>
<li><strong>align-self</strong></li>
</ul>
<pre><code class="js">.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}</code></pre>
<p><strong>align-self</strong>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<pre><code class="js">.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}</code></pre>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/align-self.png" alt></p>
<h1 id="2016年3月13日"><a href="#2016年3月13日" class="headerlink" title="2016年3月13日"></a>2016年3月13日</h1><h2 id="javascript-5"><a href="#javascript-5" class="headerlink" title="javascript"></a>javascript</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table>
<thead>
<tr>
<th align="center">转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td align="center">\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td align="center">\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td align="center">\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td align="center">\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td align="center">\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td align="center">\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td align="center">\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td align="center">?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td align="center">\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td align="center">\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<blockquote>
<p>常用转义字符：<a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener">http://tool.oschina.net/commons?type=2</a></p>
</blockquote>
<blockquote>
<p>HTML、CSS特殊字符表： <a href="http://www.w3cplus.com/resources/HTML-special-character-sheets.html" target="_blank" rel="noopener">http://www.w3cplus.com/resources/HTML-special-character-sheets.html</a><br>HTML 特殊符号编码对照表: <a href="http://tool.chinaz.com/Tools/HtmlChar.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/HtmlChar.aspx</a></p>
</blockquote>
<h1 id="2016年3月14日"><a href="#2016年3月14日" class="headerlink" title="2016年3月14日"></a>2016年3月14日</h1><h2 id="nodejs-5"><a href="#nodejs-5" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><p>文件系统模块中的异步方法需要一个完成时的<strong>回调函数</strong>作为最后一个传入形参。<br>回调函数的构成由您调用的异步方法所决定，通常情况下回调函数的第一个形参为返回的错误信息(<strong>err</strong>)。 如果异步操作执行正确并返回，该错误形参则为<strong>null</strong>或者<strong>undefined</strong>。</p>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ol>
<li>用户通过浏览器发送一个http的请求到指定的主机</li>
<li>服务器接收到该请求，对该请求进行分析和处理</li>
<li>服务器处理完成以后，返回对应的数据到用户机器</li>
<li>浏览器接收服务器返回的数据，并根据接收到的进行分析和处理</li>
</ol>
<p>客户端    服务端</p>
<p>由客户端发送一个http请求到指定的服务端 -&gt; 服务端接收并处理请求 -&gt; 返回数据到客户端</p>
<pre><code class="js">var http=require(&#39;http&#39;);
var server=http.createServer();

server.listen(8080);

console.log(server.address());

//Output
//{ address: &#39;::&#39;, family: &#39;IPv6&#39;, port: 8080 }</code></pre>
<pre><code class="js">//加载一个http模块
var http = require(&#39;http&#39;);
//通过http模块下的createServer创建并返回一个web服务器对象
var server = http.createServer();

server.on(&#39;error&#39;, function(err){
    console.log(err);
});

server.on(&#39;listening&#39;, function() {
    console.log(&#39;listening...&#39;);
})

server.on(&#39;request&#39;, function(req, res) {
    console.log(&#39;有客户端请求了&#39;);

    //console.log(req);

    //res.write(&#39;hello&#39;);

    res.setHeader(&#39;miaov&#39;, &#39;leo&#39;);

    res.writeHead(200, &#39;miaov&#39;, {
        //&#39;content-type&#39; : &#39;text/plain&#39;

        &#39;content-type&#39; : &#39;text/html;charset=utf-8&#39;
    });

    res.write(&#39;&lt;h1&gt;hello&lt;/h1&gt;&#39;);

    res.end();

})

server.listen(8080, &#39;localhost&#39;);

//console.log(server.address());

</code></pre>
<ul>
<li><p>var http=require(‘http’);</p>
</li>
<li><p>var server=http.createServer([requestListener])</p>
<ul>
<li>创建并返回一个HTTP服务器对象</li>
<li>requestListener：监听到客户端连接的回调函数</li>
</ul>
</li>
<li><p>server.listen([port,[hostname],[backlog],[callback]])</p>
<ul>
<li>监听客户端连接请求，只有当调用listen方法以后，服务器才开始工作</li>
<li>port：监听的端口</li>
<li>hostname：主机名（IP/域名）</li>
<li>backlog：连接等待队列的最大长度</li>
<li>callback：调用listen方法并成功开启监听以后，会触发一个listen事件，callback将作为该事件的执行函数。</li>
</ul>
</li>
<li><p>listening事件：当server调用listen方法并成功开始监听以后触发的事件。</p>
</li>
<li><p>error事件：当有客户端发送请求道该主机和端口的请求的时候触发</p>
<ul>
<li>参数request：http.IncomingMessage的一个实例，通过他我们可以获取到这次请求的一些信息，比如信息，数据等。</li>
<li>参数response：http:http.ServerResponse的一个实例，通过他我们可以向该请求的客户端输出返回的响应。</li>
</ul>
</li>
</ul>
<h1 id="2016年3月15日"><a href="#2016年3月15日" class="headerlink" title="2016年3月15日"></a>2016年3月15日</h1><h2 id="nodejs-6"><a href="#nodejs-6" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><pre><code class="js">//加载一个http模块
var http = require(&#39;http&#39;);
//通过http模块下的createServer创建并返回一个web服务器对象
var server = http.createServer();

server.on(&#39;error&#39;, function(err){
    console.log(err);
});

server.on(&#39;listening&#39;, function() {
    console.log(&#39;listening...&#39;);
})

server.on(&#39;request&#39;, function(req, res) {

    console.log(&#39;有客户端请求了&#39;);

    //console.log(req);

    //res.write(&#39;hello&#39;);

    res.setHeader(&#39;miaov&#39;, &#39;leo&#39;);

    res.writeHead(200, &#39;miaov&#39;, {
        //&#39;content-type&#39; : &#39;text/plain&#39;

        &#39;content-type&#39; : &#39;text/html;charset=utf-8&#39;
    });

    res.write(&#39;&lt;h1&gt;hello&lt;/h1&gt;&#39;);

    res.end();

})

server.listen(8080, &#39;localhost&#39;);

//console.log(server.address());

</code></pre>
<ul>
<li>参数request对象 -http.IncomingMessage <ul>
<li>httpVersion:使用的http协议的版本</li>
<li>headers：请求头信息中的数据</li>
<li>url：请求的地址</li>
<li>method：请求方式</li>
</ul>
</li>
<li>参数response对象 - http.ServerResponse <ul>
<li>write(chunk,[encoding]):发送一个数据块到响应正文中</li>
<li>end([chunk],[encoding]):当所有的正文和头信息发送完成以后调用该方法告诉服务器数据已经全部发送完成了，这个方法在每次完成信息发送以后必须调用，并且是最后调用。</li>
<li>statusCode:该属性用来设置返回的状态码</li>
<li>setHeader(name,value):设置返回头信息</li>
<li>writeHeader(statusCode,[reasonPhrase],[headers])<ul>
<li>这个方法只能在当前请求中使用一次，并且必须在response.end()之前调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><p><strong>同步通信</strong>是指：发送方和接收方通过一定机制，实现收发步调协调。如：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</p>
<p><strong>异步通信</strong>是指：发送方的发送不管接收方的接收状态，如：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p>
<p><strong>阻塞</strong>和<strong>非阻塞</strong>就比较容易理解了，没有上面那么多场景，<strong>阻塞</strong>就是这个事情阻到这儿了，不能继续往下干事了，<strong>非阻塞</strong>就是这个事情不会阻碍你继续干后面的事情。</p>
<p><strong>阻塞</strong>可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</p>
<p><strong>同步</strong>是两个对象之间的关系，而<strong>阻塞</strong>是一个对象的状态。</p>
<h1 id="2016年3月16日"><a href="#2016年3月16日" class="headerlink" title="2016年3月16日"></a>2016年3月16日</h1><h2 id="javascript-6"><a href="#javascript-6" class="headerlink" title="javascript"></a>javascript</h2><h3 id="实参与形参"><a href="#实参与形参" class="headerlink" title="实参与形参"></a>实参与形参</h3><pre><code class="js">function addNum(var para1,var para2){
var sum = para1+para2;
return sum;
}</code></pre>
<p>形参指函数定义时候的参数，在这里就是para1和para2。实参是实际传送给函数的参数，在这里就是20和30。</p>
<h3 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h3><ul>
<li><p>MVC</p>
<ul>
<li>model</li>
<li>view </li>
<li>controller<ul>
<li>MV的桥梁</li>
</ul>
</li>
</ul>
</li>
<li><p>service服务</p>
<ul>
<li>$内部</li>
<li>$scope</li>
<li>$apply</li>
<li>$watch</li>
<li>$rootScope</li>
<li>$http</li>
<li>$timeout</li>
<li>$filter</li>
</ul>
</li>
<li><p>directive指令</p>
<ul>
<li>ng内部</li>
<li>ng-app</li>
<li>ng-controller</li>
<li>ng-repeat</li>
<li>ng-click</li>
</ul>
</li>
</ul>
<p>​    </p>
<h1 id="2016年3月17日"><a href="#2016年3月17日" class="headerlink" title="2016年3月17日"></a>2016年3月17日</h1><h2 id="javascript-7"><a href="#javascript-7" class="headerlink" title="javascript"></a>javascript</h2><h3 id="angularjs-1"><a href="#angularjs-1" class="headerlink" title="angularjs"></a>angularjs</h3><ul>
<li>angularJs特性？<ul>
<li>MVC模式</li>
<li>模块系统</li>
<li>指令系统</li>
<li>依赖注入</li>
<li>双向数据绑定</li>
</ul>
</li>
<li>angularJs的作用域<ul>
<li>$scope</li>
<li>$rootScope</li>
<li>依赖注入</li>
<li>服务</li>
</ul>
</li>
</ul>
<pre><code class="js">
function Aaa($scope ,$rootScope){//依赖注入，形参不能改
    $scope.name=&#39;hello world!!&#39;;
    $rootScope.txt=&quot;nihao&quot;;//全局变量，
}
function Bbb($scope){
    $scope.name=&#39;Bbb hello world!!&#39;;
}</code></pre>
<pre><code class="html">&lt;div ng-controller=&#39;Aaa&#39;&gt;
    &lt;p&gt;{{name}}&lt;/p&gt;
&lt;/div&gt;
&lt;div  ng-controller=&quot;Bbb&quot;&gt;
    &lt;span&gt;{{txt}}&lt;/span&gt;//会先在局部查找，然后在全局查找。
&lt;/div&gt;</code></pre>
<ul>
<li>angularJs的指令系统<ul>
<li>ng-app<ul>
<li>初始化一个angularjs应用程序</li>
</ul>
</li>
<li>ng-controller<ul>
<li>定义控制器</li>
</ul>
</li>
</ul>
</li>
<li>angularJs的双向数据绑定<ul>
<li>MVVM</li>
<li>$timeout<ul>
<li>有刷新功能</li>
</ul>
</li>
<li>ng-click<ul>
<li>click事件</li>
</ul>
</li>
<li>ng-model<ul>
<li>绑定数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">    function Aaa($scope,$timeout){
    $scope.name = &#39;hello&#39;;
    /*setTimeout(function(){
        $scope.name = &#39;hi&#39;;
    },2000);*/
    /*$timeout(function(){
        $scope.name = &#39;hi&#39;;
    },2000);*/

    $scope.show = function(){
        $scope.name = &#39;hi&#39;;
    };

}</code></pre>
<pre><code class="html">&lt;div ng-controller=&quot;Aaa&quot; ng-click=&quot;show()&quot;&gt;
    &lt;p&gt;{{name}}&lt;/p&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>过滤器<ul>
<li>currency</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;span&gt;{{all.money*all.num|currency:'@'}}&lt;/span&gt;</code></pre>
<ul>
<li>$watch<ul>
<li>监听数据变化</li>
<li>三个参数<ul>
<li>第三个为<strong>true</strong>时可以监听一个整体，否则是单个。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="js">$scope.$watch($scope.sum,function(newVal,oldVal){
        //console.log(newVal);
        //console.log(oldVal);

$scope.iphone.fre = newVal &gt;= 100 ? 0 : 10;

});</code></pre>
<h1 id="2016年3月18日"><a href="#2016年3月18日" class="headerlink" title="2016年3月18日"></a>2016年3月18日</h1><h2 id="angularjs-2"><a href="#angularjs-2" class="headerlink" title="angularjs"></a>angularjs</h2><p>模块写法：</p>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){
    $scope.name = &#39;hello&#39;;
}]);
m1.controller(&#39;Bbb&#39;,[&#39;$scope&#39;,function($scope){
    $scope.name = &#39;hi&#39;;
}]);</code></pre>
<ul>
<li>angular.bind()</li>
</ul>
<pre><code class="js">function show(n1,n2){
    alert(n1);
    alert(n2);
    alert(this);
}

angular.bind(document,show,3)(4);//改this指向</code></pre>
<ul>
<li>angular.copy()</li>
</ul>
<pre><code class="js">var a = {
    name : &#39;hello&#39;
};
var b = {
    age : &#39;20&#39;
};

var c = angular.copy(a,b);   //a把所有值覆盖给了b,也拷贝了给C对象</code></pre>
<ul>
<li>angular.extend();  </li>
</ul>
<pre><code class="js">
var a = {
    name : &#39;hello&#39;
};
var b = {
    age : &#39;20&#39;
};

var c = angular.extend(b,a); //对象继承

console.log(b);
//{age: &quot;20&quot;, name: &quot;hello&quot;}//继承了a的属性方法。

console.log(c);
//{age: &quot;20&quot;, name: &quot;hello&quot;}
//
console.log(a);
//{name: &quot;hello&quot;}</code></pre>
<ul>
<li>angularJs的工具方法<ul>
<li>angular.isArray<ul>
<li>判断是否数组</li>
</ul>
</li>
<li>angular.isDate<ul>
<li>如果引用的是日期返回 true</li>
</ul>
</li>
<li>angular.isDefined<ul>
<li>如果引用的已定义返回 true</li>
</ul>
</li>
<li>angular.isUndefined<ul>
<li>如果引用的未定义返回 true</li>
</ul>
</li>
<li>angular.isFunction<ul>
<li>如果引用的是函数返回 true</li>
</ul>
</li>
<li>angular.isNumber<ul>
<li>如果引用的是数字返回 true</li>
</ul>
</li>
<li>angular.isObject<ul>
<li>如果引用的是对象返回 true</li>
</ul>
</li>
<li>angular.isString<ul>
<li>如果引用的是字符串返回 true</li>
</ul>
</li>
<li>angular.isElement<ul>
<li>判断是否元素</li>
</ul>
</li>
<li>angular.version<ul>
<li>返回版本信息</li>
</ul>
</li>
<li>angular.equals<ul>
<li>判断是否相等。</li>
</ul>
</li>
<li>angular.forEach<ul>
<li>循环，接受三个参数。</li>
</ul>
</li>
<li>angular.fromJson/toJson<ul>
<li>json与字符串的转换。</li>
</ul>
</li>
<li>angular.identity/noop<ul>
<li>空函数，或者返回指定内容。防止程序出问题。</li>
</ul>
</li>
<li>angular.lowercase/uppercase<ul>
<li>字符串全部大写或者小写。</li>
</ul>
</li>
<li>angular.element<ul>
<li>选择元素，类似jQuery的选择器<code>angular.element === $</code>。</li>
</ul>
</li>
<li>angular.bootstrap<ul>
<li>在javascript里动态初始化</li>
</ul>
</li>
<li>angular.injector</li>
</ul>
</li>
</ul>
<h1 id="2016年3月19日"><a href="#2016年3月19日" class="headerlink" title="2016年3月19日"></a>2016年3月19日</h1><h2 id="angularjs-3"><a href="#angularjs-3" class="headerlink" title="angularjs"></a>angularjs</h2><ul>
<li>$scope<ul>
<li>$scope.$watch<ul>
<li>监听程序变化</li>
</ul>
</li>
<li>$scope.$apply<ul>
<li>监听数据变化，数据变化，会影响视图。</li>
</ul>
</li>
</ul>
</li>
<li>angular.module<ul>
<li>controller</li>
<li>run</li>
</ul>
</li>
<li>angularJs的过滤器<ul>
<li>currency</li>
<li>number</li>
<li>lowercase/uppercase</li>
<li>json</li>
<li>limitTo</li>
<li>date</li>
<li>orderBy</li>
<li>filter</li>
</ul>
</li>
</ul>
<pre><code class="js">//过滤器组合使用
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,&#39;$filter&#39;,function($scope,$filter){

    //$scope.name = &#39;723894734.7489545&#39;;
    //$scope.name = &#39;hello&#39;;
    //$scope.name = {&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:&quot;20&quot;};
    //$scope.name = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];
    $scope.name = &#39;3748935795&#39;;

    /*$scope.name = [
        {color:&quot;red&quot;,age:&quot;20&quot;},
        {color:&quot;yellow&quot;,age:&quot;30&quot;},
        {color:&quot;blue&quot;,age:&quot;40&quot;},
        {color:&quot;green&quot;,age:&quot;10&quot;}
    ];*/

    //$scope.name = $filter(&#39;uppercase&#39;)(&#39;hello&#39;);
    //$scope.name = $filter(&#39;number&#39;)(&#39;236478234.3647348&#39;,1);
    //$scope.name = $filter(&#39;date&#39;)(&#39;236478234&#39;,&#39;hh&#39;);

    //$scope.name = &#39;hello&#39;;

    $scope.name = $filter(&#39;firstUpper&#39;)(&#39;hello&#39;);


}]);


//自定义过滤器
//

m1.filter(&#39;firstUpper&#39;,function(){
    return function(str,num){
        //console.log(num);
        return str.charAt(0).toUpperCase() + str.substring(1);
    }
});</code></pre>
<ul>
<li>ng-repeat</li>
<li>ng-app<ul>
<li>初始化angularjs这个库的指令</li>
</ul>
</li>
<li>ng-controller<ul>
<li>调用控制器，把数据与视图连接在一起</li>
</ul>
</li>
<li><h2 id="ng-model"><a href="#ng-model" class="headerlink" title="ng-model"></a>ng-model</h2></li>
<li>ng-click<ul>
<li>点击事件</li>
</ul>
</li>
</ul>
<h1 id="2016年3月20日"><a href="#2016年3月20日" class="headerlink" title="2016年3月20日"></a>2016年3月20日</h1><h2 id="angularjs-4"><a href="#angularjs-4" class="headerlink" title="angularjs"></a>angularjs</h2><p><strong>ng-repeat 指令</strong></p>
<ul>
<li>扩展部分<ul>
<li>$index<ul>
<li>索引号</li>
</ul>
</li>
<li>$first<ul>
<li>第一项返回true，其他都是false</li>
</ul>
</li>
<li>$middle<ul>
<li>除了头尾，都返回true。</li>
</ul>
</li>
<li>$last<ul>
<li>最后一项返回true。</li>
</ul>
</li>
<li>$even<ul>
<li>奇数行返回true</li>
</ul>
</li>
<li>$odd<ul>
<li>偶数行返回true</li>
</ul>
</li>
<li>ng-repeat-start</li>
<li>ng-repeat-end</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){

    $scope.dataList = [
        &#39;aaaaa&#39; , &#39;bbbbb&#39; , &#39;cccccc&#39; , &#39;dddddd&#39; , &#39;eeeeee&#39;
    ];

}]);
</code></pre>
<pre><code class="html">&lt;div ng-repeat-start=&quot;data in dataList&quot;&gt;{{data}}&lt;/div&gt;
&lt;p&gt;{{data}}&lt;/p&gt;
&lt;div ng-repeat-end&gt;{{data}}&lt;/div&gt;</code></pre>
<p><strong>事件指令</strong></p>
<ul>
<li>ng-click/dblclick</li>
<li>ng-mousedown/up</li>
<li>ng-mouseenter/leave</li>
<li>ng-mousemove/over/out</li>
<li>ng-keydown/up/press</li>
<li>ng-focus/blur</li>
<li>ng-submit</li>
<li>ng-selected</li>
</ul>
<pre><code class="js">&lt;input type=&quot;checkbox&quot; ng-model=&quot;aaa&quot;&gt;
&lt;select&gt;
    &lt;option&gt;11111&lt;/option&gt;
    &lt;option ng-selected=&quot;aaa&quot;&gt;22222&lt;/option&gt;
    &lt;option&gt;33333&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<ul>
<li>ng-change</li>
<li>ng-copy<ul>
<li>进行复制操作会触发这个事件 </li>
</ul>
</li>
<li>ng-cut<ul>
<li>进行剪切操作会触发这个事件 </li>
</ul>
</li>
<li>ng-paste<ul>
<li>进行粘贴操作会触发这个事件 </li>
</ul>
</li>
</ul>
<p><strong>angularJs的指令</strong></p>
<ul>
<li>ng-disabled<ul>
<li>服务 $interval，动态修改按钮的状态。</li>
</ul>
</li>
<li>ng-readonly<ul>
<li>针对文本可读状态， 对按钮没效果。</li>
</ul>
</li>
<li>ng-checked</li>
<li>ng-value</li>
<li>ng-bind<ul>
<li>只能嵌套一个</li>
</ul>
</li>
<li>ng-cloak<ul>
<li>控制display ，没解释完是none，解释完才显示 出来。</li>
</ul>
</li>
<li>ng-bind-template<ul>
<li>可以嵌套多个</li>
</ul>
</li>
<li>ng-bind-html<ul>
<li>不能解释标签，必须要添加插件</li>
<li><a href="http://www.bootcdn.cn/angular.js/" target="_blank" rel="noopener">http://www.bootcdn.cn/angular.js/</a></li>
</ul>
</li>
<li>ng-non-bindable<ul>
<li>不让表达式去解释</li>
</ul>
</li>
</ul>
<p><strong>angularJs的样式指令</strong></p>
<ul>
<li>ng-class</li>
<li>ng-style</li>
<li>ng-href</li>
<li>ng-src</li>
<li>ng-attr-(suffix)<ul>
<li>一般的标签属性设置</li>
</ul>
</li>
</ul>
<pre><code class="js">var m1 = angular.module(&#39;myApp&#39;,[]);
m1.controller(&#39;Aaa&#39;,[&#39;$scope&#39;,function($scope){
    $scope.text = &#39;hello&#39;;
    $scope.style = &quot;{color:&#39;red&#39;,background:&#39;yellow&#39;}&quot;;
    $scope.sClass = &quot;{red:true,yellow:true}&quot;;
    $scope.url = &quot;http://www.baidu.com&quot;;
}]);
</code></pre>
<pre><code class="html">&lt;div ng-controller=&quot;Aaa&quot;&gt;
    &lt;div ng-class=&quot;{{sClass}}&quot;&gt;{{text}}&lt;/div&gt;
    &lt;div ng-style=&quot;{{style}}&quot;&gt;{{text}}&lt;/div&gt;
    &lt;a ng-href=&quot;{{url}}&quot;&gt;aaaaaaa&lt;/a&gt;
    &lt;a ng-attr-href=&quot;{{url}}&quot; ng-attr-title=&quot;{{text}}&quot; ng-attr-class=&quot;&quot; ng-attr-style=&quot;&quot;&gt;aaaaaaa&lt;/a&gt;
&lt;/div&gt; </code></pre>
<ul>
<li>ng-init</li>
<li>ng-include<ul>
<li>引入其他文件模板</li>
</ul>
</li>
</ul>
<pre><code class="js">&lt;div ng-controller=&quot;Aaa&quot; ng-include=&quot;&#39;temp.html&#39;&quot;&gt;</code></pre>
<ul>
<li>ng-model<ul>
<li>双向数据绑定</li>
<li>ng-model-options</li>
<li>updateOn<ul>
<li>双向数据绑定延迟触发</li>
</ul>
</li>
</ul>
</li>
<li>ng-controller<ul>
<li>as<ul>
<li>构造函数的属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>angularjs标签指令</strong></p>
<ul>
<li>&lt; a &gt;</li>
<li>&lt; select &gt;<ul>
<li>ng-options</li>
<li>for   in</li>
</ul>
</li>
<li>&lt; textarea &gt;</li>
<li>&lt; input &gt;</li>
<li>&lt; form &gt;<ul>
<li>novalidate<ul>
<li>防止表单默认行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>ngularJs的表单验证</strong></p>
<ul>
<li>$valid<ul>
<li>是否有效，有效返回true。可用于Email输入。</li>
</ul>
</li>
<li>$invalid</li>
<li>$pristine<ul>
<li>是否修改过，是就返回true。</li>
</ul>
</li>
<li>$dirty<ul>
<li>初始值返回false</li>
</ul>
</li>
<li>$error<ul>
<li>打印认证信息</li>
</ul>
</li>
<li>注意点<ul>
<li>name的方式进行查找</li>
<li>要写ng-model</li>
</ul>
</li>
</ul>
<h1 id="2016年3月21日"><a href="#2016年3月21日" class="headerlink" title="2016年3月21日"></a>2016年3月21日</h1><h2 id="angularjs-5"><a href="#angularjs-5" class="headerlink" title="angularjs"></a>angularjs</h2><p><strong>npm操作使用教程</strong></p>
<pre><code>cd xxx  //访问某个文件夹

npm install angular//安装angularjs文件包

npm uninstall angular //删除angularjs文件包

使用npm help &lt;command&gt;可查看某条命令的详细帮助，例如npm help install。

输入 &quot;npm -v&quot; 来测试是否成功安装

npm install &lt;Module Name&gt;//使用 npm 命令安装模块

npm install express          # 本地安装
npm install express -g   # 全局安装

npm ls -g//使用以下命令来查看所有全局安装的模块
</code></pre><ul>
<li><p><strong>本地安装</strong></p>
<ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
</li>
<li><p><strong>全局安装</strong></p>
<ol>
<li><p>将安装包放在 /usr/local 下。</p>
</li>
<li><p>可以直接在命令行里使用。</p>
</li>
<li><p>不能通过 require() 来引入本地安装的包。<br>接下来我们使用全局方式安装 express</p>
</li>
</ol>
</li>
</ul>
<h1 id="2016年3月22日"><a href="#2016年3月22日" class="headerlink" title="2016年3月22日"></a>2016年3月22日</h1><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><strong>反向代理</strong></p>
<p>我们有时候，用自己的计算机A想访问国外的某个网站B，但是访问不了，此时，有一台中间服务器C可以访问国外的网站B，那么，我们可以用自己的电脑访问服务器C，通过C来访问B这个网站。那么这个时候，服务器C称为代理服务器，这种访问方式叫做正向代理。正向代理有一个特点，就是我们明确知道要访问哪个网站。再如，当我们有一个服务器集中，并且服务器集群中的每台服务器的内容一样的时候，同样我们要直接从个人电脑访问到服务器集中的服务器的时候无法访问，且此时第三方服务器能访问集群，这个时候，我们通过第三方服务器访问服务器集群的内容，但是此时我们并不知道是哪一台服务器提供的内容，此时的代理方式称为反向代理。</p>
<p><strong>负载均衡</strong></p>
<p>当一台服务器的单位时间内的访问量越大的时候，服务器的压力会越大。当一台服务器压力大得超过自身的承受能力的时候，服务器会崩溃。为了避免服务器崩溃，让用户有更好地体验，我们通常通过负载均衡的方式来分担服务器的压力。那么什么是负载均衡呢？是这样，我们可以建立很多很多个服务器，这些服务器组成一个服务器集群，然后，当用户访问我们网站的时候，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该选择的服务器。这样，用户的每次访问，都会保证服务器集群中的每个服务器的压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。</p>
<h1 id="2016年3月23日"><a href="#2016年3月23日" class="headerlink" title="2016年3月23日"></a>2016年3月23日</h1><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="margin属性"><a href="#margin属性" class="headerlink" title="margin属性"></a>margin属性</h3><ul>
<li>垂直外边距合并</li>
</ul>
<p>简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
<p><strong>请注意</strong>，如果不设置 div 的内上边距(<strong>padding-top</strong>)或上边框(<strong>border-top</strong>)，那么内部 div 的上外边距将与外部 div 的上外边距合并（叠加）。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_1.gif" alt></p>
<p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上或下外边距也会发生合并。</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_2.gif" alt></p>
<p>假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_3.gif" alt></p>
<p>如果这个外边距遇到另一个元素的外边距，它还会发生合并:</p>
<p><img src="C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_4.gif" alt></p>
<blockquote>
<p>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。<br><a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/css/css_margin_collapsing.asp</a></p>
</blockquote>
<h3 id="html与body"><a href="#html与body" class="headerlink" title="html与body"></a>html与body</h3><p>宽高的百分比是基于包含它的块级对象的百分比宽高。<br>父元素没高度，子元素100%的父元素高度也是0</p>
<p>当body里只有一个relative元素的时候，只有同时设置html和body的100%高度才能使这个元素的宽高填充。</p>
<p>一旦设置了html标签height:100%;则无论哪个浏览器下body都支持height:100%;了，而body内部的容器也可以支持height:100%;了。</p>
<h3 id="angularjs-6"><a href="#angularjs-6" class="headerlink" title="angularjs"></a>angularjs</h3><ul>
<li>ng-app 指令初始化一个 AngularJS 应用程序。<ul>
<li>ng-app 指令告诉 AngularJS，哪个元素是 AngularJS 应用程序 的”所有者”，也是angularjs程序的开始。</li>
</ul>
</li>
<li>ng-model 指令读取元素的值（比如输入域的值），然后绑定到应用程序。<ul>
<li>ng-model 指令把输入域的值绑定到应用程序变量 name。</li>
</ul>
</li>
<li>ng-bind 指令把应用程序数据绑定到 HTML 视图。<ul>
<li>ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</li>
</ul>
</li>
<li>ng-init 指令初始化 AngularJS 应用程序变量。</li>
<li>AngularJS 属性以<strong>ng-</strong> 开头，但是您可以使用<strong>data-ng-</strong> 来让网页对 HTML5有效。</li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;&quot;&gt;
    &lt;!-- ng-model指令读取用户输入信息，然后传递给变量name --&gt;
    &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;
    &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
&lt;/div&gt;


&lt;div ng-app=&quot;&quot; ng-init=&quot;firstName=&#39;John&#39;&quot;&gt;
    &lt;!-- ng-bind指令是控制标签的innerHTMl，内容为参数值。 --&gt;
    &lt;p&gt;姓名为 &lt;span ng-bind=&quot;firstName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;姓名为 &lt;span data-ng-bind=&quot;firstName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;姓名为 &lt;span&gt;{{name}}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre>
<pre><code class="html">&lt;!-- ng-app定义了一个angularjs应用，在哪个标签插入，应用就在哪开始。 --&gt;
&lt;!-- ng-controller确定了使用模块下哪个控制器 --&gt;
&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;


名: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt;
姓: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt;
&lt;br&gt;
姓名: {{firstName + " " + lastName}}

&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);//定义一个模块，
app.controller(&#39;myCtrl&#39;, function($scope) {//调用模块的方法
    $scope.firstName= &quot;John&quot;;
    $scope.lastName= &quot;Doe&quot;;
});
&lt;/script&gt;</code></pre>
<p><strong>自定义的指令</strong></p>
<p>使用驼峰法来命名一个指令，<strong>runoobDirective</strong> , 但在使用它时需要以 - 分割, <strong>runoob-directive</strong>。</p>
<p>调用方式：</p>
<ul>
<li>元素名</li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot;&gt;
    元素名：&lt;hi-boy&gt;&lt;/hi-boy&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var app=angular.module(&#39;myApp&#39;,[]);
        app.directive(&quot;hiBoy&quot;,function(){
            return {
                template:&quot;&lt;span&gt;hello boy &lt;/span&gt;&quot;
            };
        });
    &lt;/script&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>属性 </li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot;&gt;
    属性：&lt;div hi-boy&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var app=angular.module(&#39;myApp&#39;,[]);
        app.directive(&quot;hiBoy&quot;,function(){
            return {
                replace:true,
                restrict:&#39;M&#39;,
                template:&quot;&lt;span&gt;hello boy &lt;/span&gt;&quot;
            };
        });
    &lt;/script&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>类名</li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot;&gt;
    属性：&lt;div class=&quot;hi-boy&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var app=angular.module(&#39;myApp&#39;,[]);
        app.directive(&quot;hiBoy&quot;,function(){
            return {
                // 必须设置 restrict 的值为 &quot;C&quot; 才能通过类名来调用指令。
                restrict:&#39;C&#39;,
                template:&quot;&lt;span&gt;hello boy &lt;/span&gt;&quot;
            };
        });
    &lt;/script&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>注释</li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot;&gt;
    注释：&lt;!-- directive:hi-boy --&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var app=angular.module(&#39;myApp&#39;,[]);
        app.directive(&quot;hiBoy&quot;,function(){
            return {
                replace:true,//需要在该实例添加 replace 属性， 否则评论是不可见的。
                restrict:&#39;M&#39;,//须设置 restrict 的值为 &quot;M&quot; 才能通过注释来调用指令。
                template:&quot;&lt;span&gt;hello boy &lt;/span&gt;&quot;
            };
        });
    &lt;/script&gt;
&lt;/div&gt;</code></pre>
<p>restrict 值可以是以下几种:</p>
<ul>
<li>E 只限元素名使用</li>
<li>A 只限属性使用</li>
<li>C 只限类名使用</li>
<li>M 只限注释使用</li>
</ul>
<p>restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。</p>
<h1 id="2016年3月24日"><a href="#2016年3月24日" class="headerlink" title="2016年3月24日"></a>2016年3月24日</h1><h2 id="angularjs-7"><a href="#angularjs-7" class="headerlink" title="angularjs"></a>angularjs</h2><ul>
<li>ng-model 指令</li>
</ul>
<p>ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。</p>
<pre><code class="html">&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot;&gt;
    Email:
    &lt;input type=&quot;email&quot; name=&quot;myAddress&quot; ng-model=&quot;text&quot;&gt;
    &lt;span ng-show=&quot;myForm.myAddress.$error.email&quot;&gt;不是一个合法的邮箱地址&lt;/span&gt;
&lt;/form&gt;</code></pre>
<blockquote>
<p>提示信息会在 ng-show 属性返回 true 的情况下显示。</p>
</blockquote>
<p><strong>应用状态</strong><br>ng-model 指令可以为应用数据提供状态值(<strong>invalid</strong>, <strong>dirty</strong>, <strong>touched</strong>, <strong>error</strong>):</p>
<pre><code class="html">&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot; ng-init=&quot;myText = &#39;test@runoob.com&#39;&quot;&gt;

Email:
&lt;input type=&quot;email&quot; name=&quot;myAddress&quot; ng-model=&quot;myText&quot; required&gt;
&lt;p&gt;编辑邮箱地址，查看状态的改变。&lt;/p&gt;
&lt;h1&gt;状态&lt;/h1&gt;
&lt;p&gt;Valid: {{myForm.myAddress.$valid}} (如果输入的值是合法的则为 true)。&lt;/p&gt;
&lt;p&gt;Dirty: {{myForm.myAddress.$dirty}} (如果值改变则为 true)。&lt;/p&gt;
&lt;p&gt;Touched: {{myForm.myAddress.$touched}} (如果通过触屏点击则为 true)。&lt;/p&gt;

&lt;/form&gt;</code></pre>
<p><strong>CSS 类</strong></p>
<p>ng-model 指令基于它们的状态为 HTML 元素提供了 CSS 类：</p>
<pre><code class="html">&lt;style&gt;
input.ng-invalid {
    background-color: lightblue;
}
&lt;/style&gt;
&lt;body&gt;

&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot;&gt;
    输入你的名字:
    &lt;input name=&quot;myAddress&quot; ng-model=&quot;text&quot; required&gt;
&lt;/form&gt;</code></pre>
<p>ng-model 指令根据表单域的状态添加/移除以下类：</p>
<ul>
<li>ng-empty<ul>
<li>值为空</li>
</ul>
</li>
<li>ng-not-empty<ul>
<li>值不为空</li>
</ul>
</li>
<li>ng-touched<ul>
<li>控件已失去焦点</li>
</ul>
</li>
<li>ng-untouched<ul>
<li>控件未失去焦点</li>
</ul>
</li>
<li>ng-valid<ul>
<li>有效值</li>
</ul>
</li>
<li>ng-invalid<ul>
<li>无效值</li>
</ul>
</li>
<li>ng-dirty<ul>
<li>值改变</li>
</ul>
</li>
<li>ng-pending<ul>
<li>任何为满足$asyncValidators的情况</li>
</ul>
</li>
<li>ng-pristine<ul>
<li>控件为初始状态</li>
</ul>
</li>
</ul>
<p><strong>AngularJS 应用组成</strong></p>
<ul>
<li>View(视图), 即 HTML。</li>
<li>Model(模型), 当前视图中可用的数据。</li>
<li>Controller(控制器), 即 JavaScript 函数，可以添加或修改属性。</li>
</ul>
<p><strong>过滤器</strong></p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currency</td>
<td>格式化数字为货币格式。</td>
</tr>
<tr>
<td>filter</td>
<td>从数组项中选择一个子集。</td>
</tr>
<tr>
<td>lowercase</td>
<td>格式化字符串为小写。</td>
</tr>
<tr>
<td>orderBy</td>
<td>根据某个表达式排列数组。</td>
</tr>
<tr>
<td>uppercase</td>
<td>格式化字符串为大写。</td>
</tr>
</tbody></table>
<p>过滤器可以通过一个管道字符（|）和一个过滤器添加到表达式中。.</p>
<p><strong>uppercase</strong>过滤器将字符串格式化为大写：</p>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;personCtrl&quot;&gt;

&lt;p&gt;姓名为 {{ lastName | uppercase }}&lt;/p&gt;

&lt;/div&gt;
</code></pre>
<p><strong>过滤输入</strong></p>
<p>输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。<br><strong>filter</strong> 过滤器从数组中选择一个子集：</p>
<pre><code class="html5">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;namesCtrl&quot;&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; ng-model=&quot;test&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li ng-repeat=&quot;x in names | filter:test | orderBy:&#39;country&#39;&quot;&gt;
    {{ (x.name | uppercase) + ', ' + x.country }}
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
</code></pre>
<h1 id="2016年3月25日"><a href="#2016年3月25日" class="headerlink" title="2016年3月25日"></a>2016年3月25日</h1><h2 id="angularjs-8"><a href="#angularjs-8" class="headerlink" title="angularjs"></a>angularjs</h2><p><strong>AngularJS 服务(Service)</strong></p>
<p>在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。</p>
<ul>
<li>$location 服务，它可以返回当前页面的 URL 地址。</li>
</ul>
<pre><code class="js">var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;customersCtrl&#39;, function($scope, $location) {
    $scope.myUrl = $location.absUrl();
});</code></pre>
<ul>
<li>$http 是 AngularJS 应用中最常用的服务。服务向服务器发送请求，应用响应服务器传送过来的数据。</li>
</ul>
<pre><code class="js">var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;myCtrl&#39;, function($scope, $http) {
    $http.get(&quot;welcome.htm&quot;).then(function (response) {
        $scope.myWelcome = response.data;
    });
});</code></pre>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p><strong>无内容元素（Void elements）</strong></p>
<p>无内容元素是一种不能包含任何内容的特殊元素。而其他元素，比如 <div>，则既可以不包含任何内容，又可以包含另一个元素或者文字。</div></p>
<p>比较常见的无内容元素有：</p>
<ul>
<li>&lt; br&gt;</li>
<li>&lt; hr&gt;</li>
<li>&lt; img&gt;</li>
<li>&lt; input&gt;</li>
<li>&lt; link&gt; </li>
<li>&lt; meta&gt;</li>
</ul>
<p>不太常见的无内容元素有：</p>
<ul>
<li>&lt; area&gt;</li>
<li>&lt; base&gt;</li>
<li>&lt; col&gt;</li>
<li>&lt; command&gt;</li>
<li>&lt; embed&gt;</li>
<li>&lt; keygen&gt;</li>
<li>&lt; param&gt;</li>
<li>&lt; source&gt;</li>
<li>&lt; track&gt;</li>
<li>&lt; wbr&gt;</li>
</ul>
<p>此类标签应由下列部分组成，顺序须与下表保持一致：</p>
<ul>
<li>一个 “&lt;” 字符。</li>
<li>标签名。</li>
<li>此项可选，一个或多个属性，每一个属性的前面必须有一个或多个空格。</li>
<li>此项可选，一个或多个空格。</li>
<li>此项可选，一个 “/” 字符，此项只能在无内容元素中出现。</li>
<li>一个 “&gt;” 字符。</li>
</ul>
<p>倒数第二部分的 “/” 字符是可选的，而且没有任何实际含义。所以 &lt; br&gt; 和 &lt; br /&gt; 其实没有实质区别。</p>
<blockquote>
<p><a href="http://blog.jobbole.com/61514/" target="_blank" rel="noopener">http://blog.jobbole.com/61514/</a></p>
</blockquote>
<p><strong>AngularJS Select(选择框)</strong></p>
<p>使用 ng-option 指令来创建一个下拉列表，列表项通过对象和数组循环输出</p>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;

&lt;select ng-model=&quot;selectedName&quot; ng-options=&quot;x for x in names&quot;&gt;
&lt;/select&gt;

&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;myCtrl&#39;, function($scope) {
    $scope.names = [&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;];
});
&lt;/script&gt;</code></pre>
<p>也可以使用ng-repeat 指令：</p>
<pre><code class="html">&lt;select&gt;
&lt;option ng-repeat=&quot;x in names&quot; value=&quot;{{x.names}}&quot;&gt;{{x}}&lt;/option&gt;
&lt;/select&gt; </code></pre>
<blockquote>
<p>option标签的value值是发给服务器的值。</p>
</blockquote>
<p><strong>ng-repeat</strong>指令是通过数组来循环 HTML 代码来创建下拉列表，但 <strong>ng-options</strong> 指令更适合创建下拉列表，它有以下优势：<br>使用 <strong>ng-options</strong> 的选项的一个对象， <strong>ng-repeat</strong> 是一个字符串。</p>
<h1 id="2016年3月28日"><a href="#2016年3月28日" class="headerlink" title="2016年3月28日"></a>2016年3月28日</h1><h2 id="angularjs-9"><a href="#angularjs-9" class="headerlink" title="angularjs"></a>angularjs</h2><p>使用 angular 显示表格</p>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;customersCtrl&quot;&gt; 

&lt;table&gt;
  &lt;tr ng-repeat=&quot;x in names&quot;&gt;
    &lt;td&gt;{{ x.Name }}&lt;/td&gt;
    &lt;td&gt;{{ x.Country }}&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;/div&gt;
&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;customersCtrl&#39;, function($scope, $http) {
    $http.get(&quot;http://www.runoob.com/try/angularjs/data/Customers_JSON.php&quot;)
    .success(function (response) {$scope.names = response.records;});
});
&lt;/script&gt;</code></pre>
<p>可以使用 orderBy 过滤器: </p>
<pre><code class="html">&lt;table&gt;
  &lt;tr ng-repeat=&quot;x in names | orderBy : &#39;Country&#39;&quot;&gt;
    &lt;td&gt;{{ x.Name }}&lt;/td&gt;
    &lt;td&gt;{{ x.Country }}&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<p>可以在 &lt; td&gt; 中添加 $index: </p>
<pre><code class="html">&lt;table&gt;
  &lt;tr ng-repeat=&quot;x in names&quot;&gt;
    &lt;td&gt;{{ $index + 1 }}&lt;/td&gt;
    &lt;td&gt;{{ x.Name }}&lt;/td&gt;
    &lt;td&gt;{{ x.Country }}&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<p>使用 $even 和 $odd</p>
<pre><code class="html">&lt;table&gt;
&lt;tr ng-repeat=&quot;x in names&quot;&gt;
&lt;td ng-if=&quot;$odd&quot; style=&quot;background-color:#f1f1f1&quot;&gt;{{ x.Name }}&lt;/td&gt;
&lt;td ng-if=&quot;$even&quot;&gt;{{ x.Name }}&lt;/td&gt;
&lt;td ng-if=&quot;$odd&quot; style=&quot;background-color:#f1f1f1&quot;&gt;{{ x.Country }}&lt;/td&gt;
&lt;td ng-if=&quot;$even&quot;&gt;{{ x.Country }}&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</code></pre>
<p><strong>跨域 HTTP 请求</strong></p>
<p>指定某域名<code>（http://client.runoob.com）</code>跨域访问，则只需在<code>http://server.runoob.com/server.php</code>文件头部添加如下代码：</p>
<pre><code class="php">header(&#39;Access-Control-Allow-Origin:http://client.runoob.com&#39;);</code></pre>
<blockquote>
<p>参考：<a href="http://www.runoob.com/w3cnote/php-ajax-cross-border.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/php-ajax-cross-border.html</a> 。</p>
</blockquote>
<p><strong>ng-disabled</strong> 指令绑定应用程序数据 <strong>mySwitch</strong> 到 HTML 的 disabled 属性。<br><strong>ng-model</strong> 指令绑定 <strong>mySwitch</strong> 到 HTML input checkbox 元素的内容（value）。</p>
<p><strong>AngularJS 事件</strong></p>
<ul>
<li>ng-click 指令定义了 AngularJS 点击事件。</li>
<li>ng-hide 指令用于设置应用部分是否可见。</li>
<li>ng-hide=”true” 设置 HTML 元素不可见。</li>
<li>ng-hide=”false” 设置 HTML 元素可见。</li>
</ul>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;personCtrl&quot;&gt;

&lt;button ng-click=&quot;toggle()&quot;&gt;&gt;隐藏/显示&lt;/button&gt;

&lt;p ng-hide=&quot;myVar&quot;&gt;
名: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt;
姓名: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt;
&lt;br&gt;
Full Name: {{firstName + " " + lastName}}
&lt;/p&gt;

&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;personCtrl&#39;, function($scope) {
    $scope.firstName = &quot;John&quot;,
    $scope.lastName = &quot;Doe&quot;
    $scope.myVar = false;
    $scope.toggle = function() {
        $scope.myVar = !$scope.myVar;
    };
});
&lt;/script&gt;</code></pre>
<p><strong>类似</strong></p>
<ul>
<li>ng-show 指令可用于设置应用中的一部分是否可见 。</li>
<li>ng-show=”false” 可以设置 HTML 元素 不可见。</li>
<li>ng-show=”true” 可以以设置 HTML 元素可见。</li>
</ul>
<p>[TOC]</p>
<h1 id="2016年3月29日"><a href="#2016年3月29日" class="headerlink" title="2016年3月29日"></a>2016年3月29日</h1><h2 id="angularjs-10"><a href="#angularjs-10" class="headerlink" title="angularjs"></a>angularjs</h2><p><strong>AngularJS 模块</strong></p>
<ul>
<li>创建模块</li>
</ul>
<p>你可以通过 AngularJS 的 angular.module 函数来创建模块： </p>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot;&gt;...&lt;/div&gt;

&lt;script&gt;

var app = angular.module(&quot;myApp&quot;, []); 

&lt;/script&gt;</code></pre>
<p><strong>myApp</strong>参数对应执行应用的 HTML 元素。<br>现在你可以在 AngularJS 应用中添加控制器、指令、过滤器等。</p>
<ul>
<li>添加控制器</li>
</ul>
<p>你可以使用 ng-controller 指令来添加<strong>应用</strong>的控制器: </p>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;
{{ firstName + " " + lastName }}
&lt;/div&gt;

&lt;script&gt;

var app = angular.module(&quot;myApp&quot;, []);//应用模块的定义程序

app.controller(&quot;myCtrl&quot;, function($scope) {//控制器
    $scope.firstName = &quot;John&quot;;
    $scope.lastName = &quot;Doe&quot;;
});

&lt;/script&gt;</code></pre>
<p><strong>AngularJS 表单</strong></p>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;formCtrl&quot;&gt;
  &lt;form novalidate&gt;
    First Name:&lt;br&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;user.firstName&quot;&gt;&lt;br&gt;
    Last Name:&lt;br&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;user.lastName&quot;&gt;
    &lt;br&gt;&lt;br&gt;
    &lt;button ng-click=&quot;reset()&quot;&gt;RESET&lt;/button&gt;
  &lt;/form&gt;
  &lt;p&gt;form = {{user}}&lt;/p&gt;
  &lt;p&gt;master = {{master}}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;formCtrl&#39;, function($scope) {
    $scope.master = {firstName: &quot;John&quot;, lastName: &quot;Doe&quot;};
    $scope.reset = function() {
        $scope.user = angular.copy($scope.master);
    };
    $scope.reset();
});
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>novalidate</strong> 属性是在 HTML5 中新增的。禁用了使用浏览器的默认验证。</p>
</blockquote>
<ul>
<li>ng-app 指令定义了 AngularJS 应用。</li>
<li>ng-controller 指令定义了应用控制器。</li>
<li>ng-model 指令绑定了两个 input 元素到模型的 user 对象。</li>
<li>formCtrl 函数设置了 master 对象的初始值，并定义了 reset() 方法。</li>
<li>reset() 方法设置了 user 对象等于 master 对象。</li>
<li>ng-click 指令调用了 reset() 方法，且在点击按钮时调用。</li>
<li>novalidate 属性在应用中不是必须的，但是你需要在 AngularJS表单中使用，用于重写标准的 HTML5 验证</li>
</ul>
<p><strong>AngularJS API</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>angular.lowercase()</td>
<td>转换字符串为小写</td>
</tr>
<tr>
<td>angular.uppercase()</td>
<td>转换字符串为大写</td>
</tr>
<tr>
<td>angular.isString()</td>
<td>判断给定的对象是否为字符串，如果是返回 true。</td>
</tr>
<tr>
<td>angular.isNumber()</td>
<td>判断给定的对象是否为数字，如果是返回 true。</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;
&lt;p&gt;{{ x1 }}&lt;/p&gt;
&lt;p&gt;{{ x2 }}&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;myCtrl&#39;, function($scope) {
$scope.x1 = &quot;JOHN&quot;;
$scope.x2 = angular.lowercase($scope.x1);
});
&lt;/script&gt;</code></pre>
<p><strong>AngularJS Bootstrap</strong></p>
<table>
<thead>
<tr>
<th>AngularJS 指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; html ng-app</td>
<td>为 &lt; html&gt; 元素定义一个应用(未命名)</td>
</tr>
<tr>
<td>&lt; body ng-controller</td>
<td>为 &lt; body&gt; 元素定义一个控制器</td>
</tr>
<tr>
<td>&lt; tr ng-repeat</td>
<td>循环 users 对象数组，每个 user 对象放在 &lt; tr&gt; 元素中。</td>
</tr>
<tr>
<td>&lt; button ng-click</td>
<td>当点击 &lt; button&gt; 元素时调用函数 editUser()</td>
</tr>
<tr>
<td>&lt; h3 ng-show</td>
<td>如果 edit = true 显示 &lt; h3&gt; 元素</td>
</tr>
<tr>
<td>&lt; h3 ng-hide</td>
<td>如果 edit = true 隐藏 &lt; h3&gt; 元素</td>
</tr>
<tr>
<td>&lt; input ng-model</td>
<td>为应用程序绑定 &lt; input&gt; 元素</td>
</tr>
<tr>
<td>&lt; button ng-disabled</td>
<td>如果发生错误或者 ncomplete = true 禁用 &lt; button&gt; 元素</td>
</tr>
</tbody></table>
<p><strong>AngularJS 包含</strong></p>
<p>在 AngularJS 中，你可以在 HTML 中包含 HTML 文件。</p>
<p>使用 AngularJS, 你可以使用 ng-include 指令来包含 HTML 内容:</p>
<pre><code class="html">&lt;body&gt;

&lt;div class=&quot;container&quot;&gt;
  &lt;div ng-include=&quot;&#39;myUsers_List.htm&#39;&quot;&gt;&lt;/div&gt;
  &lt;div ng-include=&quot;&#39;myUsers_Form.htm&#39;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;</code></pre>
<p><strong>AngularJS 动画</strong></p>
<p>AngularJS 提供了动画效果，可以配合 CSS 使用。<br>AngularJS 使用动画需要引入 angular-animate.min.js 库。</p>
<pre><code class="html">&lt;body ng-app=&quot;myApp&quot;&gt;

&lt;h1&gt;隐藏 DIV: &lt;input type=&quot;checkbox&quot; ng-model=&quot;myCheck&quot;&gt;&lt;/h1&gt;

&lt;div ng-hide=&quot;myCheck&quot;&gt;&lt;/div&gt;

&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, [&#39;ngAnimate&#39;]);
&lt;/script&gt;</code></pre>
<p>ngAnimate 模型可以添加或移除 class 。<br>ngAnimate 模型并不能使 HTML 元素产生动画，但是 ngAnimate 会监测事件，类似隐藏显示 HTML 元素 ，如果事件发生 ngAnimate 就会使用预定义的 class 来设置 HTML 元素的动画。</p>
<p>AngularJS 添加/移除 class 的指令:</p>
<ul>
<li>ng-show</li>
<li>ng-hide</li>
<li>ng-class</li>
<li>ng-view</li>
<li>ng-include</li>
<li>ng-repeat</li>
<li>ng-if</li>
<li>ng-switch</li>
</ul>
<p>此外，在动画完成后，HTML 元素的类集合将被移除。例如： ng-hide 指令会添加一下类：</p>
<ul>
<li>ng-animate</li>
<li>ng-hide-animate</li>
<li>ng-hide-add (如果元素将被隐藏)</li>
<li>ng-hide-remove (如果元素将显示)</li>
<li>ng-hide-add-active (如果元素将隐藏)</li>
<li>ng-hide-remove-active (如果元素将显示)</li>
</ul>
<p>[TOC]</p>
<h1 id="2016年3月30日"><a href="#2016年3月30日" class="headerlink" title="2016年3月30日"></a>2016年3月30日</h1><h2 id="转义字符-1"><a href="#转义字符-1" class="headerlink" title="转义字符"></a>转义字符</h2><p>字符型常量所表示的值是字符型变量所能包含的值。<br>我们可以用<strong>ASCII表达式</strong>来表示一个字符型常量，或者用<strong>单引号</strong>内加<strong>反斜杠</strong>表示转义字符。</p>
<blockquote>
<p>其中：\x表示后面的字符是十六进制数，\表示后面的字符是八进制数。</p>
</blockquote>
<p><code>&amp;#x50;</code>(&#x50;):用十六进制的方式表示编码为<strong>50</strong>的字符。<br><code>&amp;#50;</code>(&#50;):用十进制的方式表示编码为<strong>50</strong>的字符。<br><code>\045</code>:在javascript中可解释成八进制的ASCII 码&quot;<strong>%</strong>&quot;。<br><code>\x24</code>:在javascript中可以解释成十六进制的ASCII码&quot;<strong>$</strong>&quot;</p>
<p>在CSS中表示ASCII码：</p>
<pre><code class="css">#t1:after{
        content: &quot;\45\0a\55\045&quot;
    }</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">190</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
