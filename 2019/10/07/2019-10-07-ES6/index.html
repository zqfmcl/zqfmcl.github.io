<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Javascript,">





  <link rel="alternate" href="/atom.xml" title="Fey's blog" type="application/atom+xml">






<meta name="description" content="个人es6总结，大多是看阮老师的博客，总结了自己认为重要的部分  let &amp;amp; constlet和const注意：只有在{}中才有作用域（if单语句不加{}  不能用let） if(1) let i = 1 Uncaught SyntaxError: Unexpected identifier const表示常量必须在定义的时候赋值，且不能修改，否则报错 重复定义会报错// 报错 func">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6">
<meta property="og:url" content="https://zqfmcl.github.io/dialy/2019/10/07/2019-10-07-ES6/index.html">
<meta property="og:site_name" content="Fey&#39;s blog">
<meta property="og:description" content="个人es6总结，大多是看阮老师的博客，总结了自己认为重要的部分  let &amp;amp; constlet和const注意：只有在{}中才有作用域（if单语句不加{}  不能用let） if(1) let i = 1 Uncaught SyntaxError: Unexpected identifier const表示常量必须在定义的时候赋值，且不能修改，否则报错 重复定义会报错// 报错 func">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-23T07:21:32.859Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6">
<meta name="twitter:description" content="个人es6总结，大多是看阮老师的博客，总结了自己认为重要的部分  let &amp;amp; constlet和const注意：只有在{}中才有作用域（if单语句不加{}  不能用let） if(1) let i = 1 Uncaught SyntaxError: Unexpected identifier const表示常量必须在定义的时候赋值，且不能修改，否则报错 重复定义会报错// 报错 func">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zqfmcl.github.io/dialy/2019/10/07/2019-10-07-ES6/">





  <title>ES6 | Fey's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zqfmcl.github.io/dialy/2019/10/07/2019-10-07-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zqfmcl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fey's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES6</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-07T10:00:00+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>个人es6总结，大多是看阮老师的博客，总结了自己认为重要的部分</p>
</blockquote>
<h2 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h2><p>let和const注意：只有在<code>{}</code>中才有作用域（if单语句不加{}  不能用let）</p>
<pre><code class="javascript">if(1) let i = 1
Uncaught SyntaxError: Unexpected identifier</code></pre>
<p>const表示常量必须在<strong>定义的时候赋值</strong>，且<strong>不能修改</strong>，否则报错</p>
<h3 id="重复定义会报错"><a href="#重复定义会报错" class="headerlink" title="重复定义会报错"></a>重复定义会报错</h3><pre><code class="javascript">// 报错
function () {
  let a = 10;
  var a = 1;
}

function () {
  var a = 10;
  let a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}

function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}</code></pre>
<h3 id="for的特殊性"><a href="#for的特殊性" class="headerlink" title="for的特殊性"></a>for的特殊性</h3><pre><code class="javascript">for (var i = 0; i &lt; 3; i++) {
  setTimeout(function(){console.log(i)},0)
}
//3 3 3 

for (let i = 0; i &lt; 3; i++) {
  setTimeout(function(){console.log(i)},0)
}
//0 1 2 </code></pre>
<p><code>for</code>循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = &#39;abc&#39;;
  console.log(i);
}</code></pre><h3 id="无变量提升"><a href="#无变量提升" class="headerlink" title="无变量提升"></a>无变量提升</h3><p><code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code class="javascript">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;</code></pre>
<h3 id="暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="暂时性死区（temporal dead zone，简称 TDZ）"></a>暂时性死区（temporal dead zone，简称 TDZ）</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre><code class="javascript">var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}

if (true) {
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}</code></pre>
<h3 id="typeof不再绝对安全"><a href="#typeof不再绝对安全" class="headerlink" title="typeof不再绝对安全"></a>typeof不再绝对安全</h3><p>在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。如果一个变量用let申明，但是在typeof之后，typeof<code>运行时就会抛出一个</code>ReferenceError`。</p>
<h3 id="立即执行函数不必要"><a href="#立即执行函数不必要" class="headerlink" title="立即执行函数不必要"></a>立即执行函数不必要</h3><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<pre><code class="javascript">// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}</code></pre>
<h3 id="不属于顶层对象"><a href="#不属于顶层对象" class="headerlink" title="不属于顶层对象"></a>不属于顶层对象</h3><p><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code class="javascript">var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined</code></pre>
<h3 id="const本质"><a href="#const本质" class="headerlink" title="const本质"></a>const本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，<strong>而是变量指向的那个内存地址不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，<strong>至于它指向的数据结构是不是可变的，就完全不能控制了</strong>。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="javascript">const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: &quot;foo&quot; is read-only</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错</code></pre>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="javascript">const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;</code></pre>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="javascript">var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};</code></pre>
<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h2><h2 id="数组型"><a href="#数组型" class="headerlink" title="[]数组型"></a>[]数组型</h2><p>只要<strong>形式一样就能结构成功</strong>，右边多没事，右边少就会有<code>undefined</code></p>
<pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []</code></pre>
<p><code>...</code>表示rest元素数组。</p>
<h3 id="右边可以是字符串"><a href="#右边可以是字符串" class="headerlink" title="右边可以是字符串"></a>右边可以是字符串</h3><p>因为字符串是一个类数组，有length</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;</code></pre>
<h3 id="右边不可遍历，出错"><a href="#右边不可遍历，出错" class="headerlink" title="右边不可遍历，出错"></a>右边不可遍历，出错</h3><p>如果等号的右边不是数组（或者严格地说，<strong>不是可遍历的结构</strong>，参见《Iterator》一章），那么将会报错。</p>
<pre><code class="javascript">// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};</code></pre>
<p>事实上，只要某种数<strong>据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong>Generator是原生具有iterator接口的</p>
<pre><code class="javascript">function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5</code></pre>
<h3 id="解构允许默认值"><a href="#解构允许默认值" class="headerlink" title="解构允许默认值"></a>解构允许默认值</h3><p>ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员<strong>不严格</strong>等于<code>undefined</code>，默认值是不会生效的。(<strong>比如null</strong>)</p>
<pre><code class="javascript">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;

let [x = 1] = [null];
x // null</code></pre>
<h2 id="对象型"><a href="#对象型" class="headerlink" title="{}对象型"></a>{}对象型</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="javascript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined</code></pre>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code class="javascript">var { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;</code></pre>
<p>这实际上说明，对象的解构赋值是下面形式的简写（<strong>前面是模式，后面是真实变量</strong>）</p>
<pre><code class="javascript">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };</code></pre>
<h3 id="不在声明使用需要加括号"><a href="#不在声明使用需要加括号" class="headerlink" title="不在声明使用需要加括号"></a>不在声明使用需要加括号</h3><p>由于<code>{}</code>的二义性，所以在<code>{}</code>开头的特殊语句，需要加上<code>()</code></p>
<pre><code class="javascript">let foo;
({foo} = {foo: 1}); // 成功


let baz;
{bar: baz} = {bar: 1}; //报错</code></pre>
<h3 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h3><p>和数组一样，解构也可以用于嵌套结构的对象。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;</code></pre><p>注意，这时<code>p</code>是<strong>模式</strong>，不是变量，因此不会被赋值。</p>
<h3 id="允许默认值"><a href="#允许默认值" class="headerlink" title="允许默认值"></a>允许默认值</h3><pre><code class="javascript">var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5</code></pre>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<pre><code class="javascript">let {length : len} = &#39;hello&#39;;
len // 5

let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3</code></pre>
<h3 id="数字字符串"><a href="#数字字符串" class="headerlink" title="数字字符串"></a>数字字符串</h3><p>解构赋值时，如果等号右边是数值和布尔值，<strong>则会先转为对象。</strong></p>
<pre><code class="javascript">let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true</code></pre>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code class="javascript">let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError</code></pre>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><p>写法不仅简洁，而且易读，语义非常清晰。</p>
<pre><code class="javascript">let x = 1;
let y = 2;
[x, y] = [y, x];</code></pre>
<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><pre><code class="javascript">// 返回一个数组
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象
function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();</code></pre>
<h3 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h3><p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code class="javascript">// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});</code></pre>
<h3 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h3><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<pre><code class="javascript">let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]</code></pre>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><pre><code class="javascript">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h3 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h3><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="javascript">var map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="javascript">// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...</code></pre>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="unicode字符问题"><a href="#unicode字符问题" class="headerlink" title="unicode字符问题"></a>unicode字符问题</h2><h3 id="增加了四字节unicode表示"><a href="#增加了四字节unicode表示" class="headerlink" title="增加了四字节unicode表示"></a>增加了四字节unicode表示</h3><p>es5有<code>\uxxxx</code>表示unicode，但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。es6加入了<strong>大括号表示</strong></p>
<pre><code class="javascript">&#39;\u{1F680}&#39; === &#39;\uD83D\uDE80&#39;</code></pre>
<h3 id="码点表示"><a href="#码点表示" class="headerlink" title="码点表示"></a>码点表示</h3><p>charPointAt();</p>
<p>String.fromCodePoint();</p>
<p>这些都是基于码点的，可以完整返回四字节Unicode。</p>
<h3 id="for-of遍历"><a href="#for-of遍历" class="headerlink" title="for of遍历"></a>for of遍历</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p>
<pre><code class="javascript">for (let codePoint of &#39;foo&#39;) {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;</code></pre>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<pre><code>var s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true

</code></pre><p>这三个方法都<strong>支持第二个参数，表示开始搜索的位置。</strong></p>
<pre><code>var s = &#39;Hello world!&#39;;

s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false

</code></pre><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<pre><code>&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre><p>参数如果是小数，会被取整。</p>
<pre><code>&#39;na&#39;.repeat(2.9) // &quot;nana&quot;

</code></pre><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<pre><code>&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError

</code></pre><p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。</p>
<pre><code>&#39;na&#39;.repeat(-0.9) // &quot;&quot;

</code></pre><p>参数<code>NaN</code>等同于0。</p>
<pre><code>&#39;na&#39;.repeat(NaN) // &quot;&quot;

</code></pre><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<pre><code>&#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot;
&#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot;
</code></pre><h3 id="padStart和padEnd（ES2017）"><a href="#padStart和padEnd（ES2017）" class="headerlink" title="padStart和padEnd（ES2017）"></a>padStart和padEnd（ES2017）</h3><p>ES2017 引入了字符串补全长度的功能（chrome可以使用了，node v6.3.1没实现该api）</p>
<p>如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre><p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>如果补串超长，自动截去超过部分  </li>
<li>如果原字符串长度&gt;=最小长度，则返回原字符串</li>
<li>如果忽略第二参数，默认用空格补</li>
</ol>
<pre><code class="javascript">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)  // &#39;0123456abc&#39;
&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;
&#39;x&#39;.padStart(4) // &#39;   x&#39;</code></pre>
<p><code>padStart</code>的常见用途是为数值补全指定位数。另一个用途是提示字符串格式。</p>
<pre><code class="javascript">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;</code></pre>
<h2 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h2><p>我觉得es6在字符串里引入的最大的变化就是模板字符串，通过`` 表示，模板字符串有几大特性：</p>
<h3 id="可以换行"><a href="#可以换行" class="headerlink" title="可以换行"></a>可以换行</h3><pre><code class="javascript">$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());</code></pre>
<h3 id="可以嵌入js变量"><a href="#可以嵌入js变量" class="headerlink" title="可以嵌入js变量"></a>可以嵌入js变量</h3><p>通过<code>${}</code>可以嵌入js对象，允许使用运算符，可以使用函数（返回值）</p>
<pre><code class="javascript">  //传统写法
&#39;User &#39;
      + user.name
      + &#39; is not authorized to do &#39;
      + action
      + &#39;.&#39;

//ES6写法
`User ${user.name} is not authorized to do ${action}.`);


function fn() {
  return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar

function fn2() {}
`test ${fn2()}`
// test undefined
`${fn2}`
// function fn2() {}


var x = 1;
var y = 2;

`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;

`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;</code></pre>
<p>如果变量没申明，则会报错</p>
<pre><code class="javascript">// 变量place没有声明
var msg = `Hello, ${place}`;
// 报错</code></pre>
<h3 id="需要转义"><a href="#需要转义" class="headerlink" title="需要转义"></a>需要转义</h3><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code class="javascript">var greeting = `\`Yo\` World!`;</code></pre>
<h3 id="【高级】模板嵌套"><a href="#【高级】模板嵌套" class="headerlink" title="【高级】模板嵌套"></a>【高级】模板嵌套</h3><p>模板字符串甚至还能嵌套。</p>
<pre><code class="javascript">const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join(&#39;&#39;)}
  &lt;/table&gt;
`;

const data = [
    { first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; },
    { first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; },
];

console.log(tmpl(data));
// &lt;table&gt;
//
//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
//
//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
//
// &lt;/table&gt;</code></pre>
<h3 id="【高级】标签模板"><a href="#【高级】标签模板" class="headerlink" title="【高级】标签模板"></a>【高级】标签模板</h3><p>实际就是将模板跟在函数名后，将会调用函数来执行这个模板</p>
<pre><code class="javascript">var a = 5;
var b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);</code></pre>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中<strong>那些没有变量替换的部分</strong>，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>
<p><code>tag</code>函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p><a href="http://es6.ruanyifeng.com/#docs/string#标签模板" target="_blank" rel="noopener">具体看这里</a></p>
<p>利用标签模板，<strong>理论上可以在javascript里面加载别的语言代码：</strong></p>
<pre><code class="javascript">function java(...){

}

java`
class HelloWorldApp {
  public static void main(String[] args) {
    System.out.println(“Hello World!”); // Display the string.
  }
}
`
HelloWorldApp.main();</code></pre>
<h3 id="String-raw调用标签模板"><a href="#String-raw调用标签模板" class="headerlink" title="String.raw调用标签模板"></a>String.raw调用标签模板</h3><p>单独使用标签模板无法自动把里面的参数转换成字符串，所以ES6原生提供了一个<code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回<strong>一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串</strong>，对应于替换变量后的模板字符串。</p>
<pre><code class="javascript">String.raw`Hi\n${2+3}!`;
// &quot;Hi\\n5!&quot;

String.raw`Hi\u000A!`;
// &#39;Hi\\u000A!&#39;</code></pre>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。</p>
<pre><code class="javascript">String.raw`Hi\\n`
// Hi\\n
//也就是&quot;Hi\n&quot;     //这里\n已经是转义过的，否则会换行，比如看下面的例子

`Hi\n${2+3}!`;
&quot;Hi
5!&quot;</code></pre>
<p>由于它会自动转换斜杠，所以利于用来方便下一步做字符串。</p>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>加入了大量特性都是跟unicode有关的，增加了一个<code>flags</code>属性返回正则的修饰符比如<code>gi</code>，加入了新的粘连（sticky）修饰符<code>y</code>,<code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code class="javascript">var s = &#39;aaa_aa_a&#39;;
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null

var s = &#39;aaa_aa_a&#39;;
var r = /a+_/y;

r.exec(s) // [&quot;aaa_&quot;]
r.exec(s) // [&quot;aa_&quot;]</code></pre>
<p>进一步说，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<pre><code>/b/y.exec(&#39;aba&#39;)
// null

</code></pre><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<pre><code>var r = /hello\d/y;
r.sticky // true
</code></pre><h3 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h3><p>在ES5中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<pre><code class="javascript">var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;);
// 等价于
var regex = /xyz/i;</code></pre>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<pre><code class="javascript">var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;</code></pre>
<p>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。</p>
<pre><code class="javascript">var regex = new RegExp(/xyz/, &#39;i&#39;);
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</code></pre>
<p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<pre><code class="javascript">new RegExp(/abc/ig, &#39;i&#39;).flags
// &quot;i&quot;</code></pre>
<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="八进制和二进制"><a href="#八进制和二进制" class="headerlink" title="八进制和二进制"></a>八进制和二进制</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>
<pre><code class="javascript">0b111110111 === 503 // true
0o767 === 503 // true</code></pre>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<pre><code class="javascript">Number(&#39;0b111&#39;)  // 7
Number(&#39;0o10&#39;)  // 8</code></pre>
<h3 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h3><p>ES6在Number对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法<strong>只对数值有效</strong>，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code></p>
<pre><code class="javascript">isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false</code></pre>
<p>可以这样部署isFinite()，isNaN类似</p>
<pre><code class="javascript">(function (global) {
  var global_isFinite = global.isFinite;

  Object.defineProperty(Number, &#39;isFinite&#39;, {
    value: function isFinite(value) {
      return typeof value === &#39;number&#39; &amp;&amp; global_isFinite(value);
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
})(this);</code></pre>
<h3 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h3><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。这样做的目的，<strong>是逐步减少全局性方法，使得语言逐步模块化。</strong></p>
<pre><code class="javascript">// ES5的写法
parseInt(&#39;12.34&#39;) // 12
parseFloat(&#39;123.45#&#39;) // 123.45

// ES6的写法
Number.parseInt(&#39;12.34&#39;) // 12
Number.parseFloat(&#39;123.45#&#39;) // 123.45

Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true</code></pre>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以<strong>3和3.0被视为同一个值。</strong></p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.0) // true
Number.isInteger(25.1) // false
Number.isInteger(&quot;15&quot;) // false
Number.isInteger(true) // false
</code></pre><p>ES5可以通过下面的代码，部署<code>Number.isInteger()</code>。</p>
<pre><code class="javascript">(function (global) {
   ……
  Object.defineProperty(Number, &#39;isInteger&#39;, {
    value: function isInteger(value) {
      return typeof value === &#39;number&#39; &amp;&amp; isFinite(value) &amp;&amp;
        value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp;
        floor(value) === value;
    },
    ……
  });
})(this);</code></pre>
<h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>
<pre><code class="javascript">Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &#39;0.00000000000000022204&#39;</code></pre>
<p>引入一个这么小的量的目的，<strong>在于为浮点数计算，设置一个误差范围</strong>。我们知道浮点数计算是不精确的。但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>
<h3 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h3><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。上面代码中，超出2的53次方之后，一个数就不精确了。ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<pre><code class="javascript">Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true</code></pre>
<p>上面代码中，可以看到JavaScript能够精确表示的极限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<h2 id="Math扩展"><a href="#Math扩展" class="headerlink" title="Math扩展"></a>Math扩展</h2><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分（原理就是根据正负调用floor和ceil），对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。</p>
<pre><code class="javascript">Math.trunc(4.1) // 4
Math.trunc(-4.1) // -4
Math.trunc(-0.1234) // -0
Math.trunc(&#39;123.456&#39;)// 123
Math.trunc(NaN);      // NaN
Math.trunc(&#39;foo&#39;);    // NaN
Math.trunc();         // NaN</code></pre>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p><code>Math.sign</code>方法用来判断一个数到底是<strong>正数、负数、还是零</strong>。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<h3 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h3><p><code>Math.cbrt</code>方法用于计算一个数的<strong>立方根</strong> Math.pow(Math.abs(x), 1/3)</p>
<h3 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式<strong>有多少个前导0</strong>。<code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representations of a number“（计算32位整数的前导0）的缩写。左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>
<pre><code class="javascript">Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 &lt;&lt; 1) // 30
Math.clz32(1 &lt;&lt; 2) // 29
Math.clz32(1 &lt;&lt; 29) // 2</code></pre>
<h3 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h3><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<pre><code class="javascript">Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755
Math.hypot();            // 0
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, &#39;foo&#39;); // NaN
Math.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755
Math.hypot(-3);          // 3</code></pre>
<h3 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h3><p><strong>（1） Math.expm1()</strong>   == Math.exp(x) - 1;</p>
<p><code>Math.expm1(x)</code>返回ex - 1，即<code>Math.exp(x) - 1</code>。</p>
<p><strong>（2）Math.log1p()</strong>  ==  Math.log(1 + x);</p>
<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>
<p><strong>（3）Math.log10()</strong> == Math.log(x) / Math.LN10;</p>
<p><code>Math.log10(x)</code>返回以10为底的<code>x</code>的对数。如果<code>x</code>小于0，则返回NaN。</p>
<p><strong>（4）Math.log2()</strong> == Math.log(x) / Math.LN2;</p>
<p><code>Math.log2(x)</code>返回以2为底的<code>x</code>的对数。如果<code>x</code>小于0，则返回NaN。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>ES6新增了6个三角函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="！指数运算符"><a href="#！指数运算符" class="headerlink" title="！指数运算符"></a>！指数运算符</h3><p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>
<pre><code class="javascript">2 ** 3 // 8

let a = 1.5;
a **= 2;
// 等同于 a = a * a;</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="! Array.from()"></a>! Array.from()</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>
<pre><code class="javascript">let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。再使用<code>forEach</code>方法。</p>
<pre><code class="javascript">// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).forEach(function (p) {
  console.log(p);
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}</code></pre>
<p>只要是部署了Iterator接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>
<pre><code class="javascript">Array.from(&#39;hello&#39;)
// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]

let namesSet = new Set([&#39;a&#39;, &#39;b&#39;])
Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]</code></pre>
<p>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被<code>Array.from</code>转为真正的数组。</p>
<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。</p>
<pre><code class="javascript">// arguments对象
function foo() {
  var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]</code></pre>
<p><code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<pre><code class="javascript">Array.from({ length: 3 });
// [ undefined, undefined, undefined ]</code></pre>
<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。<code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);
// 等同于
Array.prototype.map.call(arrayLike),x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]

let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)</code></pre>
<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<pre><code class="javascript">Array.from({ length: 2 }, () =&gt; &#39;jack&#39;)
// [&#39;jack&#39;, &#39;jack&#39;]</code></pre>
<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于<code>\uFFFF</code>的Unicode字符，算作两个字符的bug。</p>
<pre><code class="javascript">function countSymbols(string) {
  return Array.from(string).length;
}</code></pre>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1</code></pre>
<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]</code></pre>
<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<pre><code class="javascript">Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]</code></pre>
<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>
<pre><code class="javascript">function ArrayOf(){
  return [].slice.call(arguments);
}</code></pre>
<h3 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h3><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，<strong>使用这个方法，会修改当前数组。</strong></p>
<pre><code class="javascript">Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。<strong>如果为负值，表示倒数。</strong></li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。<strong>如果为负值，表示倒数。</strong></li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]</code></pre>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p>下面是更多例子。</p>
<pre><code class="javascript">// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);</code></pre>
<h3 id="Array-fill"><a href="#Array-fill" class="headerlink" title="Array.fill"></a>Array.fill</h3><p>方法使用给定值，填充一个数组(<strong>初始化数组</strong>)</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]</code></pre>
<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。<code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]</code></pre>
<p>上面代码表示，<code>fill</code>方法从1号位开始，向原数组填充7，到2号位之前结束。</p>
<h3 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h3><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个<strong>遍历器对象</strong>，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<p>注：values在chrome中暂时不可用</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);
}
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;</code></pre>
<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<pre><code class="javascript">let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let entries = letter.entries();
console.log(entries.next().value); // [0, &#39;a&#39;]
console.log(entries.next().value); // [1, &#39;b&#39;]
console.log(entries.next().value); // [2, &#39;c&#39;]</code></pre>
<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于<strong>ES7</strong>，但Babel转码器已经支持。用来替换indexof，它有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对<code>NaN</code>的误判。</p>
<pre><code class="javascript">[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, NaN].includes(NaN); // true

[NaN].indexOf(NaN)// -1</code></pre>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true</code></pre>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<pre><code class="javascript">const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)   //这样还是没办法避免NaN问题，如果需要判断这个还需加强
)();
contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</code></pre>
<p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h3 id="空位置（坑）"><a href="#空位置（坑）" class="headerlink" title="空位置（坑）"></a>空位置（坑）</h3><p>数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<pre><code>Array(3) // [, , ,]

</code></pre><p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<pre><code class="javascript">0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false</code></pre>
<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<pre><code class="javascript">// forEach方法
[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]

// every方法
[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true

// some方法
[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false

// map方法
[,&#39;a&#39;].map(x =&gt; 1) // [,1]

// join方法
[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;

// toString方法
[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;</code></pre>
<p>ES6则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<pre><code class="javascript">Array.from([&#39;a&#39;,,&#39;b&#39;])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre>
<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<pre><code class="javascript">[...[&#39;a&#39;,,&#39;b&#39;]]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre>
<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<pre><code class="javascript">[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]</code></pre>
<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<pre><code class="javascript">new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</code></pre>
<p><code>for...of</code>循环也会遍历空位。</p>
<pre><code class="javascript">let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1</code></pre>
<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<pre><code class="javascript">// entries()
[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,&#39;a&#39;].keys()] // [0,1]

// values()
[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]

// find()
[,&#39;a&#39;].find(x =&gt; true) // undefined

// findIndex()
[,&#39;a&#39;].findIndex(x =&gt; true) // 0</code></pre>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。这种写法的缺点在于，<strong>如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。</strong>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<pre><code class="javascript">function log(x, y) {
  y = y || &#39;World&#39;;
  console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello World           //这里不符合预计

//改成
function log(x, y) {
  if (typeof y === &#39;undefined&#39;) {
     y = &#39;World&#39;;
  }
  console.log(x, y);
}</code></pre>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello</code></pre>
<p>ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>另外，一个容易忽略的地方是，<strong>如果参数默认值是变量，那么参数就不是传值的</strong>，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code class="javascript">let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101</code></pre>
<p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p>
<h3 id="与解构结合用"><a href="#与解构结合用" class="headerlink" title="与解构结合用"></a>与解构结合用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="javascript">function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined, 5
foo(1,2) // undefined, 5    //只要第一个参数不是一个对象就不会赋值
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined</code></pre>
<p>上面的写法不能省略参数，如果结合函数参数的默认值，就可以省略第二个参数。<strong>这时，就出现了双重默认值。</strong></p>
<pre><code class="javascript">function foo({x, y = 5} = {}) {
  console.log(x, y);
}
foo() // undefined, 5</code></pre>
<p><strong>注意：</strong></p>
<p>再请问下面两种写法有什么差别？</p>
<pre><code class="javascript">// 写法一  使用这种
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二  缺点是如果传入了参数，哪怕是空{},初始化就失效
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code class="javascript">// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x有值，y无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]</code></pre>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，<strong>应该是函数的尾参数</strong>。因为这样比较容易看出来，到底省略了哪些参数。<strong>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</strong>除非显式输入<code>undefined</code>。如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<pre><code class="javascript">// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]</code></pre>
<p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。这是因为<code>length</code>属性的含义是，<strong>该函数预期传入的参数个数</strong>。</p>
<pre><code class="javascript">(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<pre><code class="javascript">(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1</code></pre>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，<strong>参数会形成一个单独的作用域（context）</strong>。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="javascript">var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2</code></pre>
<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">let x = 1;
function f(y = x) {   //如果不定义x会报错
  let x = 2;
  console.log(y);
}
f() // 1</code></pre>
<p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p>
<p>面是一个更复杂的例子。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;   //和第一个参数x不一样
  y();   //改变的是第一个参数x
  console.log(x); 
}

foo() // 3
x // 1</code></pre>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;    //和第一个参数x一致
  y();      //改变了第一个参数x
  console.log(x);  //2
}

foo() // 2
x // 1</code></pre>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，<strong>可以指定某一个参数不得省略，如果省略就抛出一个错误。</strong></p>
<pre><code class="javascript">function throwIfMissing() {
  throw new Error(&#39;Missing parameter&#39;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter</code></pre>
<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<pre><code class="javascript">function foo(optional = undefined) { ··· }</code></pre>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入<strong>数组</strong>中。</p>
<pre><code>function add(...values) {
    values //[2,5,3]
}

add(2, 5, 3) // 10
</code></pre><p><strong>由于rest参数本来就是数组，所以它不需要做数组转换就可以用数组的方法</strong>(sort，forEach……)</p>
<pre><code class="javascript">// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code class="javascript">// 报错
function f(a, ...b, c) {
  // ...
}</code></pre>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<pre><code class="javascript">(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1</code></pre>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 <strong>rest 参数的逆运算</strong>，将<strong>一个数组转为用逗号分隔的参数序列</strong>。</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</code></pre>
<p>该运算符主要用于函数调用。</p>
<pre><code class="javascript">function push(array, ...items) {
  array.push(...items);   //把items转换成序列
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers) // 42</code></pre>
<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code class="javascript">function f(v, w, x, y, z) { }
var args = [0, 1];
f(-1, ...args, 2, ...[3]);</code></pre>
<h3 id="！扩展运算符作用"><a href="#！扩展运算符作用" class="headerlink" title="！扩展运算符作用"></a>！扩展运算符作用</h3><ol>
<li><p><strong>替代apply</strong></p>
<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>
</li>
</ol>
<pre><code class="javascript">// 1. 求数组最大值

// ES5的写法
Math.max.apply(null, [14, 3, 77])

// ES6的写法
Math.max(...[14, 3, 77])

// 2. 给Date传参

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);


// 3. 添加数组到尾部

// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);
// ES6的写法
arr1.push(...arr2);

// 4. 合并数组

// ES5
arr1.concat(arr2, arr3);

// ES6
[...arr1, ...arr2, ...arr3]</code></pre>
<ol>
<li>扩展运算符可以与<strong>解构赋值</strong>结合起来，<strong>用于生成数组。</strong>如果将扩展运算符用于数组赋值，<strong>只能放在参数的最后一位</strong>，否则会报错。</li>
</ol>
<pre><code class="javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list

const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错</code></pre>
<ol>
<li><strong>字符串</strong></li>
</ol>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</code></pre>
<p>上面的写法，有一个重要的好处，<strong>那就是能够正确识别32位的Unicode字符。</strong></p>
<pre><code class="javascript">&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3</code></pre>
<p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code class="javascript">function length(str) {
  return [...str].length;
}

length(&#39;x\uD83D\uDE80y&#39;) // 3</code></pre>
<p>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre><code class="javascript">let str = &#39;x\uD83D\uDE80y&#39;;

str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;</code></pre>
<p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确</p>
<ol>
<li><p><strong>转换所有带Iterator接口的对象</strong></p>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
</li>
</ol>
<pre><code class="javascript">let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]</code></pre>
<p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code class="javascript">var go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]</code></pre>
<p>上面代码中，变量<code>go</code>是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有<code>iterator</code>接口的对象，使用扩展运算符，将会报错。</p>
<pre><code class="javascript">var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object</code></pre>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<pre><code class="javascript">function foo() {}
foo.name // &quot;foo&quot;</code></pre>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<pre><code class="javascript">var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;</code></pre>
<p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</p>
<pre><code class="javascript">const bar = function baz() {};

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;</code></pre>
<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<pre><code class="javascript">(new Function).name // &quot;anonymous&quot;</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<pre><code class="javascript">function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>如果没有参数，必须要用一个括号，只有一个参数，不用写括号，返回值不用写return</p>
<pre><code class="javascript">var f = v =&gt; v;
//等于
var f = function(v) {
  return v;
};
var f = () =&gt; 5;
var sum = (num1, num2) =&gt; num1 + num2;</code></pre>
<h3 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h3><p>如果只是返回对象，必须要加一个括号，否则编译器认不出</p>
<pre><code class="javascript">var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });</code></pre>
<h3 id="与解构"><a href="#与解构" class="headerlink" title="与解构"></a>与解构</h3><pre><code class="javascript">const full = ({ first, last }) =&gt; first + &#39; &#39; + last;

// 等同于
function full(person) {
  return person.first + &#39; &#39; + person.last;
}</code></pre>
<h3 id="简化回调"><a href="#简化回调" class="headerlink" title="简化回调"></a>简化回调</h3><pre><code class="javascript">// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);

// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);</code></pre>
<h3 id="与rest结合"><a href="#与rest结合" class="headerlink" title="与rest结合"></a>与rest结合</h3><pre><code class="javascript">const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]</code></pre>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）<strong>不可以当作构造函数</strong>，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，<strong>可以用Rest参数代替</strong>。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数<strong>不能用作Generator函数</strong>。</p>
<p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<pre><code class="javascript">var handler = {
  id: &#39;123456&#39;,

  init: function() {
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);   //如果不用箭头函数那this指向document
  },

  doSomething: function(type) {
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  }
};</code></pre>
<p>所以，箭头函数转成ES5的代码如下。</p>
<pre><code class="javascript">// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;    //这里引用了外面的this

  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}</code></pre>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<pre><code class="javascript">(function() {
  return [
    (() =&gt; this.x).bind({ x: &#39;inner&#39; })()
  ];
}).call({ x: &#39;outer&#39; });
// [&#39;outer&#39;]</code></pre>
<h3 id="arguments-super-target"><a href="#arguments-super-target" class="headerlink" title="arguments,super,target"></a>arguments,super,target</h3><p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>
<pre><code class="javascript">function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;args:&#39;, arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]</code></pre>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><pre><code class="javascript">function f(x){
  return g(x);
}</code></pre>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<pre><code class="javascript">function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}</code></pre>
<p>以下不是尾调用</p>
<pre><code class="javascript">// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;  // ==  var tmp = g(x); return tmp+1;
}

// 情况三
function f(x){
  g(x);    //  g(x);   return undefined;
}</code></pre>
<p><strong>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧</strong>，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<pre><code class="javascript">function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);</code></pre>
<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p>
<pre><code class="javascript">function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}</code></pre>
<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但<strong>对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</strong></p>
<pre><code class="javascript">function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120</code></pre>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<pre><code class="javascript">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120</code></pre>
<p>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p>
<p>如果是非尾递归的fibonacci 递归方法</p>
<pre><code class="javascript">function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10); // 89
// Fibonacci(100)
// Fibonacci(500)
// 堆栈溢出了</code></pre>
<p>如果我们使用尾递归优化过的fibonacci 递归算法</p>
<pre><code class="javascript">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity</code></pre>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。<strong>ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。</strong>这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h3><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<pre><code class="javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)</code></pre>
<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归100000次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<pre><code class="javascript">function trampoline(f) {
  while (f &amp;&amp; f instanceof Function) {
    f = f();
  }
  return f;
}</code></pre>
<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<pre><code class="javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}</code></pre>
<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<pre><code class="javascript">trampoline(sum(1, 100000))
// 100001</code></pre>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<pre><code class="javascript">function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001</code></pre>
<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="属性简洁表达"><a href="#属性简洁表达" class="headerlink" title="属性简洁表达"></a>属性简洁表达</h2><p>ES6允许<strong>直接写入变量和函数，作为对象的属性和方法</strong>。这样的书写更加简洁。</p>
<pre><code class="javascript">var foo = &#39;bar&#39;;
var baz = {foo};
baz // {foo: &quot;bar&quot;}</code></pre>
<p>属性名直接是变量名，属性值是变量值</p>
<pre><code class="javascript">var birth = &#39;2000/01/01&#39;;

var Person = {
  name: &#39;张三&#39;,
  //等同于birth: &#39;2000/01/01&#39;;
  birth,
  // 等同于hello: function ()...
  hello() { console.log(&#39;我的名字是&#39;, this.name); }
};</code></pre>
<p>CommonJS模块输出变量，就非常合适使用简洁写法。</p>
<pre><code class="javascript">var ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};</code></pre>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre><code class="javascript">var obj = {
  class () {}   //class是字符串，所以不会因为它属于关键字，而导致语法解析报错。
};
// 等同于
var obj = {
  &#39;class&#39;: function() {}    
};</code></pre>
<p>如果某个方法的值是一个Generator函数，前面需<strong>要加上星号。</strong></p>
<pre><code class="javascript">var obj = {
  * m(){
    yield &#39;hello world&#39;;
  }
};</code></pre>
<h2 id="字面量中可用"><a href="#字面量中可用" class="headerlink" title="字面量中可用[]"></a>字面量中可用[]</h2><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，<strong>即把表达式放在方括号内</strong>。</p>
<pre><code class="javascript">let propKey = &#39;foo&#39;;

let obj = {
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
};
//Object {foo: true, abc: 123}</code></pre>
<p>表达式还可以用于定义方法名。</p>
<pre><code class="javascript">let obj = {
  [&#39;h&#39; + &#39;ello&#39;]() {
    return &#39;hi&#39;;
  }
};

obj.hello() // hi</code></pre>
<p><strong>注意</strong>，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code class="javascript">// 报错
var foo = &#39;bar&#39;;
var bar = &#39;abc&#39;;
var baz = { [foo] };

// 正确
var foo = &#39;bar&#39;;
var baz = { [foo]: &#39;abc&#39;};
var baz = {foo}</code></pre>
<p><strong>注意</strong>，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<pre><code class="javascript">const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
};

myObject // Object {[object Object]: &quot;valueB&quot;}
//[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</code></pre>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Javascript/" rel="tag"># Javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/06/2019-10-06-Java题解控制/" rel="next" title="Java题解控制">
                <i class="fa fa-chevron-left"></i> Java题解控制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/07/2019-10-07-Leetcode/" rel="prev" title="Leetcode">
                Leetcode <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zqfmcl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">193</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#let-amp-const"><span class="nav-number">1.</span> <span class="nav-text">let &amp; const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重复定义会报错"><span class="nav-number">1.1.</span> <span class="nav-text">重复定义会报错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for的特殊性"><span class="nav-number">1.2.</span> <span class="nav-text">for的特殊性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无变量提升"><span class="nav-number">1.3.</span> <span class="nav-text">无变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#暂时性死区（temporal-dead-zone，简称-TDZ）"><span class="nav-number">1.4.</span> <span class="nav-text">暂时性死区（temporal dead zone，简称 TDZ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof不再绝对安全"><span class="nav-number">1.5.</span> <span class="nav-text">typeof不再绝对安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即执行函数不必要"><span class="nav-number">1.6.</span> <span class="nav-text">立即执行函数不必要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不属于顶层对象"><span class="nav-number">1.7.</span> <span class="nav-text">不属于顶层对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const本质"><span class="nav-number">1.8.</span> <span class="nav-text">const本质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量解构"><span class="nav-number">2.</span> <span class="nav-text">变量解构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组型"><span class="nav-number">3.</span> <span class="nav-text">[]数组型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#右边可以是字符串"><span class="nav-number">3.1.</span> <span class="nav-text">右边可以是字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#右边不可遍历，出错"><span class="nav-number">3.2.</span> <span class="nav-text">右边不可遍历，出错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解构允许默认值"><span class="nav-number">3.3.</span> <span class="nav-text">解构允许默认值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象型"><span class="nav-number">4.</span> <span class="nav-text">{}对象型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不在声明使用需要加括号"><span class="nav-number">4.1.</span> <span class="nav-text">不在声明使用需要加括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套对象"><span class="nav-number">4.2.</span> <span class="nav-text">嵌套对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#允许默认值"><span class="nav-number">4.3.</span> <span class="nav-text">允许默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类数组"><span class="nav-number">4.4.</span> <span class="nav-text">类数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字字符串"><span class="nav-number">4.5.</span> <span class="nav-text">数字字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用途"><span class="nav-number">5.</span> <span class="nav-text">用途</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交换变量"><span class="nav-number">5.1.</span> <span class="nav-text">交换变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从函数返回多个值"><span class="nav-number">5.2.</span> <span class="nav-text">从函数返回多个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数参数的定义"><span class="nav-number">5.3.</span> <span class="nav-text">函数参数的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提取JSON数据"><span class="nav-number">5.4.</span> <span class="nav-text">提取JSON数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数默认值"><span class="nav-number">5.5.</span> <span class="nav-text">参数默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历Map结构"><span class="nav-number">5.6.</span> <span class="nav-text">遍历Map结构</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number"></span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unicode字符问题"><span class="nav-number">1.</span> <span class="nav-text">unicode字符问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增加了四字节unicode表示"><span class="nav-number">1.1.</span> <span class="nav-text">增加了四字节unicode表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#码点表示"><span class="nav-number">1.2.</span> <span class="nav-text">码点表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-of遍历"><span class="nav-number">1.3.</span> <span class="nav-text">for of遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展方法"><span class="nav-number">2.</span> <span class="nav-text">扩展方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#includes-startsWith-endsWith"><span class="nav-number">2.1.</span> <span class="nav-text">includes(), startsWith(), endsWith()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repeat"><span class="nav-number">2.2.</span> <span class="nav-text">repeat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#padStart和padEnd（ES2017）"><span class="nav-number">2.3.</span> <span class="nav-text">padStart和padEnd（ES2017）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版字符串"><span class="nav-number">3.</span> <span class="nav-text">模版字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可以换行"><span class="nav-number">3.1.</span> <span class="nav-text">可以换行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以嵌入js变量"><span class="nav-number">3.2.</span> <span class="nav-text">可以嵌入js变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要转义"><span class="nav-number">3.3.</span> <span class="nav-text">需要转义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【高级】模板嵌套"><span class="nav-number">3.4.</span> <span class="nav-text">【高级】模板嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【高级】标签模板"><span class="nav-number">3.5.</span> <span class="nav-text">【高级】标签模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-raw调用标签模板"><span class="nav-number">3.6.</span> <span class="nav-text">String.raw调用标签模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则"><span class="nav-number">4.</span> <span class="nav-text">正则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp构造函数"><span class="nav-number">4.1.</span> <span class="nav-text">RegExp构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数字"><span class="nav-number">5.</span> <span class="nav-text">数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#八进制和二进制"><span class="nav-number">5.1.</span> <span class="nav-text">八进制和二进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-isFinite-Number-isNaN"><span class="nav-number">5.2.</span> <span class="nav-text">Number.isFinite(), Number.isNaN()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-parseInt-Number-parseFloat"><span class="nav-number">5.3.</span> <span class="nav-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-isInteger"><span class="nav-number">5.4.</span> <span class="nav-text">Number.isInteger()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-EPSILON"><span class="nav-number">5.5.</span> <span class="nav-text">Number.EPSILON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全整数和Number-isSafeInteger"><span class="nav-number">5.6.</span> <span class="nav-text">安全整数和Number.isSafeInteger()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math扩展"><span class="nav-number">6.</span> <span class="nav-text">Math扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-trunc"><span class="nav-number">6.1.</span> <span class="nav-text">Math.trunc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-sign"><span class="nav-number">6.2.</span> <span class="nav-text">Math.sign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-cbrt"><span class="nav-number">6.3.</span> <span class="nav-text">Math.cbrt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-clz32"><span class="nav-number">6.4.</span> <span class="nav-text">Math.clz32()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-hypot"><span class="nav-number">6.5.</span> <span class="nav-text">Math.hypot()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对数方法"><span class="nav-number">6.6.</span> <span class="nav-text">对数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三角函数"><span class="nav-number">6.7.</span> <span class="nav-text">三角函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#！指数运算符"><span class="nav-number">6.8.</span> <span class="nav-text">！指数运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">7.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-from"><span class="nav-number">7.1.</span> <span class="nav-text">! Array.from()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-of"><span class="nav-number">7.2.</span> <span class="nav-text">Array.of()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组实例的copyWithin"><span class="nav-number">7.3.</span> <span class="nav-text">数组实例的copyWithin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-fill"><span class="nav-number">7.4.</span> <span class="nav-text">Array.fill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组实例的entries-，keys-和values"><span class="nav-number">7.5.</span> <span class="nav-text">数组实例的entries()，keys()和values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组实例的includes"><span class="nav-number">7.6.</span> <span class="nav-text">数组实例的includes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空位置（坑）"><span class="nav-number">7.7.</span> <span class="nav-text">空位置（坑）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number"></span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认值"><span class="nav-number">1.</span> <span class="nav-text">默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与解构结合用"><span class="nav-number">1.1.</span> <span class="nav-text">与解构结合用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数默认值的位置"><span class="nav-number">1.2.</span> <span class="nav-text">参数默认值的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">1.3.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">1.4.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rest参数"><span class="nav-number">2.</span> <span class="nav-text">rest参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展运算符"><span class="nav-number">2.1.</span> <span class="nav-text">扩展运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#！扩展运算符作用"><span class="nav-number">2.2.</span> <span class="nav-text">！扩展运算符作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#name-属性"><span class="nav-number">3.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头函数"><span class="nav-number">4.</span> <span class="nav-text">箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#返回对象"><span class="nav-number">4.1.</span> <span class="nav-text">返回对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与解构"><span class="nav-number">4.2.</span> <span class="nav-text">与解构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简化回调"><span class="nav-number">4.3.</span> <span class="nav-text">简化回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与rest结合"><span class="nav-number">4.4.</span> <span class="nav-text">与rest结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">4.5.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arguments-super-target"><span class="nav-number">4.6.</span> <span class="nav-text">arguments,super,target</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尾调用优化"><span class="nav-number">5.</span> <span class="nav-text">尾调用优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尾递归"><span class="nav-number">6.</span> <span class="nav-text">尾递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#尾递归优化的实现"><span class="nav-number">6.1.</span> <span class="nav-text">尾递归优化的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象"><span class="nav-number"></span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性简洁表达"><span class="nav-number">1.</span> <span class="nav-text">属性简洁表达</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量中可用"><span class="nav-number">2.</span> <span class="nav-text">字面量中可用[]</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zqfmcl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
